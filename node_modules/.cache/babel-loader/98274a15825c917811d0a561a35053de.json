{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jsXdr = require(\"js-xdr\");\n\nvar XDR = _interopRequireWildcard(_jsXdr);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar types = XDR.config(function (xdr) {\n  // === xdr source ============================================================\n  //\n  //   enum ErrorCode\n  //   {\n  //       ERR_MISC = 0, // Unspecific error\n  //       ERR_DATA = 1, // Malformed data\n  //       ERR_CONF = 2, // Misconfiguration error\n  //       ERR_AUTH = 3, // Authentication failure\n  //       ERR_LOAD = 4  // System overloaded\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ErrorCode\", {\n    errMisc: 0,\n    errData: 1,\n    errConf: 2,\n    errAuth: 3,\n    errLoad: 4\n  }); // === xdr source ============================================================\n  //\n  //   struct Error\n  //   {\n  //       ErrorCode code;\n  //       string msg<100>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Error\", [[\"code\", xdr.lookup(\"ErrorCode\")], [\"msg\", xdr.string(100)]]); // === xdr source ============================================================\n  //\n  //   struct AuthCert\n  //   {\n  //       Curve25519Public pubkey;\n  //       uint64 expiration;\n  //       Signature sig;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AuthCert\", [[\"pubkey\", xdr.lookup(\"Curve25519Public\")], [\"expiration\", xdr.lookup(\"Uint64\")], [\"sig\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   struct Hello\n  //   {\n  //       uint32 ledgerVersion;\n  //       uint32 overlayVersion;\n  //       uint32 overlayMinVersion;\n  //       Hash networkID;\n  //       string versionStr<100>;\n  //       int listeningPort;\n  //       NodeID peerID;\n  //       AuthCert cert;\n  //       uint256 nonce;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Hello\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"overlayVersion\", xdr.lookup(\"Uint32\")], [\"overlayMinVersion\", xdr.lookup(\"Uint32\")], [\"networkId\", xdr.lookup(\"Hash\")], [\"versionStr\", xdr.string(100)], [\"listeningPort\", xdr.int()], [\"peerId\", xdr.lookup(\"NodeId\")], [\"cert\", xdr.lookup(\"AuthCert\")], [\"nonce\", xdr.lookup(\"Uint256\")]]); // === xdr source ============================================================\n  //\n  //   struct Auth\n  //   {\n  //       // Empty message, just to confirm\n  //       // establishment of MAC keys.\n  //       int unused;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Auth\", [[\"unused\", xdr.int()]]); // === xdr source ============================================================\n  //\n  //   enum IPAddrType\n  //   {\n  //       IPv4 = 0,\n  //       IPv6 = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"IpAddrType\", {\n    iPv4: 0,\n    iPv6: 1\n  }); // === xdr source ============================================================\n  //\n  //   union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"PeerAddressIp\", {\n    switchOn: xdr.lookup(\"IpAddrType\"),\n    switchName: \"type\",\n    switches: [[\"iPv4\", \"ipv4\"], [\"iPv6\", \"ipv6\"]],\n    arms: {\n      ipv4: xdr.opaque(4),\n      ipv6: xdr.opaque(16)\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct PeerAddress\n  //   {\n  //       union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //       ip;\n  //       uint32 port;\n  //       uint32 numFailures;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PeerAddress\", [[\"ip\", xdr.lookup(\"PeerAddressIp\")], [\"port\", xdr.lookup(\"Uint32\")], [\"numFailures\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   enum MessageType\n  //   {\n  //       ERROR_MSG = 0,\n  //       AUTH = 2,\n  //       DONT_HAVE = 3,\n  //   \n  //       GET_PEERS = 4, // gets a list of peers this guy knows about\n  //       PEERS = 5,\n  //   \n  //       GET_TX_SET = 6, // gets a particular txset by hash\n  //       TX_SET = 7,\n  //   \n  //       TRANSACTION = 8, // pass on a tx you have heard about\n  //   \n  //       // SCP\n  //       GET_SCP_QUORUMSET = 9,\n  //       SCP_QUORUMSET = 10,\n  //       SCP_MESSAGE = 11,\n  //       GET_SCP_STATE = 12,\n  //   \n  //       // new messages\n  //       HELLO = 13,\n  //   \n  //       SURVEY_REQUEST = 14,\n  //       SURVEY_RESPONSE = 15\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"MessageType\", {\n    errorMsg: 0,\n    auth: 2,\n    dontHave: 3,\n    getPeers: 4,\n    peers: 5,\n    getTxSet: 6,\n    txSet: 7,\n    transaction: 8,\n    getScpQuorumset: 9,\n    scpQuorumset: 10,\n    scpMessage: 11,\n    getScpState: 12,\n    hello: 13,\n    surveyRequest: 14,\n    surveyResponse: 15\n  }); // === xdr source ============================================================\n  //\n  //   struct DontHave\n  //   {\n  //       MessageType type;\n  //       uint256 reqHash;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"DontHave\", [[\"type\", xdr.lookup(\"MessageType\")], [\"reqHash\", xdr.lookup(\"Uint256\")]]); // === xdr source ============================================================\n  //\n  //   enum SurveyMessageCommandType\n  //   {\n  //       SURVEY_TOPOLOGY = 0\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"SurveyMessageCommandType\", {\n    surveyTopology: 0\n  }); // === xdr source ============================================================\n  //\n  //   struct SurveyRequestMessage\n  //   {\n  //       NodeID surveyorPeerID;\n  //       NodeID surveyedPeerID;\n  //       uint32 ledgerNum;\n  //       Curve25519Public encryptionKey;\n  //       SurveyMessageCommandType commandType;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SurveyRequestMessage\", [[\"surveyorPeerId\", xdr.lookup(\"NodeId\")], [\"surveyedPeerId\", xdr.lookup(\"NodeId\")], [\"ledgerNum\", xdr.lookup(\"Uint32\")], [\"encryptionKey\", xdr.lookup(\"Curve25519Public\")], [\"commandType\", xdr.lookup(\"SurveyMessageCommandType\")]]); // === xdr source ============================================================\n  //\n  //   struct SignedSurveyRequestMessage\n  //   {\n  //       Signature requestSignature;\n  //       SurveyRequestMessage request;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SignedSurveyRequestMessage\", [[\"requestSignature\", xdr.lookup(\"Signature\")], [\"request\", xdr.lookup(\"SurveyRequestMessage\")]]); // === xdr source ============================================================\n  //\n  //   typedef opaque EncryptedBody<64000>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"EncryptedBody\", xdr.varOpaque(64000)); // === xdr source ============================================================\n  //\n  //   struct SurveyResponseMessage\n  //   {\n  //       NodeID surveyorPeerID;\n  //       NodeID surveyedPeerID;\n  //       uint32 ledgerNum;\n  //       SurveyMessageCommandType commandType;\n  //       EncryptedBody encryptedBody;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SurveyResponseMessage\", [[\"surveyorPeerId\", xdr.lookup(\"NodeId\")], [\"surveyedPeerId\", xdr.lookup(\"NodeId\")], [\"ledgerNum\", xdr.lookup(\"Uint32\")], [\"commandType\", xdr.lookup(\"SurveyMessageCommandType\")], [\"encryptedBody\", xdr.lookup(\"EncryptedBody\")]]); // === xdr source ============================================================\n  //\n  //   struct SignedSurveyResponseMessage\n  //   {\n  //       Signature responseSignature;\n  //       SurveyResponseMessage response;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SignedSurveyResponseMessage\", [[\"responseSignature\", xdr.lookup(\"Signature\")], [\"response\", xdr.lookup(\"SurveyResponseMessage\")]]); // === xdr source ============================================================\n  //\n  //   struct PeerStats\n  //   {\n  //       NodeID id;\n  //       string versionStr<100>;\n  //       uint64 messagesRead;\n  //       uint64 messagesWritten;\n  //       uint64 bytesRead;\n  //       uint64 bytesWritten;\n  //       uint64 secondsConnected;\n  //   \n  //       uint64 uniqueFloodBytesRecv;\n  //       uint64 duplicateFloodBytesRecv;\n  //       uint64 uniqueFetchBytesRecv;\n  //       uint64 duplicateFetchBytesRecv;\n  //   \n  //       uint64 uniqueFloodMessageRecv;\n  //       uint64 duplicateFloodMessageRecv;\n  //       uint64 uniqueFetchMessageRecv;\n  //       uint64 duplicateFetchMessageRecv;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PeerStats\", [[\"id\", xdr.lookup(\"NodeId\")], [\"versionStr\", xdr.string(100)], [\"messagesRead\", xdr.lookup(\"Uint64\")], [\"messagesWritten\", xdr.lookup(\"Uint64\")], [\"bytesRead\", xdr.lookup(\"Uint64\")], [\"bytesWritten\", xdr.lookup(\"Uint64\")], [\"secondsConnected\", xdr.lookup(\"Uint64\")], [\"uniqueFloodBytesRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFloodBytesRecv\", xdr.lookup(\"Uint64\")], [\"uniqueFetchBytesRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFetchBytesRecv\", xdr.lookup(\"Uint64\")], [\"uniqueFloodMessageRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFloodMessageRecv\", xdr.lookup(\"Uint64\")], [\"uniqueFetchMessageRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFetchMessageRecv\", xdr.lookup(\"Uint64\")]]); // === xdr source ============================================================\n  //\n  //   typedef PeerStats PeerStatList<25>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"PeerStatList\", xdr.varArray(xdr.lookup(\"PeerStats\"), 25)); // === xdr source ============================================================\n  //\n  //   struct TopologyResponseBody\n  //   {\n  //       PeerStatList inboundPeers;\n  //       PeerStatList outboundPeers;\n  //   \n  //       uint32 totalInboundPeerCount;\n  //       uint32 totalOutboundPeerCount;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TopologyResponseBody\", [[\"inboundPeers\", xdr.lookup(\"PeerStatList\")], [\"outboundPeers\", xdr.lookup(\"PeerStatList\")], [\"totalInboundPeerCount\", xdr.lookup(\"Uint32\")], [\"totalOutboundPeerCount\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   union SurveyResponseBody switch (SurveyMessageCommandType type)\n  //   {\n  //   case SURVEY_TOPOLOGY:\n  //       TopologyResponseBody topologyResponseBody;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"SurveyResponseBody\", {\n    switchOn: xdr.lookup(\"SurveyMessageCommandType\"),\n    switchName: \"type\",\n    switches: [[\"surveyTopology\", \"topologyResponseBody\"]],\n    arms: {\n      topologyResponseBody: xdr.lookup(\"TopologyResponseBody\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union StellarMessage switch (MessageType type)\n  //   {\n  //   case ERROR_MSG:\n  //       Error error;\n  //   case HELLO:\n  //       Hello hello;\n  //   case AUTH:\n  //       Auth auth;\n  //   case DONT_HAVE:\n  //       DontHave dontHave;\n  //   case GET_PEERS:\n  //       void;\n  //   case PEERS:\n  //       PeerAddress peers<100>;\n  //   \n  //   case GET_TX_SET:\n  //       uint256 txSetHash;\n  //   case TX_SET:\n  //       TransactionSet txSet;\n  //   \n  //   case TRANSACTION:\n  //       TransactionEnvelope transaction;\n  //   \n  //   case SURVEY_REQUEST:\n  //       SignedSurveyRequestMessage signedSurveyRequestMessage;\n  //   \n  //   case SURVEY_RESPONSE:\n  //       SignedSurveyResponseMessage signedSurveyResponseMessage;\n  //   \n  //   // SCP\n  //   case GET_SCP_QUORUMSET:\n  //       uint256 qSetHash;\n  //   case SCP_QUORUMSET:\n  //       SCPQuorumSet qSet;\n  //   case SCP_MESSAGE:\n  //       SCPEnvelope envelope;\n  //   case GET_SCP_STATE:\n  //       uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"StellarMessage\", {\n    switchOn: xdr.lookup(\"MessageType\"),\n    switchName: \"type\",\n    switches: [[\"errorMsg\", \"error\"], [\"hello\", \"hello\"], [\"auth\", \"auth\"], [\"dontHave\", \"dontHave\"], [\"getPeers\", xdr.void()], [\"peers\", \"peers\"], [\"getTxSet\", \"txSetHash\"], [\"txSet\", \"txSet\"], [\"transaction\", \"transaction\"], [\"surveyRequest\", \"signedSurveyRequestMessage\"], [\"surveyResponse\", \"signedSurveyResponseMessage\"], [\"getScpQuorumset\", \"qSetHash\"], [\"scpQuorumset\", \"qSet\"], [\"scpMessage\", \"envelope\"], [\"getScpState\", \"getScpLedgerSeq\"]],\n    arms: {\n      error: xdr.lookup(\"Error\"),\n      hello: xdr.lookup(\"Hello\"),\n      auth: xdr.lookup(\"Auth\"),\n      dontHave: xdr.lookup(\"DontHave\"),\n      peers: xdr.varArray(xdr.lookup(\"PeerAddress\"), 100),\n      txSetHash: xdr.lookup(\"Uint256\"),\n      txSet: xdr.lookup(\"TransactionSet\"),\n      transaction: xdr.lookup(\"TransactionEnvelope\"),\n      signedSurveyRequestMessage: xdr.lookup(\"SignedSurveyRequestMessage\"),\n      signedSurveyResponseMessage: xdr.lookup(\"SignedSurveyResponseMessage\"),\n      qSetHash: xdr.lookup(\"Uint256\"),\n      qSet: xdr.lookup(\"ScpQuorumSet\"),\n      envelope: xdr.lookup(\"ScpEnvelope\"),\n      getScpLedgerSeq: xdr.lookup(\"Uint32\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           uint64 sequence;\n  //           StellarMessage message;\n  //           HmacSha256Mac mac;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AuthenticatedMessageV0\", [[\"sequence\", xdr.lookup(\"Uint64\")], [\"message\", xdr.lookup(\"StellarMessage\")], [\"mac\", xdr.lookup(\"HmacSha256Mac\")]]); // === xdr source ============================================================\n  //\n  //   union AuthenticatedMessage switch (uint32 v)\n  //   {\n  //   case 0:\n  //       struct\n  //       {\n  //           uint64 sequence;\n  //           StellarMessage message;\n  //           HmacSha256Mac mac;\n  //       } v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"AuthenticatedMessage\", {\n    switchOn: xdr.lookup(\"Uint32\"),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"AuthenticatedMessageV0\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   typedef opaque Hash[32];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Hash\", xdr.opaque(32)); // === xdr source ============================================================\n  //\n  //   typedef opaque uint256[32];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Uint256\", xdr.opaque(32)); // === xdr source ============================================================\n  //\n  //   typedef unsigned int uint32;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Uint32\", xdr.uint()); // === xdr source ============================================================\n  //\n  //   typedef int int32;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Int32\", xdr.int()); // === xdr source ============================================================\n  //\n  //   typedef unsigned hyper uint64;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Uint64\", xdr.uhyper()); // === xdr source ============================================================\n  //\n  //   typedef hyper int64;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Int64\", xdr.hyper()); // === xdr source ============================================================\n  //\n  //   enum CryptoKeyType\n  //   {\n  //       KEY_TYPE_ED25519 = 0,\n  //       KEY_TYPE_PRE_AUTH_TX = 1,\n  //       KEY_TYPE_HASH_X = 2,\n  //       // MUXED enum values for supported type are derived from the enum values\n  //       // above by ORing them with 0x100\n  //       KEY_TYPE_MUXED_ED25519 = 0x100\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"CryptoKeyType\", {\n    keyTypeEd25519: 0,\n    keyTypePreAuthTx: 1,\n    keyTypeHashX: 2,\n    keyTypeMuxedEd25519: 256\n  }); // === xdr source ============================================================\n  //\n  //   enum PublicKeyType\n  //   {\n  //       PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PublicKeyType\", {\n    publicKeyTypeEd25519: 0\n  }); // === xdr source ============================================================\n  //\n  //   enum SignerKeyType\n  //   {\n  //       SIGNER_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,\n  //       SIGNER_KEY_TYPE_PRE_AUTH_TX = KEY_TYPE_PRE_AUTH_TX,\n  //       SIGNER_KEY_TYPE_HASH_X = KEY_TYPE_HASH_X\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"SignerKeyType\", {\n    signerKeyTypeEd25519: 0,\n    signerKeyTypePreAuthTx: 1,\n    signerKeyTypeHashX: 2\n  }); // === xdr source ============================================================\n  //\n  //   union PublicKey switch (PublicKeyType type)\n  //   {\n  //   case PUBLIC_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PublicKey\", {\n    switchOn: xdr.lookup(\"PublicKeyType\"),\n    switchName: \"type\",\n    switches: [[\"publicKeyTypeEd25519\", \"ed25519\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union SignerKey switch (SignerKeyType type)\n  //   {\n  //   case SIGNER_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   case SIGNER_KEY_TYPE_PRE_AUTH_TX:\n  //       /* SHA-256 Hash of TransactionSignaturePayload structure */\n  //       uint256 preAuthTx;\n  //   case SIGNER_KEY_TYPE_HASH_X:\n  //       /* Hash of random 256 bit preimage X */\n  //       uint256 hashX;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"SignerKey\", {\n    switchOn: xdr.lookup(\"SignerKeyType\"),\n    switchName: \"type\",\n    switches: [[\"signerKeyTypeEd25519\", \"ed25519\"], [\"signerKeyTypePreAuthTx\", \"preAuthTx\"], [\"signerKeyTypeHashX\", \"hashX\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\"),\n      preAuthTx: xdr.lookup(\"Uint256\"),\n      hashX: xdr.lookup(\"Uint256\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   typedef opaque Signature<64>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Signature\", xdr.varOpaque(64)); // === xdr source ============================================================\n  //\n  //   typedef opaque SignatureHint[4];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"SignatureHint\", xdr.opaque(4)); // === xdr source ============================================================\n  //\n  //   typedef PublicKey NodeID;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"NodeId\", xdr.lookup(\"PublicKey\")); // === xdr source ============================================================\n  //\n  //   struct Curve25519Secret\n  //   {\n  //       opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Curve25519Secret\", [[\"key\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct Curve25519Public\n  //   {\n  //       opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Curve25519Public\", [[\"key\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct HmacSha256Key\n  //   {\n  //       opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"HmacSha256Key\", [[\"key\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct HmacSha256Mac\n  //   {\n  //       opaque mac[32];\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"HmacSha256Mac\", [[\"mac\", xdr.opaque(32)]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           uint64 id;\n  //           uint256 ed25519;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"MuxedAccountMed25519\", [[\"id\", xdr.lookup(\"Uint64\")], [\"ed25519\", xdr.lookup(\"Uint256\")]]); // === xdr source ============================================================\n  //\n  //   union MuxedAccount switch (CryptoKeyType type)\n  //   {\n  //   case KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   case KEY_TYPE_MUXED_ED25519:\n  //       struct\n  //       {\n  //           uint64 id;\n  //           uint256 ed25519;\n  //       } med25519;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"MuxedAccount\", {\n    switchOn: xdr.lookup(\"CryptoKeyType\"),\n    switchName: \"type\",\n    switches: [[\"keyTypeEd25519\", \"ed25519\"], [\"keyTypeMuxedEd25519\", \"med25519\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\"),\n      med25519: xdr.lookup(\"MuxedAccountMed25519\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct DecoratedSignature\n  //   {\n  //       SignatureHint hint;  // last 4 bytes of the public key, used as a hint\n  //       Signature signature; // actual signature\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"DecoratedSignature\", [[\"hint\", xdr.lookup(\"SignatureHint\")], [\"signature\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   enum OperationType\n  //   {\n  //       CREATE_ACCOUNT = 0,\n  //       PAYMENT = 1,\n  //       PATH_PAYMENT_STRICT_RECEIVE = 2,\n  //       MANAGE_SELL_OFFER = 3,\n  //       CREATE_PASSIVE_SELL_OFFER = 4,\n  //       SET_OPTIONS = 5,\n  //       CHANGE_TRUST = 6,\n  //       ALLOW_TRUST = 7,\n  //       ACCOUNT_MERGE = 8,\n  //       INFLATION = 9,\n  //       MANAGE_DATA = 10,\n  //       BUMP_SEQUENCE = 11,\n  //       MANAGE_BUY_OFFER = 12,\n  //       PATH_PAYMENT_STRICT_SEND = 13,\n  //       CREATE_CLAIMABLE_BALANCE = 14,\n  //       CLAIM_CLAIMABLE_BALANCE = 15,\n  //       BEGIN_SPONSORING_FUTURE_RESERVES = 16,\n  //       END_SPONSORING_FUTURE_RESERVES = 17,\n  //       REVOKE_SPONSORSHIP = 18\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"OperationType\", {\n    createAccount: 0,\n    payment: 1,\n    pathPaymentStrictReceive: 2,\n    manageSellOffer: 3,\n    createPassiveSellOffer: 4,\n    setOptions: 5,\n    changeTrust: 6,\n    allowTrust: 7,\n    accountMerge: 8,\n    inflation: 9,\n    manageData: 10,\n    bumpSequence: 11,\n    manageBuyOffer: 12,\n    pathPaymentStrictSend: 13,\n    createClaimableBalance: 14,\n    claimClaimableBalance: 15,\n    beginSponsoringFutureReserves: 16,\n    endSponsoringFutureReserves: 17,\n    revokeSponsorship: 18\n  }); // === xdr source ============================================================\n  //\n  //   struct CreateAccountOp\n  //   {\n  //       AccountID destination; // account to create\n  //       int64 startingBalance; // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"CreateAccountOp\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"startingBalance\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct PaymentOp\n  //   {\n  //       MuxedAccount destination; // recipient of the payment\n  //       Asset asset;              // what they end up with\n  //       int64 amount;             // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PaymentOp\", [[\"destination\", xdr.lookup(\"MuxedAccount\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct PathPaymentStrictReceiveOp\n  //   {\n  //       Asset sendAsset; // asset we pay with\n  //       int64 sendMax;   // the maximum amount of sendAsset to\n  //                        // send (excluding fees).\n  //                        // The operation will fail if can't be met\n  //   \n  //       MuxedAccount destination; // recipient of the payment\n  //       Asset destAsset;          // what they end up with\n  //       int64 destAmount;         // amount they end up with\n  //   \n  //       Asset path<5>; // additional hops it must go through to get there\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PathPaymentStrictReceiveOp\", [[\"sendAsset\", xdr.lookup(\"Asset\")], [\"sendMax\", xdr.lookup(\"Int64\")], [\"destination\", xdr.lookup(\"MuxedAccount\")], [\"destAsset\", xdr.lookup(\"Asset\")], [\"destAmount\", xdr.lookup(\"Int64\")], [\"path\", xdr.varArray(xdr.lookup(\"Asset\"), 5)]]); // === xdr source ============================================================\n  //\n  //   struct PathPaymentStrictSendOp\n  //   {\n  //       Asset sendAsset;  // asset we pay with\n  //       int64 sendAmount; // amount of sendAsset to send (excluding fees)\n  //   \n  //       MuxedAccount destination; // recipient of the payment\n  //       Asset destAsset;          // what they end up with\n  //       int64 destMin;            // the minimum amount of dest asset to\n  //                                 // be received\n  //                                 // The operation will fail if it can't be met\n  //   \n  //       Asset path<5>; // additional hops it must go through to get there\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PathPaymentStrictSendOp\", [[\"sendAsset\", xdr.lookup(\"Asset\")], [\"sendAmount\", xdr.lookup(\"Int64\")], [\"destination\", xdr.lookup(\"MuxedAccount\")], [\"destAsset\", xdr.lookup(\"Asset\")], [\"destMin\", xdr.lookup(\"Int64\")], [\"path\", xdr.varArray(xdr.lookup(\"Asset\"), 5)]]); // === xdr source ============================================================\n  //\n  //   struct ManageSellOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 amount; // amount being sold. if set to 0, delete the offer\n  //       Price price;  // price of thing being sold in terms of what you are buying\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct ManageBuyOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 buyAmount; // amount being bought. if set to 0, delete the offer\n  //       Price price;     // price of thing being bought in terms of what you are\n  //                        // selling\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageBuyOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"buyAmount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct CreatePassiveSellOfferOp\n  //   {\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount taker gets. if set to 0, delete the offer\n  //       Price price;   // cost of A in terms of B\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"CreatePassiveSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")]]); // === xdr source ============================================================\n  //\n  //   struct SetOptionsOp\n  //   {\n  //       AccountID* inflationDest; // sets the inflation destination\n  //   \n  //       uint32* clearFlags; // which flags to clear\n  //       uint32* setFlags;   // which flags to set\n  //   \n  //       // account threshold manipulation\n  //       uint32* masterWeight; // weight of the master account\n  //       uint32* lowThreshold;\n  //       uint32* medThreshold;\n  //       uint32* highThreshold;\n  //   \n  //       string32* homeDomain; // sets the home domain\n  //   \n  //       // Add, update or remove a signer for the account\n  //       // signer is deleted if the weight is 0\n  //       Signer* signer;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SetOptionsOp\", [[\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"clearFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"setFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"masterWeight\", xdr.option(xdr.lookup(\"Uint32\"))], [\"lowThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"medThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"highThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"homeDomain\", xdr.option(xdr.lookup(\"String32\"))], [\"signer\", xdr.option(xdr.lookup(\"Signer\"))]]); // === xdr source ============================================================\n  //\n  //   struct ChangeTrustOp\n  //   {\n  //       Asset line;\n  //   \n  //       // if limit is set to 0, deletes the trust line\n  //       int64 limit;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ChangeTrustOp\", [[\"line\", xdr.lookup(\"Asset\")], [\"limit\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AllowTrustOpAsset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeCreditAlphanum4\", \"assetCode4\"], [\"assetTypeCreditAlphanum12\", \"assetCode12\"]],\n    arms: {\n      assetCode4: xdr.lookup(\"AssetCode4\"),\n      assetCode12: xdr.lookup(\"AssetCode12\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct AllowTrustOp\n  //   {\n  //       AccountID trustor;\n  //       union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //       asset;\n  //   \n  //       // 0, or any bitwise combination of TrustLineFlags\n  //       uint32 authorize;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AllowTrustOp\", [[\"trustor\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"AllowTrustOpAsset\")], [\"authorize\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   struct ManageDataOp\n  //   {\n  //       string64 dataName;\n  //       DataValue* dataValue; // set to null to clear\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageDataOp\", [[\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.option(xdr.lookup(\"DataValue\"))]]); // === xdr source ============================================================\n  //\n  //   struct BumpSequenceOp\n  //   {\n  //       SequenceNumber bumpTo;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"BumpSequenceOp\", [[\"bumpTo\", xdr.lookup(\"SequenceNumber\")]]); // === xdr source ============================================================\n  //\n  //   struct CreateClaimableBalanceOp\n  //   {\n  //       Asset asset;\n  //       int64 amount;\n  //       Claimant claimants<10>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"CreateClaimableBalanceOp\", [[\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"claimants\", xdr.varArray(xdr.lookup(\"Claimant\"), 10)]]); // === xdr source ============================================================\n  //\n  //   struct ClaimClaimableBalanceOp\n  //   {\n  //       ClaimableBalanceID balanceID;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ClaimClaimableBalanceOp\", [[\"balanceId\", xdr.lookup(\"ClaimableBalanceId\")]]); // === xdr source ============================================================\n  //\n  //   struct BeginSponsoringFutureReservesOp\n  //   {\n  //       AccountID sponsoredID;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"BeginSponsoringFutureReservesOp\", [[\"sponsoredId\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   enum RevokeSponsorshipType\n  //   {\n  //       REVOKE_SPONSORSHIP_LEDGER_ENTRY = 0,\n  //       REVOKE_SPONSORSHIP_SIGNER = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"RevokeSponsorshipType\", {\n    revokeSponsorshipLedgerEntry: 0,\n    revokeSponsorshipSigner: 1\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           SignerKey signerKey;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"RevokeSponsorshipOpSigner\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"signerKey\", xdr.lookup(\"SignerKey\")]]); // === xdr source ============================================================\n  //\n  //   union RevokeSponsorshipOp switch (RevokeSponsorshipType type)\n  //   {\n  //   case REVOKE_SPONSORSHIP_LEDGER_ENTRY:\n  //       LedgerKey ledgerKey;\n  //   case REVOKE_SPONSORSHIP_SIGNER:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           SignerKey signerKey;\n  //       }\n  //       signer;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"RevokeSponsorshipOp\", {\n    switchOn: xdr.lookup(\"RevokeSponsorshipType\"),\n    switchName: \"type\",\n    switches: [[\"revokeSponsorshipLedgerEntry\", \"ledgerKey\"], [\"revokeSponsorshipSigner\", \"signer\"]],\n    arms: {\n      ledgerKey: xdr.lookup(\"LedgerKey\"),\n      signer: xdr.lookup(\"RevokeSponsorshipOpSigner\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           MuxedAccount destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendOp pathPaymentStrictSendOp;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceOp createClaimableBalanceOp;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceOp claimClaimableBalanceOp;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           void;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipOp revokeSponsorshipOp;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationBody\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountOp\"], [\"payment\", \"paymentOp\"], [\"pathPaymentStrictReceive\", \"pathPaymentStrictReceiveOp\"], [\"manageSellOffer\", \"manageSellOfferOp\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferOp\"], [\"setOptions\", \"setOptionsOp\"], [\"changeTrust\", \"changeTrustOp\"], [\"allowTrust\", \"allowTrustOp\"], [\"accountMerge\", \"destination\"], [\"inflation\", xdr.void()], [\"manageData\", \"manageDataOp\"], [\"bumpSequence\", \"bumpSequenceOp\"], [\"manageBuyOffer\", \"manageBuyOfferOp\"], [\"pathPaymentStrictSend\", \"pathPaymentStrictSendOp\"], [\"createClaimableBalance\", \"createClaimableBalanceOp\"], [\"claimClaimableBalance\", \"claimClaimableBalanceOp\"], [\"beginSponsoringFutureReserves\", \"beginSponsoringFutureReservesOp\"], [\"endSponsoringFutureReserves\", xdr.void()], [\"revokeSponsorship\", \"revokeSponsorshipOp\"]],\n    arms: {\n      createAccountOp: xdr.lookup(\"CreateAccountOp\"),\n      paymentOp: xdr.lookup(\"PaymentOp\"),\n      pathPaymentStrictReceiveOp: xdr.lookup(\"PathPaymentStrictReceiveOp\"),\n      manageSellOfferOp: xdr.lookup(\"ManageSellOfferOp\"),\n      createPassiveSellOfferOp: xdr.lookup(\"CreatePassiveSellOfferOp\"),\n      setOptionsOp: xdr.lookup(\"SetOptionsOp\"),\n      changeTrustOp: xdr.lookup(\"ChangeTrustOp\"),\n      allowTrustOp: xdr.lookup(\"AllowTrustOp\"),\n      destination: xdr.lookup(\"MuxedAccount\"),\n      manageDataOp: xdr.lookup(\"ManageDataOp\"),\n      bumpSequenceOp: xdr.lookup(\"BumpSequenceOp\"),\n      manageBuyOfferOp: xdr.lookup(\"ManageBuyOfferOp\"),\n      pathPaymentStrictSendOp: xdr.lookup(\"PathPaymentStrictSendOp\"),\n      createClaimableBalanceOp: xdr.lookup(\"CreateClaimableBalanceOp\"),\n      claimClaimableBalanceOp: xdr.lookup(\"ClaimClaimableBalanceOp\"),\n      beginSponsoringFutureReservesOp: xdr.lookup(\"BeginSponsoringFutureReservesOp\"),\n      revokeSponsorshipOp: xdr.lookup(\"RevokeSponsorshipOp\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct Operation\n  //   {\n  //       // sourceAccount is the account used to run the operation\n  //       // if not set, the runtime defaults to \"sourceAccount\" specified at\n  //       // the transaction level\n  //       MuxedAccount* sourceAccount;\n  //   \n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           MuxedAccount destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendOp pathPaymentStrictSendOp;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceOp createClaimableBalanceOp;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceOp claimClaimableBalanceOp;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           void;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipOp revokeSponsorshipOp;\n  //       }\n  //       body;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Operation\", [[\"sourceAccount\", xdr.option(xdr.lookup(\"MuxedAccount\"))], [\"body\", xdr.lookup(\"OperationBody\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           MuxedAccount sourceAccount;\n  //           SequenceNumber seqNum;\n  //           uint32 opNum;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"OperationIdId\", [[\"sourceAccount\", xdr.lookup(\"MuxedAccount\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"opNum\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   union OperationID switch (EnvelopeType type)\n  //   {\n  //   case ENVELOPE_TYPE_OP_ID:\n  //       struct\n  //       {\n  //           MuxedAccount sourceAccount;\n  //           SequenceNumber seqNum;\n  //           uint32 opNum;\n  //       } id;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationId\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeOpId\", \"id\"]],\n    arms: {\n      id: xdr.lookup(\"OperationIdId\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum MemoType\n  //   {\n  //       MEMO_NONE = 0,\n  //       MEMO_TEXT = 1,\n  //       MEMO_ID = 2,\n  //       MEMO_HASH = 3,\n  //       MEMO_RETURN = 4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"MemoType\", {\n    memoNone: 0,\n    memoText: 1,\n    memoId: 2,\n    memoHash: 3,\n    memoReturn: 4\n  }); // === xdr source ============================================================\n  //\n  //   union Memo switch (MemoType type)\n  //   {\n  //   case MEMO_NONE:\n  //       void;\n  //   case MEMO_TEXT:\n  //       string text<28>;\n  //   case MEMO_ID:\n  //       uint64 id;\n  //   case MEMO_HASH:\n  //       Hash hash; // the hash of what to pull from the content server\n  //   case MEMO_RETURN:\n  //       Hash retHash; // the hash of the tx you are rejecting\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"Memo\", {\n    switchOn: xdr.lookup(\"MemoType\"),\n    switchName: \"type\",\n    switches: [[\"memoNone\", xdr.void()], [\"memoText\", \"text\"], [\"memoId\", \"id\"], [\"memoHash\", \"hash\"], [\"memoReturn\", \"retHash\"]],\n    arms: {\n      text: xdr.string(28),\n      id: xdr.lookup(\"Uint64\"),\n      hash: xdr.lookup(\"Hash\"),\n      retHash: xdr.lookup(\"Hash\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TimeBounds\n  //   {\n  //       TimePoint minTime;\n  //       TimePoint maxTime; // 0 here means no maxTime\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TimeBounds\", [[\"minTime\", xdr.lookup(\"TimePoint\")], [\"maxTime\", xdr.lookup(\"TimePoint\")]]); // === xdr source ============================================================\n  //\n  //   const MAX_OPS_PER_TX = 100;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MAX_OPS_PER_TX\", 100); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionV0Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionV0\n  //   {\n  //       uint256 sourceAccountEd25519;\n  //       uint32 fee;\n  //       SequenceNumber seqNum;\n  //       TimeBounds* timeBounds;\n  //       Memo memo;\n  //       Operation operations<MAX_OPS_PER_TX>;\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionV0\", [[\"sourceAccountEd25519\", xdr.lookup(\"Uint256\")], [\"fee\", xdr.lookup(\"Uint32\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"timeBounds\", xdr.option(xdr.lookup(\"TimeBounds\"))], [\"memo\", xdr.lookup(\"Memo\")], [\"operations\", xdr.varArray(xdr.lookup(\"Operation\"), xdr.lookup(\"MAX_OPS_PER_TX\"))], [\"ext\", xdr.lookup(\"TransactionV0Ext\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionV0Envelope\n  //   {\n  //       TransactionV0 tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionV0Envelope\", [[\"tx\", xdr.lookup(\"TransactionV0\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct Transaction\n  //   {\n  //       // account used to run the transaction\n  //       MuxedAccount sourceAccount;\n  //   \n  //       // the fee the sourceAccount will pay\n  //       uint32 fee;\n  //   \n  //       // sequence number to consume in the account\n  //       SequenceNumber seqNum;\n  //   \n  //       // validity range (inclusive) for the last ledger close time\n  //       TimeBounds* timeBounds;\n  //   \n  //       Memo memo;\n  //   \n  //       Operation operations<MAX_OPS_PER_TX>;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Transaction\", [[\"sourceAccount\", xdr.lookup(\"MuxedAccount\")], [\"fee\", xdr.lookup(\"Uint32\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"timeBounds\", xdr.option(xdr.lookup(\"TimeBounds\"))], [\"memo\", xdr.lookup(\"Memo\")], [\"operations\", xdr.varArray(xdr.lookup(\"Operation\"), xdr.lookup(\"MAX_OPS_PER_TX\"))], [\"ext\", xdr.lookup(\"TransactionExt\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionV1Envelope\n  //   {\n  //       Transaction tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionV1Envelope\", [[\"tx\", xdr.lookup(\"Transaction\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]); // === xdr source ============================================================\n  //\n  //   union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           TransactionV1Envelope v1;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"FeeBumpTransactionInnerTx\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTx\", \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"TransactionV1Envelope\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"FeeBumpTransactionExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct FeeBumpTransaction\n  //   {\n  //       MuxedAccount feeSource;\n  //       int64 fee;\n  //       union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           TransactionV1Envelope v1;\n  //       }\n  //       innerTx;\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"FeeBumpTransaction\", [[\"feeSource\", xdr.lookup(\"MuxedAccount\")], [\"fee\", xdr.lookup(\"Int64\")], [\"innerTx\", xdr.lookup(\"FeeBumpTransactionInnerTx\")], [\"ext\", xdr.lookup(\"FeeBumpTransactionExt\")]]); // === xdr source ============================================================\n  //\n  //   struct FeeBumpTransactionEnvelope\n  //   {\n  //       FeeBumpTransaction tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"FeeBumpTransactionEnvelope\", [[\"tx\", xdr.lookup(\"FeeBumpTransaction\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]); // === xdr source ============================================================\n  //\n  //   union TransactionEnvelope switch (EnvelopeType type)\n  //   {\n  //   case ENVELOPE_TYPE_TX_V0:\n  //       TransactionV0Envelope v0;\n  //   case ENVELOPE_TYPE_TX:\n  //       TransactionV1Envelope v1;\n  //   case ENVELOPE_TYPE_TX_FEE_BUMP:\n  //       FeeBumpTransactionEnvelope feeBump;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionEnvelope\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTxV0\", \"v0\"], [\"envelopeTypeTx\", \"v1\"], [\"envelopeTypeTxFeeBump\", \"feeBump\"]],\n    arms: {\n      v0: xdr.lookup(\"TransactionV0Envelope\"),\n      v1: xdr.lookup(\"TransactionV1Envelope\"),\n      feeBump: xdr.lookup(\"FeeBumpTransactionEnvelope\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (EnvelopeType type)\n  //       {\n  //       // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //       case ENVELOPE_TYPE_TX_FEE_BUMP:\n  //           FeeBumpTransaction feeBump;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionSignaturePayloadTaggedTransaction\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTx\", \"tx\"], [\"envelopeTypeTxFeeBump\", \"feeBump\"]],\n    arms: {\n      tx: xdr.lookup(\"Transaction\"),\n      feeBump: xdr.lookup(\"FeeBumpTransaction\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionSignaturePayload\n  //   {\n  //       Hash networkId;\n  //       union switch (EnvelopeType type)\n  //       {\n  //       // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //       case ENVELOPE_TYPE_TX_FEE_BUMP:\n  //           FeeBumpTransaction feeBump;\n  //       }\n  //       taggedTransaction;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionSignaturePayload\", [[\"networkId\", xdr.lookup(\"Hash\")], [\"taggedTransaction\", xdr.lookup(\"TransactionSignaturePayloadTaggedTransaction\")]]); // === xdr source ============================================================\n  //\n  //   struct ClaimOfferAtom\n  //   {\n  //       // emitted to identify the offer\n  //       AccountID sellerID; // Account that owns the offer\n  //       int64 offerID;\n  //   \n  //       // amount and asset taken from the owner\n  //       Asset assetSold;\n  //       int64 amountSold;\n  //   \n  //       // amount and asset sent to the owner\n  //       Asset assetBought;\n  //       int64 amountBought;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ClaimOfferAtom\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"assetSold\", xdr.lookup(\"Asset\")], [\"amountSold\", xdr.lookup(\"Int64\")], [\"assetBought\", xdr.lookup(\"Asset\")], [\"amountBought\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   enum CreateAccountResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CREATE_ACCOUNT_SUCCESS = 0, // account was created\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       CREATE_ACCOUNT_MALFORMED = -1,   // invalid destination\n  //       CREATE_ACCOUNT_UNDERFUNDED = -2, // not enough funds in source account\n  //       CREATE_ACCOUNT_LOW_RESERVE =\n  //           -3, // would create an account below the min reserve\n  //       CREATE_ACCOUNT_ALREADY_EXIST = -4 // account already exists\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"CreateAccountResultCode\", {\n    createAccountSuccess: 0,\n    createAccountMalformed: -1,\n    createAccountUnderfunded: -2,\n    createAccountLowReserve: -3,\n    createAccountAlreadyExist: -4\n  }); // === xdr source ============================================================\n  //\n  //   union CreateAccountResult switch (CreateAccountResultCode code)\n  //   {\n  //   case CREATE_ACCOUNT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"CreateAccountResult\", {\n    switchOn: xdr.lookup(\"CreateAccountResultCode\"),\n    switchName: \"code\",\n    switches: [[\"createAccountSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum PaymentResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PAYMENT_SUCCESS = 0, // payment successfuly completed\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PAYMENT_MALFORMED = -1,          // bad input\n  //       PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account\n  //       PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account\n  //       PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer\n  //       PAYMENT_NO_DESTINATION = -5,     // destination account does not exist\n  //       PAYMENT_NO_TRUST = -6,       // destination missing a trust line for asset\n  //       PAYMENT_NOT_AUTHORIZED = -7, // destination not authorized to hold asset\n  //       PAYMENT_LINE_FULL = -8,      // destination would go above their limit\n  //       PAYMENT_NO_ISSUER = -9       // missing issuer on asset\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PaymentResultCode\", {\n    paymentSuccess: 0,\n    paymentMalformed: -1,\n    paymentUnderfunded: -2,\n    paymentSrcNoTrust: -3,\n    paymentSrcNotAuthorized: -4,\n    paymentNoDestination: -5,\n    paymentNoTrust: -6,\n    paymentNotAuthorized: -7,\n    paymentLineFull: -8,\n    paymentNoIssuer: -9\n  }); // === xdr source ============================================================\n  //\n  //   union PaymentResult switch (PaymentResultCode code)\n  //   {\n  //   case PAYMENT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PaymentResult\", {\n    switchOn: xdr.lookup(\"PaymentResultCode\"),\n    switchName: \"code\",\n    switches: [[\"paymentSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum PathPaymentStrictReceiveResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PATH_PAYMENT_STRICT_RECEIVE_SUCCESS = 0, // success\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PATH_PAYMENT_STRICT_RECEIVE_MALFORMED = -1, // bad input\n  //       PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED =\n  //           -2, // not enough funds in source account\n  //       PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST =\n  //           -3, // no trust line on source account\n  //       PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED =\n  //           -4, // source not authorized to transfer\n  //       PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION =\n  //           -5, // destination account does not exist\n  //       PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST =\n  //           -6, // dest missing a trust line for asset\n  //       PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED =\n  //           -7, // dest not authorized to hold asset\n  //       PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL =\n  //           -8, // dest would go above their limit\n  //       PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER = -9, // missing issuer on one asset\n  //       PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS =\n  //           -10, // not enough offers to satisfy path\n  //       PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF =\n  //           -11, // would cross one of its own offers\n  //       PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX = -12 // could not satisfy sendmax\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PathPaymentStrictReceiveResultCode\", {\n    pathPaymentStrictReceiveSuccess: 0,\n    pathPaymentStrictReceiveMalformed: -1,\n    pathPaymentStrictReceiveUnderfunded: -2,\n    pathPaymentStrictReceiveSrcNoTrust: -3,\n    pathPaymentStrictReceiveSrcNotAuthorized: -4,\n    pathPaymentStrictReceiveNoDestination: -5,\n    pathPaymentStrictReceiveNoTrust: -6,\n    pathPaymentStrictReceiveNotAuthorized: -7,\n    pathPaymentStrictReceiveLineFull: -8,\n    pathPaymentStrictReceiveNoIssuer: -9,\n    pathPaymentStrictReceiveTooFewOffers: -10,\n    pathPaymentStrictReceiveOfferCrossSelf: -11,\n    pathPaymentStrictReceiveOverSendmax: -12\n  }); // === xdr source ============================================================\n  //\n  //   struct SimplePaymentResult\n  //   {\n  //       AccountID destination;\n  //       Asset asset;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"SimplePaymentResult\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PathPaymentStrictReceiveResultSuccess\", [[\"offers\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"last\", xdr.lookup(\"SimplePaymentResult\")]]); // === xdr source ============================================================\n  //\n  //   union PathPaymentStrictReceiveResult switch (PathPaymentStrictReceiveResultCode code)\n  //   {\n  //   case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:\n  //       struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       } success;\n  //   case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:\n  //       Asset noIssuer; // the asset that caused the error\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PathPaymentStrictReceiveResult\", {\n    switchOn: xdr.lookup(\"PathPaymentStrictReceiveResultCode\"),\n    switchName: \"code\",\n    switches: [[\"pathPaymentStrictReceiveSuccess\", \"success\"], [\"pathPaymentStrictReceiveNoIssuer\", \"noIssuer\"]],\n    arms: {\n      success: xdr.lookup(\"PathPaymentStrictReceiveResultSuccess\"),\n      noIssuer: xdr.lookup(\"Asset\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum PathPaymentStrictSendResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PATH_PAYMENT_STRICT_SEND_SUCCESS = 0, // success\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PATH_PAYMENT_STRICT_SEND_MALFORMED = -1, // bad input\n  //       PATH_PAYMENT_STRICT_SEND_UNDERFUNDED =\n  //           -2, // not enough funds in source account\n  //       PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST =\n  //           -3, // no trust line on source account\n  //       PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED =\n  //           -4, // source not authorized to transfer\n  //       PATH_PAYMENT_STRICT_SEND_NO_DESTINATION =\n  //           -5, // destination account does not exist\n  //       PATH_PAYMENT_STRICT_SEND_NO_TRUST =\n  //           -6, // dest missing a trust line for asset\n  //       PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED =\n  //           -7, // dest not authorized to hold asset\n  //       PATH_PAYMENT_STRICT_SEND_LINE_FULL = -8, // dest would go above their limit\n  //       PATH_PAYMENT_STRICT_SEND_NO_ISSUER = -9, // missing issuer on one asset\n  //       PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS =\n  //           -10, // not enough offers to satisfy path\n  //       PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF =\n  //           -11, // would cross one of its own offers\n  //       PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN = -12 // could not satisfy destMin\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"PathPaymentStrictSendResultCode\", {\n    pathPaymentStrictSendSuccess: 0,\n    pathPaymentStrictSendMalformed: -1,\n    pathPaymentStrictSendUnderfunded: -2,\n    pathPaymentStrictSendSrcNoTrust: -3,\n    pathPaymentStrictSendSrcNotAuthorized: -4,\n    pathPaymentStrictSendNoDestination: -5,\n    pathPaymentStrictSendNoTrust: -6,\n    pathPaymentStrictSendNotAuthorized: -7,\n    pathPaymentStrictSendLineFull: -8,\n    pathPaymentStrictSendNoIssuer: -9,\n    pathPaymentStrictSendTooFewOffers: -10,\n    pathPaymentStrictSendOfferCrossSelf: -11,\n    pathPaymentStrictSendUnderDestmin: -12\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"PathPaymentStrictSendResultSuccess\", [[\"offers\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"last\", xdr.lookup(\"SimplePaymentResult\")]]); // === xdr source ============================================================\n  //\n  //   union PathPaymentStrictSendResult switch (PathPaymentStrictSendResultCode code)\n  //   {\n  //   case PATH_PAYMENT_STRICT_SEND_SUCCESS:\n  //       struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       } success;\n  //   case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:\n  //       Asset noIssuer; // the asset that caused the error\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"PathPaymentStrictSendResult\", {\n    switchOn: xdr.lookup(\"PathPaymentStrictSendResultCode\"),\n    switchName: \"code\",\n    switches: [[\"pathPaymentStrictSendSuccess\", \"success\"], [\"pathPaymentStrictSendNoIssuer\", \"noIssuer\"]],\n    arms: {\n      success: xdr.lookup(\"PathPaymentStrictSendResultSuccess\"),\n      noIssuer: xdr.lookup(\"Asset\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageSellOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_SELL_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_SELL_OFFER_MALFORMED = -1, // generated offer would be invalid\n  //       MANAGE_SELL_OFFER_SELL_NO_TRUST =\n  //           -2,                              // no trust line for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_TRUST = -3, // no trust line for what we're buying\n  //       MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_SELL_OFFER_LINE_FULL = -6, // can't receive more of what it's buying\n  //       MANAGE_SELL_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell\n  //       MANAGE_SELL_OFFER_CROSS_SELF =\n  //           -8, // would cross an offer from the same user\n  //       MANAGE_SELL_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_SELL_OFFER_NOT_FOUND =\n  //           -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_SELL_OFFER_LOW_RESERVE =\n  //           -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageSellOfferResultCode\", {\n    manageSellOfferSuccess: 0,\n    manageSellOfferMalformed: -1,\n    manageSellOfferSellNoTrust: -2,\n    manageSellOfferBuyNoTrust: -3,\n    manageSellOfferSellNotAuthorized: -4,\n    manageSellOfferBuyNotAuthorized: -5,\n    manageSellOfferLineFull: -6,\n    manageSellOfferUnderfunded: -7,\n    manageSellOfferCrossSelf: -8,\n    manageSellOfferSellNoIssuer: -9,\n    manageSellOfferBuyNoIssuer: -10,\n    manageSellOfferNotFound: -11,\n    manageSellOfferLowReserve: -12\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageOfferEffect\n  //   {\n  //       MANAGE_OFFER_CREATED = 0,\n  //       MANAGE_OFFER_UPDATED = 1,\n  //       MANAGE_OFFER_DELETED = 2\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageOfferEffect\", {\n    manageOfferCreated: 0,\n    manageOfferUpdated: 1,\n    manageOfferDeleted: 2\n  }); // === xdr source ============================================================\n  //\n  //   union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageOfferSuccessResultOffer\", {\n    switchOn: xdr.lookup(\"ManageOfferEffect\"),\n    switchName: \"effect\",\n    switches: [[\"manageOfferCreated\", \"offer\"], [\"manageOfferUpdated\", \"offer\"]],\n    arms: {\n      offer: xdr.lookup(\"OfferEntry\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   struct ManageOfferSuccessResult\n  //   {\n  //       // offers that got claimed while creating this offer\n  //       ClaimOfferAtom offersClaimed<>;\n  //   \n  //       union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //       offer;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ManageOfferSuccessResult\", [[\"offersClaimed\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"offer\", xdr.lookup(\"ManageOfferSuccessResultOffer\")]]); // === xdr source ============================================================\n  //\n  //   union ManageSellOfferResult switch (ManageSellOfferResultCode code)\n  //   {\n  //   case MANAGE_SELL_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageSellOfferResult\", {\n    switchOn: xdr.lookup(\"ManageSellOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageSellOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageBuyOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_BUY_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_BUY_OFFER_MALFORMED = -1,     // generated offer would be invalid\n  //       MANAGE_BUY_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying\n  //       MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_BUY_OFFER_LINE_FULL = -6,   // can't receive more of what it's buying\n  //       MANAGE_BUY_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell\n  //       MANAGE_BUY_OFFER_CROSS_SELF = -8, // would cross an offer from the same user\n  //       MANAGE_BUY_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_BUY_OFFER_NOT_FOUND =\n  //           -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_BUY_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageBuyOfferResultCode\", {\n    manageBuyOfferSuccess: 0,\n    manageBuyOfferMalformed: -1,\n    manageBuyOfferSellNoTrust: -2,\n    manageBuyOfferBuyNoTrust: -3,\n    manageBuyOfferSellNotAuthorized: -4,\n    manageBuyOfferBuyNotAuthorized: -5,\n    manageBuyOfferLineFull: -6,\n    manageBuyOfferUnderfunded: -7,\n    manageBuyOfferCrossSelf: -8,\n    manageBuyOfferSellNoIssuer: -9,\n    manageBuyOfferBuyNoIssuer: -10,\n    manageBuyOfferNotFound: -11,\n    manageBuyOfferLowReserve: -12\n  }); // === xdr source ============================================================\n  //\n  //   union ManageBuyOfferResult switch (ManageBuyOfferResultCode code)\n  //   {\n  //   case MANAGE_BUY_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageBuyOfferResult\", {\n    switchOn: xdr.lookup(\"ManageBuyOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageBuyOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum SetOptionsResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       SET_OPTIONS_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       SET_OPTIONS_LOW_RESERVE = -1,      // not enough funds to add a signer\n  //       SET_OPTIONS_TOO_MANY_SIGNERS = -2, // max number of signers already reached\n  //       SET_OPTIONS_BAD_FLAGS = -3,        // invalid combination of clear/set flags\n  //       SET_OPTIONS_INVALID_INFLATION = -4,      // inflation account does not exist\n  //       SET_OPTIONS_CANT_CHANGE = -5,            // can no longer change this option\n  //       SET_OPTIONS_UNKNOWN_FLAG = -6,           // can't set an unknown flag\n  //       SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = -7, // bad value for weight/threshold\n  //       SET_OPTIONS_BAD_SIGNER = -8,             // signer cannot be masterkey\n  //       SET_OPTIONS_INVALID_HOME_DOMAIN = -9     // malformed home domain\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"SetOptionsResultCode\", {\n    setOptionsSuccess: 0,\n    setOptionsLowReserve: -1,\n    setOptionsTooManySigners: -2,\n    setOptionsBadFlags: -3,\n    setOptionsInvalidInflation: -4,\n    setOptionsCantChange: -5,\n    setOptionsUnknownFlag: -6,\n    setOptionsThresholdOutOfRange: -7,\n    setOptionsBadSigner: -8,\n    setOptionsInvalidHomeDomain: -9\n  }); // === xdr source ============================================================\n  //\n  //   union SetOptionsResult switch (SetOptionsResultCode code)\n  //   {\n  //   case SET_OPTIONS_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"SetOptionsResult\", {\n    switchOn: xdr.lookup(\"SetOptionsResultCode\"),\n    switchName: \"code\",\n    switches: [[\"setOptionsSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ChangeTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CHANGE_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       CHANGE_TRUST_MALFORMED = -1,     // bad input\n  //       CHANGE_TRUST_NO_ISSUER = -2,     // could not find issuer\n  //       CHANGE_TRUST_INVALID_LIMIT = -3, // cannot drop limit below balance\n  //                                        // cannot create with a limit of 0\n  //       CHANGE_TRUST_LOW_RESERVE =\n  //           -4, // not enough funds to create a new trust line,\n  //       CHANGE_TRUST_SELF_NOT_ALLOWED = -5 // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ChangeTrustResultCode\", {\n    changeTrustSuccess: 0,\n    changeTrustMalformed: -1,\n    changeTrustNoIssuer: -2,\n    changeTrustInvalidLimit: -3,\n    changeTrustLowReserve: -4,\n    changeTrustSelfNotAllowed: -5\n  }); // === xdr source ============================================================\n  //\n  //   union ChangeTrustResult switch (ChangeTrustResultCode code)\n  //   {\n  //   case CHANGE_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ChangeTrustResult\", {\n    switchOn: xdr.lookup(\"ChangeTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"changeTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum AllowTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ALLOW_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ALLOW_TRUST_MALFORMED = -1,     // asset is not ASSET_TYPE_ALPHANUM\n  //       ALLOW_TRUST_NO_TRUST_LINE = -2, // trustor does not have a trustline\n  //                                       // source account does not require trust\n  //       ALLOW_TRUST_TRUST_NOT_REQUIRED = -3,\n  //       ALLOW_TRUST_CANT_REVOKE = -4,     // source account can't revoke trust,\n  //       ALLOW_TRUST_SELF_NOT_ALLOWED = -5 // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AllowTrustResultCode\", {\n    allowTrustSuccess: 0,\n    allowTrustMalformed: -1,\n    allowTrustNoTrustLine: -2,\n    allowTrustTrustNotRequired: -3,\n    allowTrustCantRevoke: -4,\n    allowTrustSelfNotAllowed: -5\n  }); // === xdr source ============================================================\n  //\n  //   union AllowTrustResult switch (AllowTrustResultCode code)\n  //   {\n  //   case ALLOW_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"AllowTrustResult\", {\n    switchOn: xdr.lookup(\"AllowTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"allowTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum AccountMergeResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ACCOUNT_MERGE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ACCOUNT_MERGE_MALFORMED = -1,       // can't merge onto itself\n  //       ACCOUNT_MERGE_NO_ACCOUNT = -2,      // destination does not exist\n  //       ACCOUNT_MERGE_IMMUTABLE_SET = -3,   // source account has AUTH_IMMUTABLE set\n  //       ACCOUNT_MERGE_HAS_SUB_ENTRIES = -4, // account has trust lines/offers\n  //       ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed\n  //       ACCOUNT_MERGE_DEST_FULL = -6,       // can't add source balance to\n  //                                           // destination balance\n  //       ACCOUNT_MERGE_IS_SPONSOR = -7       // can't merge account that is a sponsor\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AccountMergeResultCode\", {\n    accountMergeSuccess: 0,\n    accountMergeMalformed: -1,\n    accountMergeNoAccount: -2,\n    accountMergeImmutableSet: -3,\n    accountMergeHasSubEntries: -4,\n    accountMergeSeqnumTooFar: -5,\n    accountMergeDestFull: -6,\n    accountMergeIsSponsor: -7\n  }); // === xdr source ============================================================\n  //\n  //   union AccountMergeResult switch (AccountMergeResultCode code)\n  //   {\n  //   case ACCOUNT_MERGE_SUCCESS:\n  //       int64 sourceAccountBalance; // how much got transfered from source account\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountMergeResult\", {\n    switchOn: xdr.lookup(\"AccountMergeResultCode\"),\n    switchName: \"code\",\n    switches: [[\"accountMergeSuccess\", \"sourceAccountBalance\"]],\n    arms: {\n      sourceAccountBalance: xdr.lookup(\"Int64\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum InflationResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       INFLATION_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       INFLATION_NOT_TIME = -1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"InflationResultCode\", {\n    inflationSuccess: 0,\n    inflationNotTime: -1\n  }); // === xdr source ============================================================\n  //\n  //   struct InflationPayout // or use PaymentResultAtom to limit types?\n  //   {\n  //       AccountID destination;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"InflationPayout\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"amount\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   union InflationResult switch (InflationResultCode code)\n  //   {\n  //   case INFLATION_SUCCESS:\n  //       InflationPayout payouts<>;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"InflationResult\", {\n    switchOn: xdr.lookup(\"InflationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"inflationSuccess\", \"payouts\"]],\n    arms: {\n      payouts: xdr.varArray(xdr.lookup(\"InflationPayout\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ManageDataResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_DATA_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_DATA_NOT_SUPPORTED_YET =\n  //           -1, // The network hasn't moved to this protocol change yet\n  //       MANAGE_DATA_NAME_NOT_FOUND =\n  //           -2, // Trying to remove a Data Entry that isn't there\n  //       MANAGE_DATA_LOW_RESERVE = -3, // not enough funds to create a new Data Entry\n  //       MANAGE_DATA_INVALID_NAME = -4 // Name not a valid string\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ManageDataResultCode\", {\n    manageDataSuccess: 0,\n    manageDataNotSupportedYet: -1,\n    manageDataNameNotFound: -2,\n    manageDataLowReserve: -3,\n    manageDataInvalidName: -4\n  }); // === xdr source ============================================================\n  //\n  //   union ManageDataResult switch (ManageDataResultCode code)\n  //   {\n  //   case MANAGE_DATA_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ManageDataResult\", {\n    switchOn: xdr.lookup(\"ManageDataResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageDataSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum BumpSequenceResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       BUMP_SEQUENCE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       BUMP_SEQUENCE_BAD_SEQ = -1 // `bumpTo` is not within bounds\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"BumpSequenceResultCode\", {\n    bumpSequenceSuccess: 0,\n    bumpSequenceBadSeq: -1\n  }); // === xdr source ============================================================\n  //\n  //   union BumpSequenceResult switch (BumpSequenceResultCode code)\n  //   {\n  //   case BUMP_SEQUENCE_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"BumpSequenceResult\", {\n    switchOn: xdr.lookup(\"BumpSequenceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"bumpSequenceSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum CreateClaimableBalanceResultCode\n  //   {\n  //       CREATE_CLAIMABLE_BALANCE_SUCCESS = 0,\n  //       CREATE_CLAIMABLE_BALANCE_MALFORMED = -1,\n  //       CREATE_CLAIMABLE_BALANCE_LOW_RESERVE = -2,\n  //       CREATE_CLAIMABLE_BALANCE_NO_TRUST = -3,\n  //       CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -4,\n  //       CREATE_CLAIMABLE_BALANCE_UNDERFUNDED = -5\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"CreateClaimableBalanceResultCode\", {\n    createClaimableBalanceSuccess: 0,\n    createClaimableBalanceMalformed: -1,\n    createClaimableBalanceLowReserve: -2,\n    createClaimableBalanceNoTrust: -3,\n    createClaimableBalanceNotAuthorized: -4,\n    createClaimableBalanceUnderfunded: -5\n  }); // === xdr source ============================================================\n  //\n  //   union CreateClaimableBalanceResult switch (CreateClaimableBalanceResultCode code)\n  //   {\n  //   case CREATE_CLAIMABLE_BALANCE_SUCCESS:\n  //       ClaimableBalanceID balanceID;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"CreateClaimableBalanceResult\", {\n    switchOn: xdr.lookup(\"CreateClaimableBalanceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"createClaimableBalanceSuccess\", \"balanceId\"]],\n    arms: {\n      balanceId: xdr.lookup(\"ClaimableBalanceId\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum ClaimClaimableBalanceResultCode\n  //   {\n  //       CLAIM_CLAIMABLE_BALANCE_SUCCESS = 0,\n  //       CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST = -1,\n  //       CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM = -2,\n  //       CLAIM_CLAIMABLE_BALANCE_LINE_FULL = -3,\n  //       CLAIM_CLAIMABLE_BALANCE_NO_TRUST = -4,\n  //       CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -5\n  //   \n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ClaimClaimableBalanceResultCode\", {\n    claimClaimableBalanceSuccess: 0,\n    claimClaimableBalanceDoesNotExist: -1,\n    claimClaimableBalanceCannotClaim: -2,\n    claimClaimableBalanceLineFull: -3,\n    claimClaimableBalanceNoTrust: -4,\n    claimClaimableBalanceNotAuthorized: -5\n  }); // === xdr source ============================================================\n  //\n  //   union ClaimClaimableBalanceResult switch (ClaimClaimableBalanceResultCode code)\n  //   {\n  //   case CLAIM_CLAIMABLE_BALANCE_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ClaimClaimableBalanceResult\", {\n    switchOn: xdr.lookup(\"ClaimClaimableBalanceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"claimClaimableBalanceSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum BeginSponsoringFutureReservesResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED = -1,\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED = -2,\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE = -3\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"BeginSponsoringFutureReservesResultCode\", {\n    beginSponsoringFutureReservesSuccess: 0,\n    beginSponsoringFutureReservesMalformed: -1,\n    beginSponsoringFutureReservesAlreadySponsored: -2,\n    beginSponsoringFutureReservesRecursive: -3\n  }); // === xdr source ============================================================\n  //\n  //   union BeginSponsoringFutureReservesResult switch (BeginSponsoringFutureReservesResultCode code)\n  //   {\n  //   case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"BeginSponsoringFutureReservesResult\", {\n    switchOn: xdr.lookup(\"BeginSponsoringFutureReservesResultCode\"),\n    switchName: \"code\",\n    switches: [[\"beginSponsoringFutureReservesSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum EndSponsoringFutureReservesResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       END_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED = -1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"EndSponsoringFutureReservesResultCode\", {\n    endSponsoringFutureReservesSuccess: 0,\n    endSponsoringFutureReservesNotSponsored: -1\n  }); // === xdr source ============================================================\n  //\n  //   union EndSponsoringFutureReservesResult switch (EndSponsoringFutureReservesResultCode code)\n  //   {\n  //   case END_SPONSORING_FUTURE_RESERVES_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"EndSponsoringFutureReservesResult\", {\n    switchOn: xdr.lookup(\"EndSponsoringFutureReservesResultCode\"),\n    switchName: \"code\",\n    switches: [[\"endSponsoringFutureReservesSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum RevokeSponsorshipResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       REVOKE_SPONSORSHIP_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       REVOKE_SPONSORSHIP_DOES_NOT_EXIST = -1,\n  //       REVOKE_SPONSORSHIP_NOT_SPONSOR = -2,\n  //       REVOKE_SPONSORSHIP_LOW_RESERVE = -3,\n  //       REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE = -4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"RevokeSponsorshipResultCode\", {\n    revokeSponsorshipSuccess: 0,\n    revokeSponsorshipDoesNotExist: -1,\n    revokeSponsorshipNotSponsor: -2,\n    revokeSponsorshipLowReserve: -3,\n    revokeSponsorshipOnlyTransferable: -4\n  }); // === xdr source ============================================================\n  //\n  //   union RevokeSponsorshipResult switch (RevokeSponsorshipResultCode code)\n  //   {\n  //   case REVOKE_SPONSORSHIP_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"RevokeSponsorshipResult\", {\n    switchOn: xdr.lookup(\"RevokeSponsorshipResultCode\"),\n    switchName: \"code\",\n    switches: [[\"revokeSponsorshipSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum OperationResultCode\n  //   {\n  //       opINNER = 0, // inner object result is valid\n  //   \n  //       opBAD_AUTH = -1,            // too few valid signatures / wrong network\n  //       opNO_ACCOUNT = -2,          // source account was not found\n  //       opNOT_SUPPORTED = -3,       // operation not supported at this time\n  //       opTOO_MANY_SUBENTRIES = -4, // max number of subentries already reached\n  //       opEXCEEDED_WORK_LIMIT = -5, // operation did too much work\n  //       opTOO_MANY_SPONSORING = -6  // account is sponsoring too many entries\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"OperationResultCode\", {\n    opInner: 0,\n    opBadAuth: -1,\n    opNoAccount: -2,\n    opNotSupported: -3,\n    opTooManySubentries: -4,\n    opExceededWorkLimit: -5,\n    opTooManySponsoring: -6\n  }); // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferResult manageBuyOfferResult;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendResult pathPaymentStrictSendResult;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceResult createClaimableBalanceResult;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceResult claimClaimableBalanceResult;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipResult revokeSponsorshipResult;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationResultTr\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountResult\"], [\"payment\", \"paymentResult\"], [\"pathPaymentStrictReceive\", \"pathPaymentStrictReceiveResult\"], [\"manageSellOffer\", \"manageSellOfferResult\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferResult\"], [\"setOptions\", \"setOptionsResult\"], [\"changeTrust\", \"changeTrustResult\"], [\"allowTrust\", \"allowTrustResult\"], [\"accountMerge\", \"accountMergeResult\"], [\"inflation\", \"inflationResult\"], [\"manageData\", \"manageDataResult\"], [\"bumpSequence\", \"bumpSeqResult\"], [\"manageBuyOffer\", \"manageBuyOfferResult\"], [\"pathPaymentStrictSend\", \"pathPaymentStrictSendResult\"], [\"createClaimableBalance\", \"createClaimableBalanceResult\"], [\"claimClaimableBalance\", \"claimClaimableBalanceResult\"], [\"beginSponsoringFutureReserves\", \"beginSponsoringFutureReservesResult\"], [\"endSponsoringFutureReserves\", \"endSponsoringFutureReservesResult\"], [\"revokeSponsorship\", \"revokeSponsorshipResult\"]],\n    arms: {\n      createAccountResult: xdr.lookup(\"CreateAccountResult\"),\n      paymentResult: xdr.lookup(\"PaymentResult\"),\n      pathPaymentStrictReceiveResult: xdr.lookup(\"PathPaymentStrictReceiveResult\"),\n      manageSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      createPassiveSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      setOptionsResult: xdr.lookup(\"SetOptionsResult\"),\n      changeTrustResult: xdr.lookup(\"ChangeTrustResult\"),\n      allowTrustResult: xdr.lookup(\"AllowTrustResult\"),\n      accountMergeResult: xdr.lookup(\"AccountMergeResult\"),\n      inflationResult: xdr.lookup(\"InflationResult\"),\n      manageDataResult: xdr.lookup(\"ManageDataResult\"),\n      bumpSeqResult: xdr.lookup(\"BumpSequenceResult\"),\n      manageBuyOfferResult: xdr.lookup(\"ManageBuyOfferResult\"),\n      pathPaymentStrictSendResult: xdr.lookup(\"PathPaymentStrictSendResult\"),\n      createClaimableBalanceResult: xdr.lookup(\"CreateClaimableBalanceResult\"),\n      claimClaimableBalanceResult: xdr.lookup(\"ClaimClaimableBalanceResult\"),\n      beginSponsoringFutureReservesResult: xdr.lookup(\"BeginSponsoringFutureReservesResult\"),\n      endSponsoringFutureReservesResult: xdr.lookup(\"EndSponsoringFutureReservesResult\"),\n      revokeSponsorshipResult: xdr.lookup(\"RevokeSponsorshipResult\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union OperationResult switch (OperationResultCode code)\n  //   {\n  //   case opINNER:\n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferResult manageBuyOfferResult;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendResult pathPaymentStrictSendResult;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceResult createClaimableBalanceResult;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceResult claimClaimableBalanceResult;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipResult revokeSponsorshipResult;\n  //       }\n  //       tr;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"OperationResult\", {\n    switchOn: xdr.lookup(\"OperationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"opInner\", \"tr\"]],\n    arms: {\n      tr: xdr.lookup(\"OperationResultTr\")\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   enum TransactionResultCode\n  //   {\n  //       txFEE_BUMP_INNER_SUCCESS = 1, // fee bump inner transaction succeeded\n  //       txSUCCESS = 0,                // all operations succeeded\n  //   \n  //       txFAILED = -1, // one of the operations failed (none were applied)\n  //   \n  //       txTOO_EARLY = -2,         // ledger closeTime before minTime\n  //       txTOO_LATE = -3,          // ledger closeTime after maxTime\n  //       txMISSING_OPERATION = -4, // no operation was specified\n  //       txBAD_SEQ = -5,           // sequence number does not match source account\n  //   \n  //       txBAD_AUTH = -6,             // too few valid signatures / wrong network\n  //       txINSUFFICIENT_BALANCE = -7, // fee would bring account below reserve\n  //       txNO_ACCOUNT = -8,           // source account not found\n  //       txINSUFFICIENT_FEE = -9,     // fee is too small\n  //       txBAD_AUTH_EXTRA = -10,      // unused signatures attached to transaction\n  //       txINTERNAL_ERROR = -11,      // an unknown error occured\n  //   \n  //       txNOT_SUPPORTED = -12,         // transaction type not supported\n  //       txFEE_BUMP_INNER_FAILED = -13, // fee bump inner transaction failed\n  //       txBAD_SPONSORSHIP = -14        // sponsorship not confirmed\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"TransactionResultCode\", {\n    txFeeBumpInnerSuccess: 1,\n    txSuccess: 0,\n    txFailed: -1,\n    txTooEarly: -2,\n    txTooLate: -3,\n    txMissingOperation: -4,\n    txBadSeq: -5,\n    txBadAuth: -6,\n    txInsufficientBalance: -7,\n    txNoAccount: -8,\n    txInsufficientFee: -9,\n    txBadAuthExtra: -10,\n    txInternalError: -11,\n    txNotSupported: -12,\n    txFeeBumpInnerFailed: -13,\n    txBadSponsorship: -14\n  }); // === xdr source ============================================================\n  //\n  //   union switch (TransactionResultCode code)\n  //       {\n  //       // txFEE_BUMP_INNER_SUCCESS is not included\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       case txTOO_EARLY:\n  //       case txTOO_LATE:\n  //       case txMISSING_OPERATION:\n  //       case txBAD_SEQ:\n  //       case txBAD_AUTH:\n  //       case txINSUFFICIENT_BALANCE:\n  //       case txNO_ACCOUNT:\n  //       case txINSUFFICIENT_FEE:\n  //       case txBAD_AUTH_EXTRA:\n  //       case txINTERNAL_ERROR:\n  //       case txNOT_SUPPORTED:\n  //       // txFEE_BUMP_INNER_FAILED is not included\n  //       case txBAD_SPONSORSHIP:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"InnerTransactionResultResult\", {\n    switchOn: xdr.lookup(\"TransactionResultCode\"),\n    switchName: \"code\",\n    switches: [[\"txSuccess\", \"results\"], [\"txFailed\", \"results\"], [\"txTooEarly\", xdr.void()], [\"txTooLate\", xdr.void()], [\"txMissingOperation\", xdr.void()], [\"txBadSeq\", xdr.void()], [\"txBadAuth\", xdr.void()], [\"txInsufficientBalance\", xdr.void()], [\"txNoAccount\", xdr.void()], [\"txInsufficientFee\", xdr.void()], [\"txBadAuthExtra\", xdr.void()], [\"txInternalError\", xdr.void()], [\"txNotSupported\", xdr.void()], [\"txBadSponsorship\", xdr.void()]],\n    arms: {\n      results: xdr.varArray(xdr.lookup(\"OperationResult\"), 2147483647)\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"InnerTransactionResultExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct InnerTransactionResult\n  //   {\n  //       // Always 0. Here for binary compatibility.\n  //       int64 feeCharged;\n  //   \n  //       union switch (TransactionResultCode code)\n  //       {\n  //       // txFEE_BUMP_INNER_SUCCESS is not included\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       case txTOO_EARLY:\n  //       case txTOO_LATE:\n  //       case txMISSING_OPERATION:\n  //       case txBAD_SEQ:\n  //       case txBAD_AUTH:\n  //       case txINSUFFICIENT_BALANCE:\n  //       case txNO_ACCOUNT:\n  //       case txINSUFFICIENT_FEE:\n  //       case txBAD_AUTH_EXTRA:\n  //       case txINTERNAL_ERROR:\n  //       case txNOT_SUPPORTED:\n  //       // txFEE_BUMP_INNER_FAILED is not included\n  //       case txBAD_SPONSORSHIP:\n  //           void;\n  //       }\n  //       result;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"InnerTransactionResult\", [[\"feeCharged\", xdr.lookup(\"Int64\")], [\"result\", xdr.lookup(\"InnerTransactionResultResult\")], [\"ext\", xdr.lookup(\"InnerTransactionResultExt\")]]); // === xdr source ============================================================\n  //\n  //   struct InnerTransactionResultPair\n  //   {\n  //       Hash transactionHash;          // hash of the inner transaction\n  //       InnerTransactionResult result; // result for the inner transaction\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"InnerTransactionResultPair\", [[\"transactionHash\", xdr.lookup(\"Hash\")], [\"result\", xdr.lookup(\"InnerTransactionResult\")]]); // === xdr source ============================================================\n  //\n  //   union switch (TransactionResultCode code)\n  //       {\n  //       case txFEE_BUMP_INNER_SUCCESS:\n  //       case txFEE_BUMP_INNER_FAILED:\n  //           InnerTransactionResultPair innerResultPair;\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionResultResult\", {\n    switchOn: xdr.lookup(\"TransactionResultCode\"),\n    switchName: \"code\",\n    switches: [[\"txFeeBumpInnerSuccess\", \"innerResultPair\"], [\"txFeeBumpInnerFailed\", \"innerResultPair\"], [\"txSuccess\", \"results\"], [\"txFailed\", \"results\"]],\n    arms: {\n      innerResultPair: xdr.lookup(\"InnerTransactionResultPair\"),\n      results: xdr.varArray(xdr.lookup(\"OperationResult\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionResultExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionResult\n  //   {\n  //       int64 feeCharged; // actual fee charged for the transaction\n  //   \n  //       union switch (TransactionResultCode code)\n  //       {\n  //       case txFEE_BUMP_INNER_SUCCESS:\n  //       case txFEE_BUMP_INNER_FAILED:\n  //           InnerTransactionResultPair innerResultPair;\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //       result;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResult\", [[\"feeCharged\", xdr.lookup(\"Int64\")], [\"result\", xdr.lookup(\"TransactionResultResult\")], [\"ext\", xdr.lookup(\"TransactionResultExt\")]]); // === xdr source ============================================================\n  //\n  //   typedef opaque Value<>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Value\", xdr.varOpaque()); // === xdr source ============================================================\n  //\n  //   struct SCPBallot\n  //   {\n  //       uint32 counter; // n\n  //       Value value;    // x\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpBallot\", [[\"counter\", xdr.lookup(\"Uint32\")], [\"value\", xdr.lookup(\"Value\")]]); // === xdr source ============================================================\n  //\n  //   enum SCPStatementType\n  //   {\n  //       SCP_ST_PREPARE = 0,\n  //       SCP_ST_CONFIRM = 1,\n  //       SCP_ST_EXTERNALIZE = 2,\n  //       SCP_ST_NOMINATE = 3\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ScpStatementType\", {\n    scpStPrepare: 0,\n    scpStConfirm: 1,\n    scpStExternalize: 2,\n    scpStNominate: 3\n  }); // === xdr source ============================================================\n  //\n  //   struct SCPNomination\n  //   {\n  //       Hash quorumSetHash; // D\n  //       Value votes<>;      // X\n  //       Value accepted<>;   // Y\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpNomination\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"votes\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)], [\"accepted\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatementPrepare\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"ballot\", xdr.lookup(\"ScpBallot\")], [\"prepared\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"preparedPrime\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"nC\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatementConfirm\", [[\"ballot\", xdr.lookup(\"ScpBallot\")], [\"nPrepared\", xdr.lookup(\"Uint32\")], [\"nCommit\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"quorumSetHash\", xdr.lookup(\"Hash\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatementExternalize\", [[\"commit\", xdr.lookup(\"ScpBallot\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"commitQuorumSetHash\", xdr.lookup(\"Hash\")]]); // === xdr source ============================================================\n  //\n  //   union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"ScpStatementPledges\", {\n    switchOn: xdr.lookup(\"ScpStatementType\"),\n    switchName: \"type\",\n    switches: [[\"scpStPrepare\", \"prepare\"], [\"scpStConfirm\", \"confirm\"], [\"scpStExternalize\", \"externalize\"], [\"scpStNominate\", \"nominate\"]],\n    arms: {\n      prepare: xdr.lookup(\"ScpStatementPrepare\"),\n      confirm: xdr.lookup(\"ScpStatementConfirm\"),\n      externalize: xdr.lookup(\"ScpStatementExternalize\"),\n      nominate: xdr.lookup(\"ScpNomination\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct SCPStatement\n  //   {\n  //       NodeID nodeID;    // v\n  //       uint64 slotIndex; // i\n  //   \n  //       union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //       pledges;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpStatement\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"slotIndex\", xdr.lookup(\"Uint64\")], [\"pledges\", xdr.lookup(\"ScpStatementPledges\")]]); // === xdr source ============================================================\n  //\n  //   struct SCPEnvelope\n  //   {\n  //       SCPStatement statement;\n  //       Signature signature;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpEnvelope\", [[\"statement\", xdr.lookup(\"ScpStatement\")], [\"signature\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   struct SCPQuorumSet\n  //   {\n  //       uint32 threshold;\n  //       PublicKey validators<>;\n  //       SCPQuorumSet innerSets<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpQuorumSet\", [[\"threshold\", xdr.lookup(\"Uint32\")], [\"validators\", xdr.varArray(xdr.lookup(\"PublicKey\"), 2147483647)], [\"innerSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   typedef PublicKey AccountID;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"AccountId\", xdr.lookup(\"PublicKey\")); // === xdr source ============================================================\n  //\n  //   typedef opaque Thresholds[4];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"Thresholds\", xdr.opaque(4)); // === xdr source ============================================================\n  //\n  //   typedef string string32<32>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"String32\", xdr.string(32)); // === xdr source ============================================================\n  //\n  //   typedef string string64<64>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"String64\", xdr.string(64)); // === xdr source ============================================================\n  //\n  //   typedef int64 SequenceNumber;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"SequenceNumber\", xdr.lookup(\"Int64\")); // === xdr source ============================================================\n  //\n  //   typedef uint64 TimePoint;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"TimePoint\", xdr.lookup(\"Uint64\")); // === xdr source ============================================================\n  //\n  //   typedef opaque DataValue<64>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"DataValue\", xdr.varOpaque(64)); // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode4[4];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"AssetCode4\", xdr.opaque(4)); // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode12[12];\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"AssetCode12\", xdr.opaque(12)); // === xdr source ============================================================\n  //\n  //   enum AssetType\n  //   {\n  //       ASSET_TYPE_NATIVE = 0,\n  //       ASSET_TYPE_CREDIT_ALPHANUM4 = 1,\n  //       ASSET_TYPE_CREDIT_ALPHANUM12 = 2\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AssetType\", {\n    assetTypeNative: 0,\n    assetTypeCreditAlphanum4: 1,\n    assetTypeCreditAlphanum12: 2\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AssetAlphaNum4\", [[\"assetCode\", xdr.lookup(\"AssetCode4\")], [\"issuer\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AssetAlphaNum12\", [[\"assetCode\", xdr.lookup(\"AssetCode12\")], [\"issuer\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   union Asset switch (AssetType type)\n  //   {\n  //   case ASSET_TYPE_NATIVE: // Not credit\n  //       void;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //       struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum4;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //       struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum12;\n  //   \n  //       // add other asset types here in the future\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"Asset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeNative\", xdr.void()], [\"assetTypeCreditAlphanum4\", \"alphaNum4\"], [\"assetTypeCreditAlphanum12\", \"alphaNum12\"]],\n    arms: {\n      alphaNum4: xdr.lookup(\"AssetAlphaNum4\"),\n      alphaNum12: xdr.lookup(\"AssetAlphaNum12\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct Price\n  //   {\n  //       int32 n; // numerator\n  //       int32 d; // denominator\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Price\", [[\"n\", xdr.lookup(\"Int32\")], [\"d\", xdr.lookup(\"Int32\")]]); // === xdr source ============================================================\n  //\n  //   struct Liabilities\n  //   {\n  //       int64 buying;\n  //       int64 selling;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Liabilities\", [[\"buying\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   enum ThresholdIndexes\n  //   {\n  //       THRESHOLD_MASTER_WEIGHT = 0,\n  //       THRESHOLD_LOW = 1,\n  //       THRESHOLD_MED = 2,\n  //       THRESHOLD_HIGH = 3\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ThresholdIndices\", {\n    thresholdMasterWeight: 0,\n    thresholdLow: 1,\n    thresholdMed: 2,\n    thresholdHigh: 3\n  }); // === xdr source ============================================================\n  //\n  //   enum LedgerEntryType\n  //   {\n  //       ACCOUNT = 0,\n  //       TRUSTLINE = 1,\n  //       OFFER = 2,\n  //       DATA = 3,\n  //       CLAIMABLE_BALANCE = 4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"LedgerEntryType\", {\n    account: 0,\n    trustline: 1,\n    offer: 2,\n    data: 3,\n    claimableBalance: 4\n  }); // === xdr source ============================================================\n  //\n  //   struct Signer\n  //   {\n  //       SignerKey key;\n  //       uint32 weight; // really only need 1 byte\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"Signer\", [[\"key\", xdr.lookup(\"SignerKey\")], [\"weight\", xdr.lookup(\"Uint32\")]]); // === xdr source ============================================================\n  //\n  //   enum AccountFlags\n  //   { // masks for each flag\n  //   \n  //       // Flags set on issuer accounts\n  //       // TrustLines are created with authorized set to \"false\" requiring\n  //       // the issuer to set it for each TrustLine\n  //       AUTH_REQUIRED_FLAG = 0x1,\n  //       // If set, the authorized flag in TrustLines can be cleared\n  //       // otherwise, authorization cannot be revoked\n  //       AUTH_REVOCABLE_FLAG = 0x2,\n  //       // Once set, causes all AUTH_* flags to be read-only\n  //       AUTH_IMMUTABLE_FLAG = 0x4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"AccountFlags\", {\n    authRequiredFlag: 1,\n    authRevocableFlag: 2,\n    authImmutableFlag: 4\n  }); // === xdr source ============================================================\n  //\n  //   const MASK_ACCOUNT_FLAGS = 0x7;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_ACCOUNT_FLAGS\", 0x7); // === xdr source ============================================================\n  //\n  //   const MAX_SIGNERS = 20;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MAX_SIGNERS\", 20); // === xdr source ============================================================\n  //\n  //   typedef AccountID* SponsorshipDescriptor;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"SponsorshipDescriptor\", xdr.option(xdr.lookup(\"AccountId\"))); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountEntryExtensionV2Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct AccountEntryExtensionV2\n  //   {\n  //       uint32 numSponsored;\n  //       uint32 numSponsoring;\n  //       SponsorshipDescriptor signerSponsoringIDs<MAX_SIGNERS>;\n  //   \n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AccountEntryExtensionV2\", [[\"numSponsored\", xdr.lookup(\"Uint32\")], [\"numSponsoring\", xdr.lookup(\"Uint32\")], [\"signerSponsoringIDs\", xdr.varArray(xdr.lookup(\"SponsorshipDescriptor\"), xdr.lookup(\"MAX_SIGNERS\"))], [\"ext\", xdr.lookup(\"AccountEntryExtensionV2Ext\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 2:\n  //           AccountEntryExtensionV2 v2;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountEntryExtensionV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [2, \"v2\"]],\n    arms: {\n      v2: xdr.lookup(\"AccountEntryExtensionV2\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct AccountEntryExtensionV1\n  //   {\n  //       Liabilities liabilities;\n  //   \n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 2:\n  //           AccountEntryExtensionV2 v2;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AccountEntryExtensionV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"AccountEntryExtensionV1Ext\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           AccountEntryExtensionV1 v1;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"AccountEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"AccountEntryExtensionV1\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct AccountEntry\n  //   {\n  //       AccountID accountID;      // master public key for this account\n  //       int64 balance;            // in stroops\n  //       SequenceNumber seqNum;    // last sequence number used for this account\n  //       uint32 numSubEntries;     // number of sub-entries this account has\n  //                                 // drives the reserve\n  //       AccountID* inflationDest; // Account to vote for during inflation\n  //       uint32 flags;             // see AccountFlags\n  //   \n  //       string32 homeDomain; // can be used for reverse federation and memo lookup\n  //   \n  //       // fields used for signatures\n  //       // thresholds stores unsigned bytes: [weight of master|low|medium|high]\n  //       Thresholds thresholds;\n  //   \n  //       Signer signers<MAX_SIGNERS>; // possible signers for this account\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           AccountEntryExtensionV1 v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"AccountEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"balance\", xdr.lookup(\"Int64\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"numSubEntries\", xdr.lookup(\"Uint32\")], [\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"flags\", xdr.lookup(\"Uint32\")], [\"homeDomain\", xdr.lookup(\"String32\")], [\"thresholds\", xdr.lookup(\"Thresholds\")], [\"signers\", xdr.varArray(xdr.lookup(\"Signer\"), xdr.lookup(\"MAX_SIGNERS\"))], [\"ext\", xdr.lookup(\"AccountEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   enum TrustLineFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       AUTHORIZED_FLAG = 1,\n  //       // issuer has authorized account to maintain and reduce liabilities for its\n  //       // credit\n  //       AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG = 2\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"TrustLineFlags\", {\n    authorizedFlag: 1,\n    authorizedToMaintainLiabilitiesFlag: 2\n  }); // === xdr source ============================================================\n  //\n  //   const MASK_TRUSTLINE_FLAGS = 1;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_TRUSTLINE_FLAGS\", 1); // === xdr source ============================================================\n  //\n  //   const MASK_TRUSTLINE_FLAGS_V13 = 3;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_TRUSTLINE_FLAGS_V13\", 3); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TrustLineEntryV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TrustLineEntryV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"TrustLineEntryV1Ext\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TrustLineEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"TrustLineEntryV1\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TrustLineEntry\n  //   {\n  //       AccountID accountID; // account this trustline belongs to\n  //       Asset asset;         // type of asset (with issuer)\n  //       int64 balance;       // how much of this asset the user has.\n  //                            // Asset defines the unit for this;\n  //   \n  //       int64 limit;  // balance cannot be above this\n  //       uint32 flags; // see TrustLineFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TrustLineEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"balance\", xdr.lookup(\"Int64\")], [\"limit\", xdr.lookup(\"Int64\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"TrustLineEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   enum OfferEntryFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       PASSIVE_FLAG = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"OfferEntryFlags\", {\n    passiveFlag: 1\n  }); // === xdr source ============================================================\n  //\n  //   const MASK_OFFERENTRY_FLAGS = 1;\n  //\n  // ===========================================================================\n\n  xdr.const(\"MASK_OFFERENTRY_FLAGS\", 1); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"OfferEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct OfferEntry\n  //   {\n  //       AccountID sellerID;\n  //       int64 offerID;\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount of A\n  //   \n  //       /* price for this offer:\n  //           price of A in terms of B\n  //           price=AmountB/AmountA=priceNumerator/priceDenominator\n  //           price is after fees\n  //       */\n  //       Price price;\n  //       uint32 flags; // see OfferEntryFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"OfferEntry\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"OfferEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"DataEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct DataEntry\n  //   {\n  //       AccountID accountID; // account this data belongs to\n  //       string64 dataName;\n  //       DataValue dataValue;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"DataEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.lookup(\"DataValue\")], [\"ext\", xdr.lookup(\"DataEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   enum ClaimPredicateType\n  //   {\n  //       CLAIM_PREDICATE_UNCONDITIONAL = 0,\n  //       CLAIM_PREDICATE_AND = 1,\n  //       CLAIM_PREDICATE_OR = 2,\n  //       CLAIM_PREDICATE_NOT = 3,\n  //       CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME = 4,\n  //       CLAIM_PREDICATE_BEFORE_RELATIVE_TIME = 5\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ClaimPredicateType\", {\n    claimPredicateUnconditional: 0,\n    claimPredicateAnd: 1,\n    claimPredicateOr: 2,\n    claimPredicateNot: 3,\n    claimPredicateBeforeAbsoluteTime: 4,\n    claimPredicateBeforeRelativeTime: 5\n  }); // === xdr source ============================================================\n  //\n  //   union ClaimPredicate switch (ClaimPredicateType type)\n  //   {\n  //   case CLAIM_PREDICATE_UNCONDITIONAL:\n  //       void;\n  //   case CLAIM_PREDICATE_AND:\n  //       ClaimPredicate andPredicates<2>;\n  //   case CLAIM_PREDICATE_OR:\n  //       ClaimPredicate orPredicates<2>;\n  //   case CLAIM_PREDICATE_NOT:\n  //       ClaimPredicate* notPredicate;\n  //   case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:\n  //       int64 absBefore; // Predicate will be true if closeTime < absBefore\n  //   case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:\n  //       int64 relBefore; // Seconds since closeTime of the ledger in which the\n  //                        // ClaimableBalanceEntry was created\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ClaimPredicate\", {\n    switchOn: xdr.lookup(\"ClaimPredicateType\"),\n    switchName: \"type\",\n    switches: [[\"claimPredicateUnconditional\", xdr.void()], [\"claimPredicateAnd\", \"andPredicates\"], [\"claimPredicateOr\", \"orPredicates\"], [\"claimPredicateNot\", \"notPredicate\"], [\"claimPredicateBeforeAbsoluteTime\", \"absBefore\"], [\"claimPredicateBeforeRelativeTime\", \"relBefore\"]],\n    arms: {\n      andPredicates: xdr.varArray(xdr.lookup(\"ClaimPredicate\"), 2),\n      orPredicates: xdr.varArray(xdr.lookup(\"ClaimPredicate\"), 2),\n      notPredicate: xdr.option(xdr.lookup(\"ClaimPredicate\")),\n      absBefore: xdr.lookup(\"Int64\"),\n      relBefore: xdr.lookup(\"Int64\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum ClaimantType\n  //   {\n  //       CLAIMANT_TYPE_V0 = 0\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ClaimantType\", {\n    claimantTypeV0: 0\n  }); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID destination;    // The account that can use this condition\n  //           ClaimPredicate predicate; // Claimable if predicate is true\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ClaimantV0\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"predicate\", xdr.lookup(\"ClaimPredicate\")]]); // === xdr source ============================================================\n  //\n  //   union Claimant switch (ClaimantType type)\n  //   {\n  //   case CLAIMANT_TYPE_V0:\n  //       struct\n  //       {\n  //           AccountID destination;    // The account that can use this condition\n  //           ClaimPredicate predicate; // Claimable if predicate is true\n  //       } v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"Claimant\", {\n    switchOn: xdr.lookup(\"ClaimantType\"),\n    switchName: \"type\",\n    switches: [[\"claimantTypeV0\", \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"ClaimantV0\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum ClaimableBalanceIDType\n  //   {\n  //       CLAIMABLE_BALANCE_ID_TYPE_V0 = 0\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"ClaimableBalanceIdType\", {\n    claimableBalanceIdTypeV0: 0\n  }); // === xdr source ============================================================\n  //\n  //   union ClaimableBalanceID switch (ClaimableBalanceIDType type)\n  //   {\n  //   case CLAIMABLE_BALANCE_ID_TYPE_V0:\n  //       Hash v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ClaimableBalanceId\", {\n    switchOn: xdr.lookup(\"ClaimableBalanceIdType\"),\n    switchName: \"type\",\n    switches: [[\"claimableBalanceIdTypeV0\", \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"Hash\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"ClaimableBalanceEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct ClaimableBalanceEntry\n  //   {\n  //       // Unique identifier for this ClaimableBalanceEntry\n  //       ClaimableBalanceID balanceID;\n  //   \n  //       // List of claimants with associated predicate\n  //       Claimant claimants<10>;\n  //   \n  //       // Any asset including native\n  //       Asset asset;\n  //   \n  //       // Amount of asset\n  //       int64 amount;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ClaimableBalanceEntry\", [[\"balanceId\", xdr.lookup(\"ClaimableBalanceId\")], [\"claimants\", xdr.varArray(xdr.lookup(\"Claimant\"), 10)], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"ext\", xdr.lookup(\"ClaimableBalanceEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryExtensionV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerEntryExtensionV1\n  //   {\n  //       SponsorshipDescriptor sponsoringID;\n  //   \n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerEntryExtensionV1\", [[\"sponsoringId\", xdr.lookup(\"SponsorshipDescriptor\")], [\"ext\", xdr.lookup(\"LedgerEntryExtensionV1Ext\")]]); // === xdr source ============================================================\n  //\n  //   union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       case CLAIMABLE_BALANCE:\n  //           ClaimableBalanceEntry claimableBalance;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryData\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"data\", \"data\"], [\"claimableBalance\", \"claimableBalance\"]],\n    arms: {\n      account: xdr.lookup(\"AccountEntry\"),\n      trustLine: xdr.lookup(\"TrustLineEntry\"),\n      offer: xdr.lookup(\"OfferEntry\"),\n      data: xdr.lookup(\"DataEntry\"),\n      claimableBalance: xdr.lookup(\"ClaimableBalanceEntry\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           LedgerEntryExtensionV1 v1;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"LedgerEntryExtensionV1\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerEntry\n  //   {\n  //       uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed\n  //   \n  //       union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       case CLAIMABLE_BALANCE:\n  //           ClaimableBalanceEntry claimableBalance;\n  //       }\n  //       data;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           LedgerEntryExtensionV1 v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerEntry\", [[\"lastModifiedLedgerSeq\", xdr.lookup(\"Uint32\")], [\"data\", xdr.lookup(\"LedgerEntryData\")], [\"ext\", xdr.lookup(\"LedgerEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyAccount\", [[\"accountId\", xdr.lookup(\"AccountId\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyTrustLine\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyOffer\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyData\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")]]); // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimableBalanceID balanceID;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerKeyClaimableBalance\", [[\"balanceId\", xdr.lookup(\"ClaimableBalanceId\")]]); // === xdr source ============================================================\n  //\n  //   union LedgerKey switch (LedgerEntryType type)\n  //   {\n  //   case ACCOUNT:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //       } account;\n  //   \n  //   case TRUSTLINE:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       } trustLine;\n  //   \n  //   case OFFER:\n  //       struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       } offer;\n  //   \n  //   case DATA:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       } data;\n  //   \n  //   case CLAIMABLE_BALANCE:\n  //       struct\n  //       {\n  //           ClaimableBalanceID balanceID;\n  //       } claimableBalance;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerKey\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"data\", \"data\"], [\"claimableBalance\", \"claimableBalance\"]],\n    arms: {\n      account: xdr.lookup(\"LedgerKeyAccount\"),\n      trustLine: xdr.lookup(\"LedgerKeyTrustLine\"),\n      offer: xdr.lookup(\"LedgerKeyOffer\"),\n      data: xdr.lookup(\"LedgerKeyData\"),\n      claimableBalance: xdr.lookup(\"LedgerKeyClaimableBalance\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum EnvelopeType\n  //   {\n  //       ENVELOPE_TYPE_TX_V0 = 0,\n  //       ENVELOPE_TYPE_SCP = 1,\n  //       ENVELOPE_TYPE_TX = 2,\n  //       ENVELOPE_TYPE_AUTH = 3,\n  //       ENVELOPE_TYPE_SCPVALUE = 4,\n  //       ENVELOPE_TYPE_TX_FEE_BUMP = 5,\n  //       ENVELOPE_TYPE_OP_ID = 6\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"EnvelopeType\", {\n    envelopeTypeTxV0: 0,\n    envelopeTypeScp: 1,\n    envelopeTypeTx: 2,\n    envelopeTypeAuth: 3,\n    envelopeTypeScpvalue: 4,\n    envelopeTypeTxFeeBump: 5,\n    envelopeTypeOpId: 6\n  }); // === xdr source ============================================================\n  //\n  //   typedef opaque UpgradeType<128>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"UpgradeType\", xdr.varOpaque(128)); // === xdr source ============================================================\n  //\n  //   enum StellarValueType\n  //   {\n  //       STELLAR_VALUE_BASIC = 0,\n  //       STELLAR_VALUE_SIGNED = 1\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"StellarValueType\", {\n    stellarValueBasic: 0,\n    stellarValueSigned: 1\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerCloseValueSignature\n  //   {\n  //       NodeID nodeID;       // which node introduced the value\n  //       Signature signature; // nodeID's signature\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerCloseValueSignature\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"signature\", xdr.lookup(\"Signature\")]]); // === xdr source ============================================================\n  //\n  //   union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"StellarValueExt\", {\n    switchOn: xdr.lookup(\"StellarValueType\"),\n    switchName: \"v\",\n    switches: [[\"stellarValueBasic\", xdr.void()], [\"stellarValueSigned\", \"lcValueSignature\"]],\n    arms: {\n      lcValueSignature: xdr.lookup(\"LedgerCloseValueSignature\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct StellarValue\n  //   {\n  //       Hash txSetHash;      // transaction set to apply to previous ledger\n  //       TimePoint closeTime; // network close time\n  //   \n  //       // upgrades to apply to the previous ledger (usually empty)\n  //       // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop\n  //       // unknown steps during consensus if needed.\n  //       // see notes below on 'LedgerUpgrade' for more detail\n  //       // max size is dictated by number of upgrade types (+ room for future)\n  //       UpgradeType upgrades<6>;\n  //   \n  //       // reserved for future use\n  //       union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"StellarValue\", [[\"txSetHash\", xdr.lookup(\"Hash\")], [\"closeTime\", xdr.lookup(\"TimePoint\")], [\"upgrades\", xdr.varArray(xdr.lookup(\"UpgradeType\"), 6)], [\"ext\", xdr.lookup(\"StellarValueExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerHeaderExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerHeader\n  //   {\n  //       uint32 ledgerVersion;    // the protocol version of the ledger\n  //       Hash previousLedgerHash; // hash of the previous ledger header\n  //       StellarValue scpValue;   // what consensus agreed to\n  //       Hash txSetResultHash;    // the TransactionResultSet that led to this ledger\n  //       Hash bucketListHash;     // hash of the ledger state\n  //   \n  //       uint32 ledgerSeq; // sequence number of this ledger\n  //   \n  //       int64 totalCoins; // total number of stroops in existence.\n  //                         // 10,000,000 stroops in 1 XLM\n  //   \n  //       int64 feePool;       // fees burned since last inflation run\n  //       uint32 inflationSeq; // inflation sequence number\n  //   \n  //       uint64 idPool; // last used global ID, used for generating objects\n  //   \n  //       uint32 baseFee;     // base fee per operation in stroops\n  //       uint32 baseReserve; // account base reserve in stroops\n  //   \n  //       uint32 maxTxSetSize; // maximum size a transaction set can be\n  //   \n  //       Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back\n  //                         // in time without walking the chain back ledger by ledger\n  //                         // each slot contains the oldest ledger that is mod of\n  //                         // either 50  5000  50000 or 500000 depending on index\n  //                         // skipList[0] mod(50), skipList[1] mod(5000), etc\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerHeader\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"scpValue\", xdr.lookup(\"StellarValue\")], [\"txSetResultHash\", xdr.lookup(\"Hash\")], [\"bucketListHash\", xdr.lookup(\"Hash\")], [\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"totalCoins\", xdr.lookup(\"Int64\")], [\"feePool\", xdr.lookup(\"Int64\")], [\"inflationSeq\", xdr.lookup(\"Uint32\")], [\"idPool\", xdr.lookup(\"Uint64\")], [\"baseFee\", xdr.lookup(\"Uint32\")], [\"baseReserve\", xdr.lookup(\"Uint32\")], [\"maxTxSetSize\", xdr.lookup(\"Uint32\")], [\"skipList\", xdr.array(xdr.lookup(\"Hash\"), 4)], [\"ext\", xdr.lookup(\"LedgerHeaderExt\")]]); // === xdr source ============================================================\n  //\n  //   enum LedgerUpgradeType\n  //   {\n  //       LEDGER_UPGRADE_VERSION = 1,\n  //       LEDGER_UPGRADE_BASE_FEE = 2,\n  //       LEDGER_UPGRADE_MAX_TX_SET_SIZE = 3,\n  //       LEDGER_UPGRADE_BASE_RESERVE = 4\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"LedgerUpgradeType\", {\n    ledgerUpgradeVersion: 1,\n    ledgerUpgradeBaseFee: 2,\n    ledgerUpgradeMaxTxSetSize: 3,\n    ledgerUpgradeBaseReserve: 4\n  }); // === xdr source ============================================================\n  //\n  //   union LedgerUpgrade switch (LedgerUpgradeType type)\n  //   {\n  //   case LEDGER_UPGRADE_VERSION:\n  //       uint32 newLedgerVersion; // update ledgerVersion\n  //   case LEDGER_UPGRADE_BASE_FEE:\n  //       uint32 newBaseFee; // update baseFee\n  //   case LEDGER_UPGRADE_MAX_TX_SET_SIZE:\n  //       uint32 newMaxTxSetSize; // update maxTxSetSize\n  //   case LEDGER_UPGRADE_BASE_RESERVE:\n  //       uint32 newBaseReserve; // update baseReserve\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerUpgrade\", {\n    switchOn: xdr.lookup(\"LedgerUpgradeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerUpgradeVersion\", \"newLedgerVersion\"], [\"ledgerUpgradeBaseFee\", \"newBaseFee\"], [\"ledgerUpgradeMaxTxSetSize\", \"newMaxTxSetSize\"], [\"ledgerUpgradeBaseReserve\", \"newBaseReserve\"]],\n    arms: {\n      newLedgerVersion: xdr.lookup(\"Uint32\"),\n      newBaseFee: xdr.lookup(\"Uint32\"),\n      newMaxTxSetSize: xdr.lookup(\"Uint32\"),\n      newBaseReserve: xdr.lookup(\"Uint32\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum BucketEntryType\n  //   {\n  //       METAENTRY =\n  //           -1, // At-and-after protocol 11: bucket metadata, should come first.\n  //       LIVEENTRY = 0, // Before protocol 11: created-or-updated;\n  //                      // At-and-after protocol 11: only updated.\n  //       DEADENTRY = 1,\n  //       INITENTRY = 2 // At-and-after protocol 11: only created.\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"BucketEntryType\", {\n    metaentry: -1,\n    liveentry: 0,\n    deadentry: 1,\n    initentry: 2\n  }); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"BucketMetadataExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct BucketMetadata\n  //   {\n  //       // Indicates the protocol version used to create / merge this bucket.\n  //       uint32 ledgerVersion;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"BucketMetadata\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"BucketMetadataExt\")]]); // === xdr source ============================================================\n  //\n  //   union BucketEntry switch (BucketEntryType type)\n  //   {\n  //   case LIVEENTRY:\n  //   case INITENTRY:\n  //       LedgerEntry liveEntry;\n  //   \n  //   case DEADENTRY:\n  //       LedgerKey deadEntry;\n  //   case METAENTRY:\n  //       BucketMetadata metaEntry;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"BucketEntry\", {\n    switchOn: xdr.lookup(\"BucketEntryType\"),\n    switchName: \"type\",\n    switches: [[\"liveentry\", \"liveEntry\"], [\"initentry\", \"liveEntry\"], [\"deadentry\", \"deadEntry\"], [\"metaentry\", \"metaEntry\"]],\n    arms: {\n      liveEntry: xdr.lookup(\"LedgerEntry\"),\n      deadEntry: xdr.lookup(\"LedgerKey\"),\n      metaEntry: xdr.lookup(\"BucketMetadata\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionSet\n  //   {\n  //       Hash previousLedgerHash;\n  //       TransactionEnvelope txs<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionSet\", [[\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"txes\", xdr.varArray(xdr.lookup(\"TransactionEnvelope\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct TransactionResultPair\n  //   {\n  //       Hash transactionHash;\n  //       TransactionResult result; // result for the transaction\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResultPair\", [[\"transactionHash\", xdr.lookup(\"Hash\")], [\"result\", xdr.lookup(\"TransactionResult\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionResultSet\n  //   {\n  //       TransactionResultPair results<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResultSet\", [[\"results\", xdr.varArray(xdr.lookup(\"TransactionResultPair\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionSet txSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionHistoryEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txSet\", xdr.lookup(\"TransactionSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionHistoryResultEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryResultEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionResultSet txResultSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionHistoryResultEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txResultSet\", xdr.lookup(\"TransactionResultSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryResultEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerHeaderHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  }); // === xdr source ============================================================\n  //\n  //   struct LedgerHeaderHistoryEntry\n  //   {\n  //       Hash hash;\n  //       LedgerHeader header;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerHeaderHistoryEntry\", [[\"hash\", xdr.lookup(\"Hash\")], [\"header\", xdr.lookup(\"LedgerHeader\")], [\"ext\", xdr.lookup(\"LedgerHeaderHistoryEntryExt\")]]); // === xdr source ============================================================\n  //\n  //   struct LedgerSCPMessages\n  //   {\n  //       uint32 ledgerSeq;\n  //       SCPEnvelope messages<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerScpMessages\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"messages\", xdr.varArray(xdr.lookup(\"ScpEnvelope\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct SCPHistoryEntryV0\n  //   {\n  //       SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages\n  //       LedgerSCPMessages ledgerMessages;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"ScpHistoryEntryV0\", [[\"quorumSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)], [\"ledgerMessages\", xdr.lookup(\"LedgerScpMessages\")]]); // === xdr source ============================================================\n  //\n  //   union SCPHistoryEntry switch (int v)\n  //   {\n  //   case 0:\n  //       SCPHistoryEntryV0 v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"ScpHistoryEntry\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"ScpHistoryEntryV0\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   enum LedgerEntryChangeType\n  //   {\n  //       LEDGER_ENTRY_CREATED = 0, // entry was added to the ledger\n  //       LEDGER_ENTRY_UPDATED = 1, // entry was modified in the ledger\n  //       LEDGER_ENTRY_REMOVED = 2, // entry was removed from the ledger\n  //       LEDGER_ENTRY_STATE = 3    // value of the entry\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.enum(\"LedgerEntryChangeType\", {\n    ledgerEntryCreated: 0,\n    ledgerEntryUpdated: 1,\n    ledgerEntryRemoved: 2,\n    ledgerEntryState: 3\n  }); // === xdr source ============================================================\n  //\n  //   union LedgerEntryChange switch (LedgerEntryChangeType type)\n  //   {\n  //   case LEDGER_ENTRY_CREATED:\n  //       LedgerEntry created;\n  //   case LEDGER_ENTRY_UPDATED:\n  //       LedgerEntry updated;\n  //   case LEDGER_ENTRY_REMOVED:\n  //       LedgerKey removed;\n  //   case LEDGER_ENTRY_STATE:\n  //       LedgerEntry state;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerEntryChange\", {\n    switchOn: xdr.lookup(\"LedgerEntryChangeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerEntryCreated\", \"created\"], [\"ledgerEntryUpdated\", \"updated\"], [\"ledgerEntryRemoved\", \"removed\"], [\"ledgerEntryState\", \"state\"]],\n    arms: {\n      created: xdr.lookup(\"LedgerEntry\"),\n      updated: xdr.lookup(\"LedgerEntry\"),\n      removed: xdr.lookup(\"LedgerKey\"),\n      state: xdr.lookup(\"LedgerEntry\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   typedef LedgerEntryChange LedgerEntryChanges<>;\n  //\n  // ===========================================================================\n\n  xdr.typedef(\"LedgerEntryChanges\", xdr.varArray(xdr.lookup(\"LedgerEntryChange\"), 2147483647)); // === xdr source ============================================================\n  //\n  //   struct OperationMeta\n  //   {\n  //       LedgerEntryChanges changes;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"OperationMeta\", [[\"changes\", xdr.lookup(\"LedgerEntryChanges\")]]); // === xdr source ============================================================\n  //\n  //   struct TransactionMetaV1\n  //   {\n  //       LedgerEntryChanges txChanges; // tx level changes if any\n  //       OperationMeta operations<>;   // meta for each operation\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionMetaV1\", [[\"txChanges\", xdr.lookup(\"LedgerEntryChanges\")], [\"operations\", xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   struct TransactionMetaV2\n  //   {\n  //       LedgerEntryChanges txChangesBefore; // tx level changes before operations\n  //                                           // are applied if any\n  //       OperationMeta operations<>;         // meta for each operation\n  //       LedgerEntryChanges txChangesAfter;  // tx level changes after operations are\n  //                                           // applied if any\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionMetaV2\", [[\"txChangesBefore\", xdr.lookup(\"LedgerEntryChanges\")], [\"operations\", xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647)], [\"txChangesAfter\", xdr.lookup(\"LedgerEntryChanges\")]]); // === xdr source ============================================================\n  //\n  //   union TransactionMeta switch (int v)\n  //   {\n  //   case 0:\n  //       OperationMeta operations<>;\n  //   case 1:\n  //       TransactionMetaV1 v1;\n  //   case 2:\n  //       TransactionMetaV2 v2;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"TransactionMeta\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"operations\"], [1, \"v1\"], [2, \"v2\"]],\n    arms: {\n      operations: xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647),\n      v1: xdr.lookup(\"TransactionMetaV1\"),\n      v2: xdr.lookup(\"TransactionMetaV2\")\n    }\n  }); // === xdr source ============================================================\n  //\n  //   struct TransactionResultMeta\n  //   {\n  //       TransactionResultPair result;\n  //       LedgerEntryChanges feeProcessing;\n  //       TransactionMeta txApplyProcessing;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"TransactionResultMeta\", [[\"result\", xdr.lookup(\"TransactionResultPair\")], [\"feeProcessing\", xdr.lookup(\"LedgerEntryChanges\")], [\"txApplyProcessing\", xdr.lookup(\"TransactionMeta\")]]); // === xdr source ============================================================\n  //\n  //   struct UpgradeEntryMeta\n  //   {\n  //       LedgerUpgrade upgrade;\n  //       LedgerEntryChanges changes;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"UpgradeEntryMeta\", [[\"upgrade\", xdr.lookup(\"LedgerUpgrade\")], [\"changes\", xdr.lookup(\"LedgerEntryChanges\")]]); // === xdr source ============================================================\n  //\n  //   struct LedgerCloseMetaV0\n  //   {\n  //       LedgerHeaderHistoryEntry ledgerHeader;\n  //       // NB: txSet is sorted in \"Hash order\"\n  //       TransactionSet txSet;\n  //   \n  //       // NB: transactions are sorted in apply order here\n  //       // fees for all transactions are processed first\n  //       // followed by applying transactions\n  //       TransactionResultMeta txProcessing<>;\n  //   \n  //       // upgrades are applied last\n  //       UpgradeEntryMeta upgradesProcessing<>;\n  //   \n  //       // other misc information attached to the ledger close\n  //       SCPHistoryEntry scpInfo<>;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.struct(\"LedgerCloseMetaV0\", [[\"ledgerHeader\", xdr.lookup(\"LedgerHeaderHistoryEntry\")], [\"txSet\", xdr.lookup(\"TransactionSet\")], [\"txProcessing\", xdr.varArray(xdr.lookup(\"TransactionResultMeta\"), 2147483647)], [\"upgradesProcessing\", xdr.varArray(xdr.lookup(\"UpgradeEntryMeta\"), 2147483647)], [\"scpInfo\", xdr.varArray(xdr.lookup(\"ScpHistoryEntry\"), 2147483647)]]); // === xdr source ============================================================\n  //\n  //   union LedgerCloseMeta switch (int v)\n  //   {\n  //   case 0:\n  //       LedgerCloseMetaV0 v0;\n  //   };\n  //\n  // ===========================================================================\n\n  xdr.union(\"LedgerCloseMeta\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"LedgerCloseMetaV0\")\n    }\n  });\n}); // Automatically generated on 2020-09-21T15:09:03-05:00\n// DO NOT EDIT or your changes may be overwritten\n\n/* jshint maxstatements:2147483647  */\n\n/* jshint esnext:true  */\n\nexports.default = types;","map":{"version":3,"sources":["/home/manuel/Escritorio/blockchain_code/blockchain-crowdfunding/test_crowdfundig/node_modules/stellar-base/lib/generated/stellar-xdr_generated.js"],"names":["Object","defineProperty","exports","value","_jsXdr","require","XDR","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","types","config","xdr","enum","errMisc","errData","errConf","errAuth","errLoad","struct","lookup","string","int","iPv4","iPv6","union","switchOn","switchName","switches","arms","ipv4","opaque","ipv6","errorMsg","auth","dontHave","getPeers","peers","getTxSet","txSet","transaction","getScpQuorumset","scpQuorumset","scpMessage","getScpState","hello","surveyRequest","surveyResponse","surveyTopology","typedef","varOpaque","varArray","topologyResponseBody","void","error","txSetHash","signedSurveyRequestMessage","signedSurveyResponseMessage","qSetHash","qSet","envelope","getScpLedgerSeq","v0","uint","uhyper","hyper","keyTypeEd25519","keyTypePreAuthTx","keyTypeHashX","keyTypeMuxedEd25519","publicKeyTypeEd25519","signerKeyTypeEd25519","signerKeyTypePreAuthTx","signerKeyTypeHashX","ed25519","preAuthTx","hashX","med25519","createAccount","payment","pathPaymentStrictReceive","manageSellOffer","createPassiveSellOffer","setOptions","changeTrust","allowTrust","accountMerge","inflation","manageData","bumpSequence","manageBuyOffer","pathPaymentStrictSend","createClaimableBalance","claimClaimableBalance","beginSponsoringFutureReserves","endSponsoringFutureReserves","revokeSponsorship","option","assetCode4","assetCode12","revokeSponsorshipLedgerEntry","revokeSponsorshipSigner","ledgerKey","signer","createAccountOp","paymentOp","pathPaymentStrictReceiveOp","manageSellOfferOp","createPassiveSellOfferOp","setOptionsOp","changeTrustOp","allowTrustOp","destination","manageDataOp","bumpSequenceOp","manageBuyOfferOp","pathPaymentStrictSendOp","createClaimableBalanceOp","claimClaimableBalanceOp","beginSponsoringFutureReservesOp","revokeSponsorshipOp","id","memoNone","memoText","memoId","memoHash","memoReturn","text","hash","retHash","const","v1","feeBump","tx","createAccountSuccess","createAccountMalformed","createAccountUnderfunded","createAccountLowReserve","createAccountAlreadyExist","defaultArm","paymentSuccess","paymentMalformed","paymentUnderfunded","paymentSrcNoTrust","paymentSrcNotAuthorized","paymentNoDestination","paymentNoTrust","paymentNotAuthorized","paymentLineFull","paymentNoIssuer","pathPaymentStrictReceiveSuccess","pathPaymentStrictReceiveMalformed","pathPaymentStrictReceiveUnderfunded","pathPaymentStrictReceiveSrcNoTrust","pathPaymentStrictReceiveSrcNotAuthorized","pathPaymentStrictReceiveNoDestination","pathPaymentStrictReceiveNoTrust","pathPaymentStrictReceiveNotAuthorized","pathPaymentStrictReceiveLineFull","pathPaymentStrictReceiveNoIssuer","pathPaymentStrictReceiveTooFewOffers","pathPaymentStrictReceiveOfferCrossSelf","pathPaymentStrictReceiveOverSendmax","success","noIssuer","pathPaymentStrictSendSuccess","pathPaymentStrictSendMalformed","pathPaymentStrictSendUnderfunded","pathPaymentStrictSendSrcNoTrust","pathPaymentStrictSendSrcNotAuthorized","pathPaymentStrictSendNoDestination","pathPaymentStrictSendNoTrust","pathPaymentStrictSendNotAuthorized","pathPaymentStrictSendLineFull","pathPaymentStrictSendNoIssuer","pathPaymentStrictSendTooFewOffers","pathPaymentStrictSendOfferCrossSelf","pathPaymentStrictSendUnderDestmin","manageSellOfferSuccess","manageSellOfferMalformed","manageSellOfferSellNoTrust","manageSellOfferBuyNoTrust","manageSellOfferSellNotAuthorized","manageSellOfferBuyNotAuthorized","manageSellOfferLineFull","manageSellOfferUnderfunded","manageSellOfferCrossSelf","manageSellOfferSellNoIssuer","manageSellOfferBuyNoIssuer","manageSellOfferNotFound","manageSellOfferLowReserve","manageOfferCreated","manageOfferUpdated","manageOfferDeleted","offer","manageBuyOfferSuccess","manageBuyOfferMalformed","manageBuyOfferSellNoTrust","manageBuyOfferBuyNoTrust","manageBuyOfferSellNotAuthorized","manageBuyOfferBuyNotAuthorized","manageBuyOfferLineFull","manageBuyOfferUnderfunded","manageBuyOfferCrossSelf","manageBuyOfferSellNoIssuer","manageBuyOfferBuyNoIssuer","manageBuyOfferNotFound","manageBuyOfferLowReserve","setOptionsSuccess","setOptionsLowReserve","setOptionsTooManySigners","setOptionsBadFlags","setOptionsInvalidInflation","setOptionsCantChange","setOptionsUnknownFlag","setOptionsThresholdOutOfRange","setOptionsBadSigner","setOptionsInvalidHomeDomain","changeTrustSuccess","changeTrustMalformed","changeTrustNoIssuer","changeTrustInvalidLimit","changeTrustLowReserve","changeTrustSelfNotAllowed","allowTrustSuccess","allowTrustMalformed","allowTrustNoTrustLine","allowTrustTrustNotRequired","allowTrustCantRevoke","allowTrustSelfNotAllowed","accountMergeSuccess","accountMergeMalformed","accountMergeNoAccount","accountMergeImmutableSet","accountMergeHasSubEntries","accountMergeSeqnumTooFar","accountMergeDestFull","accountMergeIsSponsor","sourceAccountBalance","inflationSuccess","inflationNotTime","payouts","manageDataSuccess","manageDataNotSupportedYet","manageDataNameNotFound","manageDataLowReserve","manageDataInvalidName","bumpSequenceSuccess","bumpSequenceBadSeq","createClaimableBalanceSuccess","createClaimableBalanceMalformed","createClaimableBalanceLowReserve","createClaimableBalanceNoTrust","createClaimableBalanceNotAuthorized","createClaimableBalanceUnderfunded","balanceId","claimClaimableBalanceSuccess","claimClaimableBalanceDoesNotExist","claimClaimableBalanceCannotClaim","claimClaimableBalanceLineFull","claimClaimableBalanceNoTrust","claimClaimableBalanceNotAuthorized","beginSponsoringFutureReservesSuccess","beginSponsoringFutureReservesMalformed","beginSponsoringFutureReservesAlreadySponsored","beginSponsoringFutureReservesRecursive","endSponsoringFutureReservesSuccess","endSponsoringFutureReservesNotSponsored","revokeSponsorshipSuccess","revokeSponsorshipDoesNotExist","revokeSponsorshipNotSponsor","revokeSponsorshipLowReserve","revokeSponsorshipOnlyTransferable","opInner","opBadAuth","opNoAccount","opNotSupported","opTooManySubentries","opExceededWorkLimit","opTooManySponsoring","createAccountResult","paymentResult","pathPaymentStrictReceiveResult","manageSellOfferResult","createPassiveSellOfferResult","setOptionsResult","changeTrustResult","allowTrustResult","accountMergeResult","inflationResult","manageDataResult","bumpSeqResult","manageBuyOfferResult","pathPaymentStrictSendResult","createClaimableBalanceResult","claimClaimableBalanceResult","beginSponsoringFutureReservesResult","endSponsoringFutureReservesResult","revokeSponsorshipResult","tr","txFeeBumpInnerSuccess","txSuccess","txFailed","txTooEarly","txTooLate","txMissingOperation","txBadSeq","txBadAuth","txInsufficientBalance","txNoAccount","txInsufficientFee","txBadAuthExtra","txInternalError","txNotSupported","txFeeBumpInnerFailed","txBadSponsorship","results","innerResultPair","scpStPrepare","scpStConfirm","scpStExternalize","scpStNominate","prepare","confirm","externalize","nominate","assetTypeNative","assetTypeCreditAlphanum4","assetTypeCreditAlphanum12","alphaNum4","alphaNum12","thresholdMasterWeight","thresholdLow","thresholdMed","thresholdHigh","account","trustline","data","claimableBalance","authRequiredFlag","authRevocableFlag","authImmutableFlag","v2","authorizedFlag","authorizedToMaintainLiabilitiesFlag","passiveFlag","claimPredicateUnconditional","claimPredicateAnd","claimPredicateOr","claimPredicateNot","claimPredicateBeforeAbsoluteTime","claimPredicateBeforeRelativeTime","andPredicates","orPredicates","notPredicate","absBefore","relBefore","claimantTypeV0","claimableBalanceIdTypeV0","trustLine","envelopeTypeTxV0","envelopeTypeScp","envelopeTypeTx","envelopeTypeAuth","envelopeTypeScpvalue","envelopeTypeTxFeeBump","envelopeTypeOpId","stellarValueBasic","stellarValueSigned","lcValueSignature","array","ledgerUpgradeVersion","ledgerUpgradeBaseFee","ledgerUpgradeMaxTxSetSize","ledgerUpgradeBaseReserve","newLedgerVersion","newBaseFee","newMaxTxSetSize","newBaseReserve","metaentry","liveentry","deadentry","initentry","liveEntry","deadEntry","metaEntry","ledgerEntryCreated","ledgerEntryUpdated","ledgerEntryRemoved","ledgerEntryState","created","updated","removed","state","operations"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jsXdr = require(\"js-xdr\");\n\nvar XDR = _interopRequireWildcard(_jsXdr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar types = XDR.config(function (xdr) {\n\n  // === xdr source ============================================================\n  //\n  //   enum ErrorCode\n  //   {\n  //       ERR_MISC = 0, // Unspecific error\n  //       ERR_DATA = 1, // Malformed data\n  //       ERR_CONF = 2, // Misconfiguration error\n  //       ERR_AUTH = 3, // Authentication failure\n  //       ERR_LOAD = 4  // System overloaded\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ErrorCode\", {\n    errMisc: 0,\n    errData: 1,\n    errConf: 2,\n    errAuth: 3,\n    errLoad: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Error\n  //   {\n  //       ErrorCode code;\n  //       string msg<100>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Error\", [[\"code\", xdr.lookup(\"ErrorCode\")], [\"msg\", xdr.string(100)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct AuthCert\n  //   {\n  //       Curve25519Public pubkey;\n  //       uint64 expiration;\n  //       Signature sig;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AuthCert\", [[\"pubkey\", xdr.lookup(\"Curve25519Public\")], [\"expiration\", xdr.lookup(\"Uint64\")], [\"sig\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Hello\n  //   {\n  //       uint32 ledgerVersion;\n  //       uint32 overlayVersion;\n  //       uint32 overlayMinVersion;\n  //       Hash networkID;\n  //       string versionStr<100>;\n  //       int listeningPort;\n  //       NodeID peerID;\n  //       AuthCert cert;\n  //       uint256 nonce;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Hello\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"overlayVersion\", xdr.lookup(\"Uint32\")], [\"overlayMinVersion\", xdr.lookup(\"Uint32\")], [\"networkId\", xdr.lookup(\"Hash\")], [\"versionStr\", xdr.string(100)], [\"listeningPort\", xdr.int()], [\"peerId\", xdr.lookup(\"NodeId\")], [\"cert\", xdr.lookup(\"AuthCert\")], [\"nonce\", xdr.lookup(\"Uint256\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Auth\n  //   {\n  //       // Empty message, just to confirm\n  //       // establishment of MAC keys.\n  //       int unused;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Auth\", [[\"unused\", xdr.int()]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum IPAddrType\n  //   {\n  //       IPv4 = 0,\n  //       IPv6 = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"IpAddrType\", {\n    iPv4: 0,\n    iPv6: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"PeerAddressIp\", {\n    switchOn: xdr.lookup(\"IpAddrType\"),\n    switchName: \"type\",\n    switches: [[\"iPv4\", \"ipv4\"], [\"iPv6\", \"ipv6\"]],\n    arms: {\n      ipv4: xdr.opaque(4),\n      ipv6: xdr.opaque(16)\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct PeerAddress\n  //   {\n  //       union switch (IPAddrType type)\n  //       {\n  //       case IPv4:\n  //           opaque ipv4[4];\n  //       case IPv6:\n  //           opaque ipv6[16];\n  //       }\n  //       ip;\n  //       uint32 port;\n  //       uint32 numFailures;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PeerAddress\", [[\"ip\", xdr.lookup(\"PeerAddressIp\")], [\"port\", xdr.lookup(\"Uint32\")], [\"numFailures\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum MessageType\n  //   {\n  //       ERROR_MSG = 0,\n  //       AUTH = 2,\n  //       DONT_HAVE = 3,\n  //   \n  //       GET_PEERS = 4, // gets a list of peers this guy knows about\n  //       PEERS = 5,\n  //   \n  //       GET_TX_SET = 6, // gets a particular txset by hash\n  //       TX_SET = 7,\n  //   \n  //       TRANSACTION = 8, // pass on a tx you have heard about\n  //   \n  //       // SCP\n  //       GET_SCP_QUORUMSET = 9,\n  //       SCP_QUORUMSET = 10,\n  //       SCP_MESSAGE = 11,\n  //       GET_SCP_STATE = 12,\n  //   \n  //       // new messages\n  //       HELLO = 13,\n  //   \n  //       SURVEY_REQUEST = 14,\n  //       SURVEY_RESPONSE = 15\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"MessageType\", {\n    errorMsg: 0,\n    auth: 2,\n    dontHave: 3,\n    getPeers: 4,\n    peers: 5,\n    getTxSet: 6,\n    txSet: 7,\n    transaction: 8,\n    getScpQuorumset: 9,\n    scpQuorumset: 10,\n    scpMessage: 11,\n    getScpState: 12,\n    hello: 13,\n    surveyRequest: 14,\n    surveyResponse: 15\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct DontHave\n  //   {\n  //       MessageType type;\n  //       uint256 reqHash;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"DontHave\", [[\"type\", xdr.lookup(\"MessageType\")], [\"reqHash\", xdr.lookup(\"Uint256\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum SurveyMessageCommandType\n  //   {\n  //       SURVEY_TOPOLOGY = 0\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"SurveyMessageCommandType\", {\n    surveyTopology: 0\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SurveyRequestMessage\n  //   {\n  //       NodeID surveyorPeerID;\n  //       NodeID surveyedPeerID;\n  //       uint32 ledgerNum;\n  //       Curve25519Public encryptionKey;\n  //       SurveyMessageCommandType commandType;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SurveyRequestMessage\", [[\"surveyorPeerId\", xdr.lookup(\"NodeId\")], [\"surveyedPeerId\", xdr.lookup(\"NodeId\")], [\"ledgerNum\", xdr.lookup(\"Uint32\")], [\"encryptionKey\", xdr.lookup(\"Curve25519Public\")], [\"commandType\", xdr.lookup(\"SurveyMessageCommandType\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SignedSurveyRequestMessage\n  //   {\n  //       Signature requestSignature;\n  //       SurveyRequestMessage request;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SignedSurveyRequestMessage\", [[\"requestSignature\", xdr.lookup(\"Signature\")], [\"request\", xdr.lookup(\"SurveyRequestMessage\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque EncryptedBody<64000>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"EncryptedBody\", xdr.varOpaque(64000));\n\n  // === xdr source ============================================================\n  //\n  //   struct SurveyResponseMessage\n  //   {\n  //       NodeID surveyorPeerID;\n  //       NodeID surveyedPeerID;\n  //       uint32 ledgerNum;\n  //       SurveyMessageCommandType commandType;\n  //       EncryptedBody encryptedBody;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SurveyResponseMessage\", [[\"surveyorPeerId\", xdr.lookup(\"NodeId\")], [\"surveyedPeerId\", xdr.lookup(\"NodeId\")], [\"ledgerNum\", xdr.lookup(\"Uint32\")], [\"commandType\", xdr.lookup(\"SurveyMessageCommandType\")], [\"encryptedBody\", xdr.lookup(\"EncryptedBody\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SignedSurveyResponseMessage\n  //   {\n  //       Signature responseSignature;\n  //       SurveyResponseMessage response;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SignedSurveyResponseMessage\", [[\"responseSignature\", xdr.lookup(\"Signature\")], [\"response\", xdr.lookup(\"SurveyResponseMessage\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct PeerStats\n  //   {\n  //       NodeID id;\n  //       string versionStr<100>;\n  //       uint64 messagesRead;\n  //       uint64 messagesWritten;\n  //       uint64 bytesRead;\n  //       uint64 bytesWritten;\n  //       uint64 secondsConnected;\n  //   \n  //       uint64 uniqueFloodBytesRecv;\n  //       uint64 duplicateFloodBytesRecv;\n  //       uint64 uniqueFetchBytesRecv;\n  //       uint64 duplicateFetchBytesRecv;\n  //   \n  //       uint64 uniqueFloodMessageRecv;\n  //       uint64 duplicateFloodMessageRecv;\n  //       uint64 uniqueFetchMessageRecv;\n  //       uint64 duplicateFetchMessageRecv;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PeerStats\", [[\"id\", xdr.lookup(\"NodeId\")], [\"versionStr\", xdr.string(100)], [\"messagesRead\", xdr.lookup(\"Uint64\")], [\"messagesWritten\", xdr.lookup(\"Uint64\")], [\"bytesRead\", xdr.lookup(\"Uint64\")], [\"bytesWritten\", xdr.lookup(\"Uint64\")], [\"secondsConnected\", xdr.lookup(\"Uint64\")], [\"uniqueFloodBytesRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFloodBytesRecv\", xdr.lookup(\"Uint64\")], [\"uniqueFetchBytesRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFetchBytesRecv\", xdr.lookup(\"Uint64\")], [\"uniqueFloodMessageRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFloodMessageRecv\", xdr.lookup(\"Uint64\")], [\"uniqueFetchMessageRecv\", xdr.lookup(\"Uint64\")], [\"duplicateFetchMessageRecv\", xdr.lookup(\"Uint64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   typedef PeerStats PeerStatList<25>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"PeerStatList\", xdr.varArray(xdr.lookup(\"PeerStats\"), 25));\n\n  // === xdr source ============================================================\n  //\n  //   struct TopologyResponseBody\n  //   {\n  //       PeerStatList inboundPeers;\n  //       PeerStatList outboundPeers;\n  //   \n  //       uint32 totalInboundPeerCount;\n  //       uint32 totalOutboundPeerCount;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TopologyResponseBody\", [[\"inboundPeers\", xdr.lookup(\"PeerStatList\")], [\"outboundPeers\", xdr.lookup(\"PeerStatList\")], [\"totalInboundPeerCount\", xdr.lookup(\"Uint32\")], [\"totalOutboundPeerCount\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union SurveyResponseBody switch (SurveyMessageCommandType type)\n  //   {\n  //   case SURVEY_TOPOLOGY:\n  //       TopologyResponseBody topologyResponseBody;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"SurveyResponseBody\", {\n    switchOn: xdr.lookup(\"SurveyMessageCommandType\"),\n    switchName: \"type\",\n    switches: [[\"surveyTopology\", \"topologyResponseBody\"]],\n    arms: {\n      topologyResponseBody: xdr.lookup(\"TopologyResponseBody\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union StellarMessage switch (MessageType type)\n  //   {\n  //   case ERROR_MSG:\n  //       Error error;\n  //   case HELLO:\n  //       Hello hello;\n  //   case AUTH:\n  //       Auth auth;\n  //   case DONT_HAVE:\n  //       DontHave dontHave;\n  //   case GET_PEERS:\n  //       void;\n  //   case PEERS:\n  //       PeerAddress peers<100>;\n  //   \n  //   case GET_TX_SET:\n  //       uint256 txSetHash;\n  //   case TX_SET:\n  //       TransactionSet txSet;\n  //   \n  //   case TRANSACTION:\n  //       TransactionEnvelope transaction;\n  //   \n  //   case SURVEY_REQUEST:\n  //       SignedSurveyRequestMessage signedSurveyRequestMessage;\n  //   \n  //   case SURVEY_RESPONSE:\n  //       SignedSurveyResponseMessage signedSurveyResponseMessage;\n  //   \n  //   // SCP\n  //   case GET_SCP_QUORUMSET:\n  //       uint256 qSetHash;\n  //   case SCP_QUORUMSET:\n  //       SCPQuorumSet qSet;\n  //   case SCP_MESSAGE:\n  //       SCPEnvelope envelope;\n  //   case GET_SCP_STATE:\n  //       uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"StellarMessage\", {\n    switchOn: xdr.lookup(\"MessageType\"),\n    switchName: \"type\",\n    switches: [[\"errorMsg\", \"error\"], [\"hello\", \"hello\"], [\"auth\", \"auth\"], [\"dontHave\", \"dontHave\"], [\"getPeers\", xdr.void()], [\"peers\", \"peers\"], [\"getTxSet\", \"txSetHash\"], [\"txSet\", \"txSet\"], [\"transaction\", \"transaction\"], [\"surveyRequest\", \"signedSurveyRequestMessage\"], [\"surveyResponse\", \"signedSurveyResponseMessage\"], [\"getScpQuorumset\", \"qSetHash\"], [\"scpQuorumset\", \"qSet\"], [\"scpMessage\", \"envelope\"], [\"getScpState\", \"getScpLedgerSeq\"]],\n    arms: {\n      error: xdr.lookup(\"Error\"),\n      hello: xdr.lookup(\"Hello\"),\n      auth: xdr.lookup(\"Auth\"),\n      dontHave: xdr.lookup(\"DontHave\"),\n      peers: xdr.varArray(xdr.lookup(\"PeerAddress\"), 100),\n      txSetHash: xdr.lookup(\"Uint256\"),\n      txSet: xdr.lookup(\"TransactionSet\"),\n      transaction: xdr.lookup(\"TransactionEnvelope\"),\n      signedSurveyRequestMessage: xdr.lookup(\"SignedSurveyRequestMessage\"),\n      signedSurveyResponseMessage: xdr.lookup(\"SignedSurveyResponseMessage\"),\n      qSetHash: xdr.lookup(\"Uint256\"),\n      qSet: xdr.lookup(\"ScpQuorumSet\"),\n      envelope: xdr.lookup(\"ScpEnvelope\"),\n      getScpLedgerSeq: xdr.lookup(\"Uint32\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           uint64 sequence;\n  //           StellarMessage message;\n  //           HmacSha256Mac mac;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"AuthenticatedMessageV0\", [[\"sequence\", xdr.lookup(\"Uint64\")], [\"message\", xdr.lookup(\"StellarMessage\")], [\"mac\", xdr.lookup(\"HmacSha256Mac\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union AuthenticatedMessage switch (uint32 v)\n  //   {\n  //   case 0:\n  //       struct\n  //       {\n  //           uint64 sequence;\n  //           StellarMessage message;\n  //           HmacSha256Mac mac;\n  //       } v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"AuthenticatedMessage\", {\n    switchOn: xdr.lookup(\"Uint32\"),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"AuthenticatedMessageV0\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Hash[32];\n  //\n  // ===========================================================================\n  xdr.typedef(\"Hash\", xdr.opaque(32));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque uint256[32];\n  //\n  // ===========================================================================\n  xdr.typedef(\"Uint256\", xdr.opaque(32));\n\n  // === xdr source ============================================================\n  //\n  //   typedef unsigned int uint32;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Uint32\", xdr.uint());\n\n  // === xdr source ============================================================\n  //\n  //   typedef int int32;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Int32\", xdr.int());\n\n  // === xdr source ============================================================\n  //\n  //   typedef unsigned hyper uint64;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Uint64\", xdr.uhyper());\n\n  // === xdr source ============================================================\n  //\n  //   typedef hyper int64;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Int64\", xdr.hyper());\n\n  // === xdr source ============================================================\n  //\n  //   enum CryptoKeyType\n  //   {\n  //       KEY_TYPE_ED25519 = 0,\n  //       KEY_TYPE_PRE_AUTH_TX = 1,\n  //       KEY_TYPE_HASH_X = 2,\n  //       // MUXED enum values for supported type are derived from the enum values\n  //       // above by ORing them with 0x100\n  //       KEY_TYPE_MUXED_ED25519 = 0x100\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"CryptoKeyType\", {\n    keyTypeEd25519: 0,\n    keyTypePreAuthTx: 1,\n    keyTypeHashX: 2,\n    keyTypeMuxedEd25519: 256\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PublicKeyType\n  //   {\n  //       PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PublicKeyType\", {\n    publicKeyTypeEd25519: 0\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum SignerKeyType\n  //   {\n  //       SIGNER_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,\n  //       SIGNER_KEY_TYPE_PRE_AUTH_TX = KEY_TYPE_PRE_AUTH_TX,\n  //       SIGNER_KEY_TYPE_HASH_X = KEY_TYPE_HASH_X\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"SignerKeyType\", {\n    signerKeyTypeEd25519: 0,\n    signerKeyTypePreAuthTx: 1,\n    signerKeyTypeHashX: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union PublicKey switch (PublicKeyType type)\n  //   {\n  //   case PUBLIC_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PublicKey\", {\n    switchOn: xdr.lookup(\"PublicKeyType\"),\n    switchName: \"type\",\n    switches: [[\"publicKeyTypeEd25519\", \"ed25519\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union SignerKey switch (SignerKeyType type)\n  //   {\n  //   case SIGNER_KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   case SIGNER_KEY_TYPE_PRE_AUTH_TX:\n  //       /* SHA-256 Hash of TransactionSignaturePayload structure */\n  //       uint256 preAuthTx;\n  //   case SIGNER_KEY_TYPE_HASH_X:\n  //       /* Hash of random 256 bit preimage X */\n  //       uint256 hashX;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"SignerKey\", {\n    switchOn: xdr.lookup(\"SignerKeyType\"),\n    switchName: \"type\",\n    switches: [[\"signerKeyTypeEd25519\", \"ed25519\"], [\"signerKeyTypePreAuthTx\", \"preAuthTx\"], [\"signerKeyTypeHashX\", \"hashX\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\"),\n      preAuthTx: xdr.lookup(\"Uint256\"),\n      hashX: xdr.lookup(\"Uint256\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Signature<64>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Signature\", xdr.varOpaque(64));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque SignatureHint[4];\n  //\n  // ===========================================================================\n  xdr.typedef(\"SignatureHint\", xdr.opaque(4));\n\n  // === xdr source ============================================================\n  //\n  //   typedef PublicKey NodeID;\n  //\n  // ===========================================================================\n  xdr.typedef(\"NodeId\", xdr.lookup(\"PublicKey\"));\n\n  // === xdr source ============================================================\n  //\n  //   struct Curve25519Secret\n  //   {\n  //       opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Curve25519Secret\", [[\"key\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Curve25519Public\n  //   {\n  //       opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Curve25519Public\", [[\"key\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct HmacSha256Key\n  //   {\n  //       opaque key[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"HmacSha256Key\", [[\"key\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct HmacSha256Mac\n  //   {\n  //       opaque mac[32];\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"HmacSha256Mac\", [[\"mac\", xdr.opaque(32)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           uint64 id;\n  //           uint256 ed25519;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"MuxedAccountMed25519\", [[\"id\", xdr.lookup(\"Uint64\")], [\"ed25519\", xdr.lookup(\"Uint256\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union MuxedAccount switch (CryptoKeyType type)\n  //   {\n  //   case KEY_TYPE_ED25519:\n  //       uint256 ed25519;\n  //   case KEY_TYPE_MUXED_ED25519:\n  //       struct\n  //       {\n  //           uint64 id;\n  //           uint256 ed25519;\n  //       } med25519;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"MuxedAccount\", {\n    switchOn: xdr.lookup(\"CryptoKeyType\"),\n    switchName: \"type\",\n    switches: [[\"keyTypeEd25519\", \"ed25519\"], [\"keyTypeMuxedEd25519\", \"med25519\"]],\n    arms: {\n      ed25519: xdr.lookup(\"Uint256\"),\n      med25519: xdr.lookup(\"MuxedAccountMed25519\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct DecoratedSignature\n  //   {\n  //       SignatureHint hint;  // last 4 bytes of the public key, used as a hint\n  //       Signature signature; // actual signature\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"DecoratedSignature\", [[\"hint\", xdr.lookup(\"SignatureHint\")], [\"signature\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum OperationType\n  //   {\n  //       CREATE_ACCOUNT = 0,\n  //       PAYMENT = 1,\n  //       PATH_PAYMENT_STRICT_RECEIVE = 2,\n  //       MANAGE_SELL_OFFER = 3,\n  //       CREATE_PASSIVE_SELL_OFFER = 4,\n  //       SET_OPTIONS = 5,\n  //       CHANGE_TRUST = 6,\n  //       ALLOW_TRUST = 7,\n  //       ACCOUNT_MERGE = 8,\n  //       INFLATION = 9,\n  //       MANAGE_DATA = 10,\n  //       BUMP_SEQUENCE = 11,\n  //       MANAGE_BUY_OFFER = 12,\n  //       PATH_PAYMENT_STRICT_SEND = 13,\n  //       CREATE_CLAIMABLE_BALANCE = 14,\n  //       CLAIM_CLAIMABLE_BALANCE = 15,\n  //       BEGIN_SPONSORING_FUTURE_RESERVES = 16,\n  //       END_SPONSORING_FUTURE_RESERVES = 17,\n  //       REVOKE_SPONSORSHIP = 18\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"OperationType\", {\n    createAccount: 0,\n    payment: 1,\n    pathPaymentStrictReceive: 2,\n    manageSellOffer: 3,\n    createPassiveSellOffer: 4,\n    setOptions: 5,\n    changeTrust: 6,\n    allowTrust: 7,\n    accountMerge: 8,\n    inflation: 9,\n    manageData: 10,\n    bumpSequence: 11,\n    manageBuyOffer: 12,\n    pathPaymentStrictSend: 13,\n    createClaimableBalance: 14,\n    claimClaimableBalance: 15,\n    beginSponsoringFutureReserves: 16,\n    endSponsoringFutureReserves: 17,\n    revokeSponsorship: 18\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct CreateAccountOp\n  //   {\n  //       AccountID destination; // account to create\n  //       int64 startingBalance; // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"CreateAccountOp\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"startingBalance\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct PaymentOp\n  //   {\n  //       MuxedAccount destination; // recipient of the payment\n  //       Asset asset;              // what they end up with\n  //       int64 amount;             // amount they end up with\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PaymentOp\", [[\"destination\", xdr.lookup(\"MuxedAccount\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct PathPaymentStrictReceiveOp\n  //   {\n  //       Asset sendAsset; // asset we pay with\n  //       int64 sendMax;   // the maximum amount of sendAsset to\n  //                        // send (excluding fees).\n  //                        // The operation will fail if can't be met\n  //   \n  //       MuxedAccount destination; // recipient of the payment\n  //       Asset destAsset;          // what they end up with\n  //       int64 destAmount;         // amount they end up with\n  //   \n  //       Asset path<5>; // additional hops it must go through to get there\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PathPaymentStrictReceiveOp\", [[\"sendAsset\", xdr.lookup(\"Asset\")], [\"sendMax\", xdr.lookup(\"Int64\")], [\"destination\", xdr.lookup(\"MuxedAccount\")], [\"destAsset\", xdr.lookup(\"Asset\")], [\"destAmount\", xdr.lookup(\"Int64\")], [\"path\", xdr.varArray(xdr.lookup(\"Asset\"), 5)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct PathPaymentStrictSendOp\n  //   {\n  //       Asset sendAsset;  // asset we pay with\n  //       int64 sendAmount; // amount of sendAsset to send (excluding fees)\n  //   \n  //       MuxedAccount destination; // recipient of the payment\n  //       Asset destAsset;          // what they end up with\n  //       int64 destMin;            // the minimum amount of dest asset to\n  //                                 // be received\n  //                                 // The operation will fail if it can't be met\n  //   \n  //       Asset path<5>; // additional hops it must go through to get there\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"PathPaymentStrictSendOp\", [[\"sendAsset\", xdr.lookup(\"Asset\")], [\"sendAmount\", xdr.lookup(\"Int64\")], [\"destination\", xdr.lookup(\"MuxedAccount\")], [\"destAsset\", xdr.lookup(\"Asset\")], [\"destMin\", xdr.lookup(\"Int64\")], [\"path\", xdr.varArray(xdr.lookup(\"Asset\"), 5)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageSellOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 amount; // amount being sold. if set to 0, delete the offer\n  //       Price price;  // price of thing being sold in terms of what you are buying\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageBuyOfferOp\n  //   {\n  //       Asset selling;\n  //       Asset buying;\n  //       int64 buyAmount; // amount being bought. if set to 0, delete the offer\n  //       Price price;     // price of thing being bought in terms of what you are\n  //                        // selling\n  //   \n  //       // 0=create a new offer, otherwise edit an existing offer\n  //       int64 offerID;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageBuyOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"buyAmount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"offerId\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct CreatePassiveSellOfferOp\n  //   {\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount taker gets. if set to 0, delete the offer\n  //       Price price;   // cost of A in terms of B\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"CreatePassiveSellOfferOp\", [[\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SetOptionsOp\n  //   {\n  //       AccountID* inflationDest; // sets the inflation destination\n  //   \n  //       uint32* clearFlags; // which flags to clear\n  //       uint32* setFlags;   // which flags to set\n  //   \n  //       // account threshold manipulation\n  //       uint32* masterWeight; // weight of the master account\n  //       uint32* lowThreshold;\n  //       uint32* medThreshold;\n  //       uint32* highThreshold;\n  //   \n  //       string32* homeDomain; // sets the home domain\n  //   \n  //       // Add, update or remove a signer for the account\n  //       // signer is deleted if the weight is 0\n  //       Signer* signer;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SetOptionsOp\", [[\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"clearFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"setFlags\", xdr.option(xdr.lookup(\"Uint32\"))], [\"masterWeight\", xdr.option(xdr.lookup(\"Uint32\"))], [\"lowThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"medThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"highThreshold\", xdr.option(xdr.lookup(\"Uint32\"))], [\"homeDomain\", xdr.option(xdr.lookup(\"String32\"))], [\"signer\", xdr.option(xdr.lookup(\"Signer\"))]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ChangeTrustOp\n  //   {\n  //       Asset line;\n  //   \n  //       // if limit is set to 0, deletes the trust line\n  //       int64 limit;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ChangeTrustOp\", [[\"line\", xdr.lookup(\"Asset\")], [\"limit\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"AllowTrustOpAsset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeCreditAlphanum4\", \"assetCode4\"], [\"assetTypeCreditAlphanum12\", \"assetCode12\"]],\n    arms: {\n      assetCode4: xdr.lookup(\"AssetCode4\"),\n      assetCode12: xdr.lookup(\"AssetCode12\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct AllowTrustOp\n  //   {\n  //       AccountID trustor;\n  //       union switch (AssetType type)\n  //       {\n  //       // ASSET_TYPE_NATIVE is not allowed\n  //       case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //           AssetCode4 assetCode4;\n  //   \n  //       case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //           AssetCode12 assetCode12;\n  //   \n  //           // add other asset types here in the future\n  //       }\n  //       asset;\n  //   \n  //       // 0, or any bitwise combination of TrustLineFlags\n  //       uint32 authorize;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AllowTrustOp\", [[\"trustor\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"AllowTrustOpAsset\")], [\"authorize\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageDataOp\n  //   {\n  //       string64 dataName;\n  //       DataValue* dataValue; // set to null to clear\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageDataOp\", [[\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.option(xdr.lookup(\"DataValue\"))]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct BumpSequenceOp\n  //   {\n  //       SequenceNumber bumpTo;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"BumpSequenceOp\", [[\"bumpTo\", xdr.lookup(\"SequenceNumber\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct CreateClaimableBalanceOp\n  //   {\n  //       Asset asset;\n  //       int64 amount;\n  //       Claimant claimants<10>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"CreateClaimableBalanceOp\", [[\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"claimants\", xdr.varArray(xdr.lookup(\"Claimant\"), 10)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ClaimClaimableBalanceOp\n  //   {\n  //       ClaimableBalanceID balanceID;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ClaimClaimableBalanceOp\", [[\"balanceId\", xdr.lookup(\"ClaimableBalanceId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct BeginSponsoringFutureReservesOp\n  //   {\n  //       AccountID sponsoredID;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"BeginSponsoringFutureReservesOp\", [[\"sponsoredId\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum RevokeSponsorshipType\n  //   {\n  //       REVOKE_SPONSORSHIP_LEDGER_ENTRY = 0,\n  //       REVOKE_SPONSORSHIP_SIGNER = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"RevokeSponsorshipType\", {\n    revokeSponsorshipLedgerEntry: 0,\n    revokeSponsorshipSigner: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           SignerKey signerKey;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"RevokeSponsorshipOpSigner\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"signerKey\", xdr.lookup(\"SignerKey\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union RevokeSponsorshipOp switch (RevokeSponsorshipType type)\n  //   {\n  //   case REVOKE_SPONSORSHIP_LEDGER_ENTRY:\n  //       LedgerKey ledgerKey;\n  //   case REVOKE_SPONSORSHIP_SIGNER:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           SignerKey signerKey;\n  //       }\n  //       signer;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"RevokeSponsorshipOp\", {\n    switchOn: xdr.lookup(\"RevokeSponsorshipType\"),\n    switchName: \"type\",\n    switches: [[\"revokeSponsorshipLedgerEntry\", \"ledgerKey\"], [\"revokeSponsorshipSigner\", \"signer\"]],\n    arms: {\n      ledgerKey: xdr.lookup(\"LedgerKey\"),\n      signer: xdr.lookup(\"RevokeSponsorshipOpSigner\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           MuxedAccount destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendOp pathPaymentStrictSendOp;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceOp createClaimableBalanceOp;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceOp claimClaimableBalanceOp;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           void;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipOp revokeSponsorshipOp;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"OperationBody\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountOp\"], [\"payment\", \"paymentOp\"], [\"pathPaymentStrictReceive\", \"pathPaymentStrictReceiveOp\"], [\"manageSellOffer\", \"manageSellOfferOp\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferOp\"], [\"setOptions\", \"setOptionsOp\"], [\"changeTrust\", \"changeTrustOp\"], [\"allowTrust\", \"allowTrustOp\"], [\"accountMerge\", \"destination\"], [\"inflation\", xdr.void()], [\"manageData\", \"manageDataOp\"], [\"bumpSequence\", \"bumpSequenceOp\"], [\"manageBuyOffer\", \"manageBuyOfferOp\"], [\"pathPaymentStrictSend\", \"pathPaymentStrictSendOp\"], [\"createClaimableBalance\", \"createClaimableBalanceOp\"], [\"claimClaimableBalance\", \"claimClaimableBalanceOp\"], [\"beginSponsoringFutureReserves\", \"beginSponsoringFutureReservesOp\"], [\"endSponsoringFutureReserves\", xdr.void()], [\"revokeSponsorship\", \"revokeSponsorshipOp\"]],\n    arms: {\n      createAccountOp: xdr.lookup(\"CreateAccountOp\"),\n      paymentOp: xdr.lookup(\"PaymentOp\"),\n      pathPaymentStrictReceiveOp: xdr.lookup(\"PathPaymentStrictReceiveOp\"),\n      manageSellOfferOp: xdr.lookup(\"ManageSellOfferOp\"),\n      createPassiveSellOfferOp: xdr.lookup(\"CreatePassiveSellOfferOp\"),\n      setOptionsOp: xdr.lookup(\"SetOptionsOp\"),\n      changeTrustOp: xdr.lookup(\"ChangeTrustOp\"),\n      allowTrustOp: xdr.lookup(\"AllowTrustOp\"),\n      destination: xdr.lookup(\"MuxedAccount\"),\n      manageDataOp: xdr.lookup(\"ManageDataOp\"),\n      bumpSequenceOp: xdr.lookup(\"BumpSequenceOp\"),\n      manageBuyOfferOp: xdr.lookup(\"ManageBuyOfferOp\"),\n      pathPaymentStrictSendOp: xdr.lookup(\"PathPaymentStrictSendOp\"),\n      createClaimableBalanceOp: xdr.lookup(\"CreateClaimableBalanceOp\"),\n      claimClaimableBalanceOp: xdr.lookup(\"ClaimClaimableBalanceOp\"),\n      beginSponsoringFutureReservesOp: xdr.lookup(\"BeginSponsoringFutureReservesOp\"),\n      revokeSponsorshipOp: xdr.lookup(\"RevokeSponsorshipOp\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Operation\n  //   {\n  //       // sourceAccount is the account used to run the operation\n  //       // if not set, the runtime defaults to \"sourceAccount\" specified at\n  //       // the transaction level\n  //       MuxedAccount* sourceAccount;\n  //   \n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountOp createAccountOp;\n  //       case PAYMENT:\n  //           PaymentOp paymentOp;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferOp manageSellOfferOp;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           CreatePassiveSellOfferOp createPassiveSellOfferOp;\n  //       case SET_OPTIONS:\n  //           SetOptionsOp setOptionsOp;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustOp changeTrustOp;\n  //       case ALLOW_TRUST:\n  //           AllowTrustOp allowTrustOp;\n  //       case ACCOUNT_MERGE:\n  //           MuxedAccount destination;\n  //       case INFLATION:\n  //           void;\n  //       case MANAGE_DATA:\n  //           ManageDataOp manageDataOp;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceOp bumpSequenceOp;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferOp manageBuyOfferOp;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendOp pathPaymentStrictSendOp;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceOp createClaimableBalanceOp;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceOp claimClaimableBalanceOp;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           void;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipOp revokeSponsorshipOp;\n  //       }\n  //       body;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Operation\", [[\"sourceAccount\", xdr.option(xdr.lookup(\"MuxedAccount\"))], [\"body\", xdr.lookup(\"OperationBody\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           MuxedAccount sourceAccount;\n  //           SequenceNumber seqNum;\n  //           uint32 opNum;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"OperationIdId\", [[\"sourceAccount\", xdr.lookup(\"MuxedAccount\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"opNum\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union OperationID switch (EnvelopeType type)\n  //   {\n  //   case ENVELOPE_TYPE_OP_ID:\n  //       struct\n  //       {\n  //           MuxedAccount sourceAccount;\n  //           SequenceNumber seqNum;\n  //           uint32 opNum;\n  //       } id;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"OperationId\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeOpId\", \"id\"]],\n    arms: {\n      id: xdr.lookup(\"OperationIdId\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum MemoType\n  //   {\n  //       MEMO_NONE = 0,\n  //       MEMO_TEXT = 1,\n  //       MEMO_ID = 2,\n  //       MEMO_HASH = 3,\n  //       MEMO_RETURN = 4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"MemoType\", {\n    memoNone: 0,\n    memoText: 1,\n    memoId: 2,\n    memoHash: 3,\n    memoReturn: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union Memo switch (MemoType type)\n  //   {\n  //   case MEMO_NONE:\n  //       void;\n  //   case MEMO_TEXT:\n  //       string text<28>;\n  //   case MEMO_ID:\n  //       uint64 id;\n  //   case MEMO_HASH:\n  //       Hash hash; // the hash of what to pull from the content server\n  //   case MEMO_RETURN:\n  //       Hash retHash; // the hash of the tx you are rejecting\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"Memo\", {\n    switchOn: xdr.lookup(\"MemoType\"),\n    switchName: \"type\",\n    switches: [[\"memoNone\", xdr.void()], [\"memoText\", \"text\"], [\"memoId\", \"id\"], [\"memoHash\", \"hash\"], [\"memoReturn\", \"retHash\"]],\n    arms: {\n      text: xdr.string(28),\n      id: xdr.lookup(\"Uint64\"),\n      hash: xdr.lookup(\"Hash\"),\n      retHash: xdr.lookup(\"Hash\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TimeBounds\n  //   {\n  //       TimePoint minTime;\n  //       TimePoint maxTime; // 0 here means no maxTime\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TimeBounds\", [[\"minTime\", xdr.lookup(\"TimePoint\")], [\"maxTime\", xdr.lookup(\"TimePoint\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   const MAX_OPS_PER_TX = 100;\n  //\n  // ===========================================================================\n  xdr.const(\"MAX_OPS_PER_TX\", 100);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionV0Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionV0\n  //   {\n  //       uint256 sourceAccountEd25519;\n  //       uint32 fee;\n  //       SequenceNumber seqNum;\n  //       TimeBounds* timeBounds;\n  //       Memo memo;\n  //       Operation operations<MAX_OPS_PER_TX>;\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionV0\", [[\"sourceAccountEd25519\", xdr.lookup(\"Uint256\")], [\"fee\", xdr.lookup(\"Uint32\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"timeBounds\", xdr.option(xdr.lookup(\"TimeBounds\"))], [\"memo\", xdr.lookup(\"Memo\")], [\"operations\", xdr.varArray(xdr.lookup(\"Operation\"), xdr.lookup(\"MAX_OPS_PER_TX\"))], [\"ext\", xdr.lookup(\"TransactionV0Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionV0Envelope\n  //   {\n  //       TransactionV0 tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionV0Envelope\", [[\"tx\", xdr.lookup(\"TransactionV0\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Transaction\n  //   {\n  //       // account used to run the transaction\n  //       MuxedAccount sourceAccount;\n  //   \n  //       // the fee the sourceAccount will pay\n  //       uint32 fee;\n  //   \n  //       // sequence number to consume in the account\n  //       SequenceNumber seqNum;\n  //   \n  //       // validity range (inclusive) for the last ledger close time\n  //       TimeBounds* timeBounds;\n  //   \n  //       Memo memo;\n  //   \n  //       Operation operations<MAX_OPS_PER_TX>;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Transaction\", [[\"sourceAccount\", xdr.lookup(\"MuxedAccount\")], [\"fee\", xdr.lookup(\"Uint32\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"timeBounds\", xdr.option(xdr.lookup(\"TimeBounds\"))], [\"memo\", xdr.lookup(\"Memo\")], [\"operations\", xdr.varArray(xdr.lookup(\"Operation\"), xdr.lookup(\"MAX_OPS_PER_TX\"))], [\"ext\", xdr.lookup(\"TransactionExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionV1Envelope\n  //   {\n  //       Transaction tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionV1Envelope\", [[\"tx\", xdr.lookup(\"Transaction\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           TransactionV1Envelope v1;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"FeeBumpTransactionInnerTx\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTx\", \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"TransactionV1Envelope\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"FeeBumpTransactionExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct FeeBumpTransaction\n  //   {\n  //       MuxedAccount feeSource;\n  //       int64 fee;\n  //       union switch (EnvelopeType type)\n  //       {\n  //       case ENVELOPE_TYPE_TX:\n  //           TransactionV1Envelope v1;\n  //       }\n  //       innerTx;\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"FeeBumpTransaction\", [[\"feeSource\", xdr.lookup(\"MuxedAccount\")], [\"fee\", xdr.lookup(\"Int64\")], [\"innerTx\", xdr.lookup(\"FeeBumpTransactionInnerTx\")], [\"ext\", xdr.lookup(\"FeeBumpTransactionExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct FeeBumpTransactionEnvelope\n  //   {\n  //       FeeBumpTransaction tx;\n  //       /* Each decorated signature is a signature over the SHA256 hash of\n  //        * a TransactionSignaturePayload */\n  //       DecoratedSignature signatures<20>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"FeeBumpTransactionEnvelope\", [[\"tx\", xdr.lookup(\"FeeBumpTransaction\")], [\"signatures\", xdr.varArray(xdr.lookup(\"DecoratedSignature\"), 20)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union TransactionEnvelope switch (EnvelopeType type)\n  //   {\n  //   case ENVELOPE_TYPE_TX_V0:\n  //       TransactionV0Envelope v0;\n  //   case ENVELOPE_TYPE_TX:\n  //       TransactionV1Envelope v1;\n  //   case ENVELOPE_TYPE_TX_FEE_BUMP:\n  //       FeeBumpTransactionEnvelope feeBump;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionEnvelope\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTxV0\", \"v0\"], [\"envelopeTypeTx\", \"v1\"], [\"envelopeTypeTxFeeBump\", \"feeBump\"]],\n    arms: {\n      v0: xdr.lookup(\"TransactionV0Envelope\"),\n      v1: xdr.lookup(\"TransactionV1Envelope\"),\n      feeBump: xdr.lookup(\"FeeBumpTransactionEnvelope\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (EnvelopeType type)\n  //       {\n  //       // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //       case ENVELOPE_TYPE_TX_FEE_BUMP:\n  //           FeeBumpTransaction feeBump;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionSignaturePayloadTaggedTransaction\", {\n    switchOn: xdr.lookup(\"EnvelopeType\"),\n    switchName: \"type\",\n    switches: [[\"envelopeTypeTx\", \"tx\"], [\"envelopeTypeTxFeeBump\", \"feeBump\"]],\n    arms: {\n      tx: xdr.lookup(\"Transaction\"),\n      feeBump: xdr.lookup(\"FeeBumpTransaction\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionSignaturePayload\n  //   {\n  //       Hash networkId;\n  //       union switch (EnvelopeType type)\n  //       {\n  //       // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0\n  //       case ENVELOPE_TYPE_TX:\n  //           Transaction tx;\n  //       case ENVELOPE_TYPE_TX_FEE_BUMP:\n  //           FeeBumpTransaction feeBump;\n  //       }\n  //       taggedTransaction;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionSignaturePayload\", [[\"networkId\", xdr.lookup(\"Hash\")], [\"taggedTransaction\", xdr.lookup(\"TransactionSignaturePayloadTaggedTransaction\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct ClaimOfferAtom\n  //   {\n  //       // emitted to identify the offer\n  //       AccountID sellerID; // Account that owns the offer\n  //       int64 offerID;\n  //   \n  //       // amount and asset taken from the owner\n  //       Asset assetSold;\n  //       int64 amountSold;\n  //   \n  //       // amount and asset sent to the owner\n  //       Asset assetBought;\n  //       int64 amountBought;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ClaimOfferAtom\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"assetSold\", xdr.lookup(\"Asset\")], [\"amountSold\", xdr.lookup(\"Int64\")], [\"assetBought\", xdr.lookup(\"Asset\")], [\"amountBought\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum CreateAccountResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CREATE_ACCOUNT_SUCCESS = 0, // account was created\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       CREATE_ACCOUNT_MALFORMED = -1,   // invalid destination\n  //       CREATE_ACCOUNT_UNDERFUNDED = -2, // not enough funds in source account\n  //       CREATE_ACCOUNT_LOW_RESERVE =\n  //           -3, // would create an account below the min reserve\n  //       CREATE_ACCOUNT_ALREADY_EXIST = -4 // account already exists\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"CreateAccountResultCode\", {\n    createAccountSuccess: 0,\n    createAccountMalformed: -1,\n    createAccountUnderfunded: -2,\n    createAccountLowReserve: -3,\n    createAccountAlreadyExist: -4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union CreateAccountResult switch (CreateAccountResultCode code)\n  //   {\n  //   case CREATE_ACCOUNT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"CreateAccountResult\", {\n    switchOn: xdr.lookup(\"CreateAccountResultCode\"),\n    switchName: \"code\",\n    switches: [[\"createAccountSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PaymentResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PAYMENT_SUCCESS = 0, // payment successfuly completed\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PAYMENT_MALFORMED = -1,          // bad input\n  //       PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account\n  //       PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account\n  //       PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer\n  //       PAYMENT_NO_DESTINATION = -5,     // destination account does not exist\n  //       PAYMENT_NO_TRUST = -6,       // destination missing a trust line for asset\n  //       PAYMENT_NOT_AUTHORIZED = -7, // destination not authorized to hold asset\n  //       PAYMENT_LINE_FULL = -8,      // destination would go above their limit\n  //       PAYMENT_NO_ISSUER = -9       // missing issuer on asset\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PaymentResultCode\", {\n    paymentSuccess: 0,\n    paymentMalformed: -1,\n    paymentUnderfunded: -2,\n    paymentSrcNoTrust: -3,\n    paymentSrcNotAuthorized: -4,\n    paymentNoDestination: -5,\n    paymentNoTrust: -6,\n    paymentNotAuthorized: -7,\n    paymentLineFull: -8,\n    paymentNoIssuer: -9\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union PaymentResult switch (PaymentResultCode code)\n  //   {\n  //   case PAYMENT_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PaymentResult\", {\n    switchOn: xdr.lookup(\"PaymentResultCode\"),\n    switchName: \"code\",\n    switches: [[\"paymentSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PathPaymentStrictReceiveResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PATH_PAYMENT_STRICT_RECEIVE_SUCCESS = 0, // success\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PATH_PAYMENT_STRICT_RECEIVE_MALFORMED = -1, // bad input\n  //       PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED =\n  //           -2, // not enough funds in source account\n  //       PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST =\n  //           -3, // no trust line on source account\n  //       PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED =\n  //           -4, // source not authorized to transfer\n  //       PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION =\n  //           -5, // destination account does not exist\n  //       PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST =\n  //           -6, // dest missing a trust line for asset\n  //       PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED =\n  //           -7, // dest not authorized to hold asset\n  //       PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL =\n  //           -8, // dest would go above their limit\n  //       PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER = -9, // missing issuer on one asset\n  //       PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS =\n  //           -10, // not enough offers to satisfy path\n  //       PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF =\n  //           -11, // would cross one of its own offers\n  //       PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX = -12 // could not satisfy sendmax\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PathPaymentStrictReceiveResultCode\", {\n    pathPaymentStrictReceiveSuccess: 0,\n    pathPaymentStrictReceiveMalformed: -1,\n    pathPaymentStrictReceiveUnderfunded: -2,\n    pathPaymentStrictReceiveSrcNoTrust: -3,\n    pathPaymentStrictReceiveSrcNotAuthorized: -4,\n    pathPaymentStrictReceiveNoDestination: -5,\n    pathPaymentStrictReceiveNoTrust: -6,\n    pathPaymentStrictReceiveNotAuthorized: -7,\n    pathPaymentStrictReceiveLineFull: -8,\n    pathPaymentStrictReceiveNoIssuer: -9,\n    pathPaymentStrictReceiveTooFewOffers: -10,\n    pathPaymentStrictReceiveOfferCrossSelf: -11,\n    pathPaymentStrictReceiveOverSendmax: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SimplePaymentResult\n  //   {\n  //       AccountID destination;\n  //       Asset asset;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"SimplePaymentResult\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"PathPaymentStrictReceiveResultSuccess\", [[\"offers\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"last\", xdr.lookup(\"SimplePaymentResult\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union PathPaymentStrictReceiveResult switch (PathPaymentStrictReceiveResultCode code)\n  //   {\n  //   case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:\n  //       struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       } success;\n  //   case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:\n  //       Asset noIssuer; // the asset that caused the error\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PathPaymentStrictReceiveResult\", {\n    switchOn: xdr.lookup(\"PathPaymentStrictReceiveResultCode\"),\n    switchName: \"code\",\n    switches: [[\"pathPaymentStrictReceiveSuccess\", \"success\"], [\"pathPaymentStrictReceiveNoIssuer\", \"noIssuer\"]],\n    arms: {\n      success: xdr.lookup(\"PathPaymentStrictReceiveResultSuccess\"),\n      noIssuer: xdr.lookup(\"Asset\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum PathPaymentStrictSendResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       PATH_PAYMENT_STRICT_SEND_SUCCESS = 0, // success\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       PATH_PAYMENT_STRICT_SEND_MALFORMED = -1, // bad input\n  //       PATH_PAYMENT_STRICT_SEND_UNDERFUNDED =\n  //           -2, // not enough funds in source account\n  //       PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST =\n  //           -3, // no trust line on source account\n  //       PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED =\n  //           -4, // source not authorized to transfer\n  //       PATH_PAYMENT_STRICT_SEND_NO_DESTINATION =\n  //           -5, // destination account does not exist\n  //       PATH_PAYMENT_STRICT_SEND_NO_TRUST =\n  //           -6, // dest missing a trust line for asset\n  //       PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED =\n  //           -7, // dest not authorized to hold asset\n  //       PATH_PAYMENT_STRICT_SEND_LINE_FULL = -8, // dest would go above their limit\n  //       PATH_PAYMENT_STRICT_SEND_NO_ISSUER = -9, // missing issuer on one asset\n  //       PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS =\n  //           -10, // not enough offers to satisfy path\n  //       PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF =\n  //           -11, // would cross one of its own offers\n  //       PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN = -12 // could not satisfy destMin\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"PathPaymentStrictSendResultCode\", {\n    pathPaymentStrictSendSuccess: 0,\n    pathPaymentStrictSendMalformed: -1,\n    pathPaymentStrictSendUnderfunded: -2,\n    pathPaymentStrictSendSrcNoTrust: -3,\n    pathPaymentStrictSendSrcNotAuthorized: -4,\n    pathPaymentStrictSendNoDestination: -5,\n    pathPaymentStrictSendNoTrust: -6,\n    pathPaymentStrictSendNotAuthorized: -7,\n    pathPaymentStrictSendLineFull: -8,\n    pathPaymentStrictSendNoIssuer: -9,\n    pathPaymentStrictSendTooFewOffers: -10,\n    pathPaymentStrictSendOfferCrossSelf: -11,\n    pathPaymentStrictSendUnderDestmin: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"PathPaymentStrictSendResultSuccess\", [[\"offers\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"last\", xdr.lookup(\"SimplePaymentResult\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union PathPaymentStrictSendResult switch (PathPaymentStrictSendResultCode code)\n  //   {\n  //   case PATH_PAYMENT_STRICT_SEND_SUCCESS:\n  //       struct\n  //       {\n  //           ClaimOfferAtom offers<>;\n  //           SimplePaymentResult last;\n  //       } success;\n  //   case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:\n  //       Asset noIssuer; // the asset that caused the error\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"PathPaymentStrictSendResult\", {\n    switchOn: xdr.lookup(\"PathPaymentStrictSendResultCode\"),\n    switchName: \"code\",\n    switches: [[\"pathPaymentStrictSendSuccess\", \"success\"], [\"pathPaymentStrictSendNoIssuer\", \"noIssuer\"]],\n    arms: {\n      success: xdr.lookup(\"PathPaymentStrictSendResultSuccess\"),\n      noIssuer: xdr.lookup(\"Asset\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageSellOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_SELL_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_SELL_OFFER_MALFORMED = -1, // generated offer would be invalid\n  //       MANAGE_SELL_OFFER_SELL_NO_TRUST =\n  //           -2,                              // no trust line for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_TRUST = -3, // no trust line for what we're buying\n  //       MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_SELL_OFFER_LINE_FULL = -6, // can't receive more of what it's buying\n  //       MANAGE_SELL_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell\n  //       MANAGE_SELL_OFFER_CROSS_SELF =\n  //           -8, // would cross an offer from the same user\n  //       MANAGE_SELL_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_SELL_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_SELL_OFFER_NOT_FOUND =\n  //           -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_SELL_OFFER_LOW_RESERVE =\n  //           -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageSellOfferResultCode\", {\n    manageSellOfferSuccess: 0,\n    manageSellOfferMalformed: -1,\n    manageSellOfferSellNoTrust: -2,\n    manageSellOfferBuyNoTrust: -3,\n    manageSellOfferSellNotAuthorized: -4,\n    manageSellOfferBuyNotAuthorized: -5,\n    manageSellOfferLineFull: -6,\n    manageSellOfferUnderfunded: -7,\n    manageSellOfferCrossSelf: -8,\n    manageSellOfferSellNoIssuer: -9,\n    manageSellOfferBuyNoIssuer: -10,\n    manageSellOfferNotFound: -11,\n    manageSellOfferLowReserve: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageOfferEffect\n  //   {\n  //       MANAGE_OFFER_CREATED = 0,\n  //       MANAGE_OFFER_UPDATED = 1,\n  //       MANAGE_OFFER_DELETED = 2\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageOfferEffect\", {\n    manageOfferCreated: 0,\n    manageOfferUpdated: 1,\n    manageOfferDeleted: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"ManageOfferSuccessResultOffer\", {\n    switchOn: xdr.lookup(\"ManageOfferEffect\"),\n    switchName: \"effect\",\n    switches: [[\"manageOfferCreated\", \"offer\"], [\"manageOfferUpdated\", \"offer\"]],\n    arms: {\n      offer: xdr.lookup(\"OfferEntry\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct ManageOfferSuccessResult\n  //   {\n  //       // offers that got claimed while creating this offer\n  //       ClaimOfferAtom offersClaimed<>;\n  //   \n  //       union switch (ManageOfferEffect effect)\n  //       {\n  //       case MANAGE_OFFER_CREATED:\n  //       case MANAGE_OFFER_UPDATED:\n  //           OfferEntry offer;\n  //       default:\n  //           void;\n  //       }\n  //       offer;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ManageOfferSuccessResult\", [[\"offersClaimed\", xdr.varArray(xdr.lookup(\"ClaimOfferAtom\"), 2147483647)], [\"offer\", xdr.lookup(\"ManageOfferSuccessResultOffer\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union ManageSellOfferResult switch (ManageSellOfferResultCode code)\n  //   {\n  //   case MANAGE_SELL_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ManageSellOfferResult\", {\n    switchOn: xdr.lookup(\"ManageSellOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageSellOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageBuyOfferResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_BUY_OFFER_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_BUY_OFFER_MALFORMED = -1,     // generated offer would be invalid\n  //       MANAGE_BUY_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying\n  //       MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell\n  //       MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy\n  //       MANAGE_BUY_OFFER_LINE_FULL = -6,   // can't receive more of what it's buying\n  //       MANAGE_BUY_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell\n  //       MANAGE_BUY_OFFER_CROSS_SELF = -8, // would cross an offer from the same user\n  //       MANAGE_BUY_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling\n  //       MANAGE_BUY_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying\n  //   \n  //       // update errors\n  //       MANAGE_BUY_OFFER_NOT_FOUND =\n  //           -11, // offerID does not match an existing offer\n  //   \n  //       MANAGE_BUY_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageBuyOfferResultCode\", {\n    manageBuyOfferSuccess: 0,\n    manageBuyOfferMalformed: -1,\n    manageBuyOfferSellNoTrust: -2,\n    manageBuyOfferBuyNoTrust: -3,\n    manageBuyOfferSellNotAuthorized: -4,\n    manageBuyOfferBuyNotAuthorized: -5,\n    manageBuyOfferLineFull: -6,\n    manageBuyOfferUnderfunded: -7,\n    manageBuyOfferCrossSelf: -8,\n    manageBuyOfferSellNoIssuer: -9,\n    manageBuyOfferBuyNoIssuer: -10,\n    manageBuyOfferNotFound: -11,\n    manageBuyOfferLowReserve: -12\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ManageBuyOfferResult switch (ManageBuyOfferResultCode code)\n  //   {\n  //   case MANAGE_BUY_OFFER_SUCCESS:\n  //       ManageOfferSuccessResult success;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ManageBuyOfferResult\", {\n    switchOn: xdr.lookup(\"ManageBuyOfferResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageBuyOfferSuccess\", \"success\"]],\n    arms: {\n      success: xdr.lookup(\"ManageOfferSuccessResult\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum SetOptionsResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       SET_OPTIONS_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       SET_OPTIONS_LOW_RESERVE = -1,      // not enough funds to add a signer\n  //       SET_OPTIONS_TOO_MANY_SIGNERS = -2, // max number of signers already reached\n  //       SET_OPTIONS_BAD_FLAGS = -3,        // invalid combination of clear/set flags\n  //       SET_OPTIONS_INVALID_INFLATION = -4,      // inflation account does not exist\n  //       SET_OPTIONS_CANT_CHANGE = -5,            // can no longer change this option\n  //       SET_OPTIONS_UNKNOWN_FLAG = -6,           // can't set an unknown flag\n  //       SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = -7, // bad value for weight/threshold\n  //       SET_OPTIONS_BAD_SIGNER = -8,             // signer cannot be masterkey\n  //       SET_OPTIONS_INVALID_HOME_DOMAIN = -9     // malformed home domain\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"SetOptionsResultCode\", {\n    setOptionsSuccess: 0,\n    setOptionsLowReserve: -1,\n    setOptionsTooManySigners: -2,\n    setOptionsBadFlags: -3,\n    setOptionsInvalidInflation: -4,\n    setOptionsCantChange: -5,\n    setOptionsUnknownFlag: -6,\n    setOptionsThresholdOutOfRange: -7,\n    setOptionsBadSigner: -8,\n    setOptionsInvalidHomeDomain: -9\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union SetOptionsResult switch (SetOptionsResultCode code)\n  //   {\n  //   case SET_OPTIONS_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"SetOptionsResult\", {\n    switchOn: xdr.lookup(\"SetOptionsResultCode\"),\n    switchName: \"code\",\n    switches: [[\"setOptionsSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ChangeTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       CHANGE_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       CHANGE_TRUST_MALFORMED = -1,     // bad input\n  //       CHANGE_TRUST_NO_ISSUER = -2,     // could not find issuer\n  //       CHANGE_TRUST_INVALID_LIMIT = -3, // cannot drop limit below balance\n  //                                        // cannot create with a limit of 0\n  //       CHANGE_TRUST_LOW_RESERVE =\n  //           -4, // not enough funds to create a new trust line,\n  //       CHANGE_TRUST_SELF_NOT_ALLOWED = -5 // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ChangeTrustResultCode\", {\n    changeTrustSuccess: 0,\n    changeTrustMalformed: -1,\n    changeTrustNoIssuer: -2,\n    changeTrustInvalidLimit: -3,\n    changeTrustLowReserve: -4,\n    changeTrustSelfNotAllowed: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ChangeTrustResult switch (ChangeTrustResultCode code)\n  //   {\n  //   case CHANGE_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ChangeTrustResult\", {\n    switchOn: xdr.lookup(\"ChangeTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"changeTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum AllowTrustResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ALLOW_TRUST_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ALLOW_TRUST_MALFORMED = -1,     // asset is not ASSET_TYPE_ALPHANUM\n  //       ALLOW_TRUST_NO_TRUST_LINE = -2, // trustor does not have a trustline\n  //                                       // source account does not require trust\n  //       ALLOW_TRUST_TRUST_NOT_REQUIRED = -3,\n  //       ALLOW_TRUST_CANT_REVOKE = -4,     // source account can't revoke trust,\n  //       ALLOW_TRUST_SELF_NOT_ALLOWED = -5 // trusting self is not allowed\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AllowTrustResultCode\", {\n    allowTrustSuccess: 0,\n    allowTrustMalformed: -1,\n    allowTrustNoTrustLine: -2,\n    allowTrustTrustNotRequired: -3,\n    allowTrustCantRevoke: -4,\n    allowTrustSelfNotAllowed: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union AllowTrustResult switch (AllowTrustResultCode code)\n  //   {\n  //   case ALLOW_TRUST_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"AllowTrustResult\", {\n    switchOn: xdr.lookup(\"AllowTrustResultCode\"),\n    switchName: \"code\",\n    switches: [[\"allowTrustSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum AccountMergeResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       ACCOUNT_MERGE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       ACCOUNT_MERGE_MALFORMED = -1,       // can't merge onto itself\n  //       ACCOUNT_MERGE_NO_ACCOUNT = -2,      // destination does not exist\n  //       ACCOUNT_MERGE_IMMUTABLE_SET = -3,   // source account has AUTH_IMMUTABLE set\n  //       ACCOUNT_MERGE_HAS_SUB_ENTRIES = -4, // account has trust lines/offers\n  //       ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed\n  //       ACCOUNT_MERGE_DEST_FULL = -6,       // can't add source balance to\n  //                                           // destination balance\n  //       ACCOUNT_MERGE_IS_SPONSOR = -7       // can't merge account that is a sponsor\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AccountMergeResultCode\", {\n    accountMergeSuccess: 0,\n    accountMergeMalformed: -1,\n    accountMergeNoAccount: -2,\n    accountMergeImmutableSet: -3,\n    accountMergeHasSubEntries: -4,\n    accountMergeSeqnumTooFar: -5,\n    accountMergeDestFull: -6,\n    accountMergeIsSponsor: -7\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union AccountMergeResult switch (AccountMergeResultCode code)\n  //   {\n  //   case ACCOUNT_MERGE_SUCCESS:\n  //       int64 sourceAccountBalance; // how much got transfered from source account\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"AccountMergeResult\", {\n    switchOn: xdr.lookup(\"AccountMergeResultCode\"),\n    switchName: \"code\",\n    switches: [[\"accountMergeSuccess\", \"sourceAccountBalance\"]],\n    arms: {\n      sourceAccountBalance: xdr.lookup(\"Int64\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum InflationResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       INFLATION_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       INFLATION_NOT_TIME = -1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"InflationResultCode\", {\n    inflationSuccess: 0,\n    inflationNotTime: -1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct InflationPayout // or use PaymentResultAtom to limit types?\n  //   {\n  //       AccountID destination;\n  //       int64 amount;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"InflationPayout\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"amount\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union InflationResult switch (InflationResultCode code)\n  //   {\n  //   case INFLATION_SUCCESS:\n  //       InflationPayout payouts<>;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"InflationResult\", {\n    switchOn: xdr.lookup(\"InflationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"inflationSuccess\", \"payouts\"]],\n    arms: {\n      payouts: xdr.varArray(xdr.lookup(\"InflationPayout\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ManageDataResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       MANAGE_DATA_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       MANAGE_DATA_NOT_SUPPORTED_YET =\n  //           -1, // The network hasn't moved to this protocol change yet\n  //       MANAGE_DATA_NAME_NOT_FOUND =\n  //           -2, // Trying to remove a Data Entry that isn't there\n  //       MANAGE_DATA_LOW_RESERVE = -3, // not enough funds to create a new Data Entry\n  //       MANAGE_DATA_INVALID_NAME = -4 // Name not a valid string\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ManageDataResultCode\", {\n    manageDataSuccess: 0,\n    manageDataNotSupportedYet: -1,\n    manageDataNameNotFound: -2,\n    manageDataLowReserve: -3,\n    manageDataInvalidName: -4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ManageDataResult switch (ManageDataResultCode code)\n  //   {\n  //   case MANAGE_DATA_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ManageDataResult\", {\n    switchOn: xdr.lookup(\"ManageDataResultCode\"),\n    switchName: \"code\",\n    switches: [[\"manageDataSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum BumpSequenceResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       BUMP_SEQUENCE_SUCCESS = 0,\n  //       // codes considered as \"failure\" for the operation\n  //       BUMP_SEQUENCE_BAD_SEQ = -1 // `bumpTo` is not within bounds\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"BumpSequenceResultCode\", {\n    bumpSequenceSuccess: 0,\n    bumpSequenceBadSeq: -1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union BumpSequenceResult switch (BumpSequenceResultCode code)\n  //   {\n  //   case BUMP_SEQUENCE_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"BumpSequenceResult\", {\n    switchOn: xdr.lookup(\"BumpSequenceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"bumpSequenceSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum CreateClaimableBalanceResultCode\n  //   {\n  //       CREATE_CLAIMABLE_BALANCE_SUCCESS = 0,\n  //       CREATE_CLAIMABLE_BALANCE_MALFORMED = -1,\n  //       CREATE_CLAIMABLE_BALANCE_LOW_RESERVE = -2,\n  //       CREATE_CLAIMABLE_BALANCE_NO_TRUST = -3,\n  //       CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -4,\n  //       CREATE_CLAIMABLE_BALANCE_UNDERFUNDED = -5\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"CreateClaimableBalanceResultCode\", {\n    createClaimableBalanceSuccess: 0,\n    createClaimableBalanceMalformed: -1,\n    createClaimableBalanceLowReserve: -2,\n    createClaimableBalanceNoTrust: -3,\n    createClaimableBalanceNotAuthorized: -4,\n    createClaimableBalanceUnderfunded: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union CreateClaimableBalanceResult switch (CreateClaimableBalanceResultCode code)\n  //   {\n  //   case CREATE_CLAIMABLE_BALANCE_SUCCESS:\n  //       ClaimableBalanceID balanceID;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"CreateClaimableBalanceResult\", {\n    switchOn: xdr.lookup(\"CreateClaimableBalanceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"createClaimableBalanceSuccess\", \"balanceId\"]],\n    arms: {\n      balanceId: xdr.lookup(\"ClaimableBalanceId\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ClaimClaimableBalanceResultCode\n  //   {\n  //       CLAIM_CLAIMABLE_BALANCE_SUCCESS = 0,\n  //       CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST = -1,\n  //       CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM = -2,\n  //       CLAIM_CLAIMABLE_BALANCE_LINE_FULL = -3,\n  //       CLAIM_CLAIMABLE_BALANCE_NO_TRUST = -4,\n  //       CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -5\n  //   \n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ClaimClaimableBalanceResultCode\", {\n    claimClaimableBalanceSuccess: 0,\n    claimClaimableBalanceDoesNotExist: -1,\n    claimClaimableBalanceCannotClaim: -2,\n    claimClaimableBalanceLineFull: -3,\n    claimClaimableBalanceNoTrust: -4,\n    claimClaimableBalanceNotAuthorized: -5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ClaimClaimableBalanceResult switch (ClaimClaimableBalanceResultCode code)\n  //   {\n  //   case CLAIM_CLAIMABLE_BALANCE_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ClaimClaimableBalanceResult\", {\n    switchOn: xdr.lookup(\"ClaimClaimableBalanceResultCode\"),\n    switchName: \"code\",\n    switches: [[\"claimClaimableBalanceSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum BeginSponsoringFutureReservesResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED = -1,\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED = -2,\n  //       BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE = -3\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"BeginSponsoringFutureReservesResultCode\", {\n    beginSponsoringFutureReservesSuccess: 0,\n    beginSponsoringFutureReservesMalformed: -1,\n    beginSponsoringFutureReservesAlreadySponsored: -2,\n    beginSponsoringFutureReservesRecursive: -3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union BeginSponsoringFutureReservesResult switch (BeginSponsoringFutureReservesResultCode code)\n  //   {\n  //   case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"BeginSponsoringFutureReservesResult\", {\n    switchOn: xdr.lookup(\"BeginSponsoringFutureReservesResultCode\"),\n    switchName: \"code\",\n    switches: [[\"beginSponsoringFutureReservesSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum EndSponsoringFutureReservesResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       END_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED = -1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"EndSponsoringFutureReservesResultCode\", {\n    endSponsoringFutureReservesSuccess: 0,\n    endSponsoringFutureReservesNotSponsored: -1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union EndSponsoringFutureReservesResult switch (EndSponsoringFutureReservesResultCode code)\n  //   {\n  //   case END_SPONSORING_FUTURE_RESERVES_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"EndSponsoringFutureReservesResult\", {\n    switchOn: xdr.lookup(\"EndSponsoringFutureReservesResultCode\"),\n    switchName: \"code\",\n    switches: [[\"endSponsoringFutureReservesSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum RevokeSponsorshipResultCode\n  //   {\n  //       // codes considered as \"success\" for the operation\n  //       REVOKE_SPONSORSHIP_SUCCESS = 0,\n  //   \n  //       // codes considered as \"failure\" for the operation\n  //       REVOKE_SPONSORSHIP_DOES_NOT_EXIST = -1,\n  //       REVOKE_SPONSORSHIP_NOT_SPONSOR = -2,\n  //       REVOKE_SPONSORSHIP_LOW_RESERVE = -3,\n  //       REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE = -4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"RevokeSponsorshipResultCode\", {\n    revokeSponsorshipSuccess: 0,\n    revokeSponsorshipDoesNotExist: -1,\n    revokeSponsorshipNotSponsor: -2,\n    revokeSponsorshipLowReserve: -3,\n    revokeSponsorshipOnlyTransferable: -4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union RevokeSponsorshipResult switch (RevokeSponsorshipResultCode code)\n  //   {\n  //   case REVOKE_SPONSORSHIP_SUCCESS:\n  //       void;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"RevokeSponsorshipResult\", {\n    switchOn: xdr.lookup(\"RevokeSponsorshipResultCode\"),\n    switchName: \"code\",\n    switches: [[\"revokeSponsorshipSuccess\", xdr.void()]],\n    arms: {},\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum OperationResultCode\n  //   {\n  //       opINNER = 0, // inner object result is valid\n  //   \n  //       opBAD_AUTH = -1,            // too few valid signatures / wrong network\n  //       opNO_ACCOUNT = -2,          // source account was not found\n  //       opNOT_SUPPORTED = -3,       // operation not supported at this time\n  //       opTOO_MANY_SUBENTRIES = -4, // max number of subentries already reached\n  //       opEXCEEDED_WORK_LIMIT = -5, // operation did too much work\n  //       opTOO_MANY_SPONSORING = -6  // account is sponsoring too many entries\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"OperationResultCode\", {\n    opInner: 0,\n    opBadAuth: -1,\n    opNoAccount: -2,\n    opNotSupported: -3,\n    opTooManySubentries: -4,\n    opExceededWorkLimit: -5,\n    opTooManySponsoring: -6\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferResult manageBuyOfferResult;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendResult pathPaymentStrictSendResult;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceResult createClaimableBalanceResult;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceResult claimClaimableBalanceResult;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipResult revokeSponsorshipResult;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"OperationResultTr\", {\n    switchOn: xdr.lookup(\"OperationType\"),\n    switchName: \"type\",\n    switches: [[\"createAccount\", \"createAccountResult\"], [\"payment\", \"paymentResult\"], [\"pathPaymentStrictReceive\", \"pathPaymentStrictReceiveResult\"], [\"manageSellOffer\", \"manageSellOfferResult\"], [\"createPassiveSellOffer\", \"createPassiveSellOfferResult\"], [\"setOptions\", \"setOptionsResult\"], [\"changeTrust\", \"changeTrustResult\"], [\"allowTrust\", \"allowTrustResult\"], [\"accountMerge\", \"accountMergeResult\"], [\"inflation\", \"inflationResult\"], [\"manageData\", \"manageDataResult\"], [\"bumpSequence\", \"bumpSeqResult\"], [\"manageBuyOffer\", \"manageBuyOfferResult\"], [\"pathPaymentStrictSend\", \"pathPaymentStrictSendResult\"], [\"createClaimableBalance\", \"createClaimableBalanceResult\"], [\"claimClaimableBalance\", \"claimClaimableBalanceResult\"], [\"beginSponsoringFutureReserves\", \"beginSponsoringFutureReservesResult\"], [\"endSponsoringFutureReserves\", \"endSponsoringFutureReservesResult\"], [\"revokeSponsorship\", \"revokeSponsorshipResult\"]],\n    arms: {\n      createAccountResult: xdr.lookup(\"CreateAccountResult\"),\n      paymentResult: xdr.lookup(\"PaymentResult\"),\n      pathPaymentStrictReceiveResult: xdr.lookup(\"PathPaymentStrictReceiveResult\"),\n      manageSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      createPassiveSellOfferResult: xdr.lookup(\"ManageSellOfferResult\"),\n      setOptionsResult: xdr.lookup(\"SetOptionsResult\"),\n      changeTrustResult: xdr.lookup(\"ChangeTrustResult\"),\n      allowTrustResult: xdr.lookup(\"AllowTrustResult\"),\n      accountMergeResult: xdr.lookup(\"AccountMergeResult\"),\n      inflationResult: xdr.lookup(\"InflationResult\"),\n      manageDataResult: xdr.lookup(\"ManageDataResult\"),\n      bumpSeqResult: xdr.lookup(\"BumpSequenceResult\"),\n      manageBuyOfferResult: xdr.lookup(\"ManageBuyOfferResult\"),\n      pathPaymentStrictSendResult: xdr.lookup(\"PathPaymentStrictSendResult\"),\n      createClaimableBalanceResult: xdr.lookup(\"CreateClaimableBalanceResult\"),\n      claimClaimableBalanceResult: xdr.lookup(\"ClaimClaimableBalanceResult\"),\n      beginSponsoringFutureReservesResult: xdr.lookup(\"BeginSponsoringFutureReservesResult\"),\n      endSponsoringFutureReservesResult: xdr.lookup(\"EndSponsoringFutureReservesResult\"),\n      revokeSponsorshipResult: xdr.lookup(\"RevokeSponsorshipResult\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union OperationResult switch (OperationResultCode code)\n  //   {\n  //   case opINNER:\n  //       union switch (OperationType type)\n  //       {\n  //       case CREATE_ACCOUNT:\n  //           CreateAccountResult createAccountResult;\n  //       case PAYMENT:\n  //           PaymentResult paymentResult;\n  //       case PATH_PAYMENT_STRICT_RECEIVE:\n  //           PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;\n  //       case MANAGE_SELL_OFFER:\n  //           ManageSellOfferResult manageSellOfferResult;\n  //       case CREATE_PASSIVE_SELL_OFFER:\n  //           ManageSellOfferResult createPassiveSellOfferResult;\n  //       case SET_OPTIONS:\n  //           SetOptionsResult setOptionsResult;\n  //       case CHANGE_TRUST:\n  //           ChangeTrustResult changeTrustResult;\n  //       case ALLOW_TRUST:\n  //           AllowTrustResult allowTrustResult;\n  //       case ACCOUNT_MERGE:\n  //           AccountMergeResult accountMergeResult;\n  //       case INFLATION:\n  //           InflationResult inflationResult;\n  //       case MANAGE_DATA:\n  //           ManageDataResult manageDataResult;\n  //       case BUMP_SEQUENCE:\n  //           BumpSequenceResult bumpSeqResult;\n  //       case MANAGE_BUY_OFFER:\n  //           ManageBuyOfferResult manageBuyOfferResult;\n  //       case PATH_PAYMENT_STRICT_SEND:\n  //           PathPaymentStrictSendResult pathPaymentStrictSendResult;\n  //       case CREATE_CLAIMABLE_BALANCE:\n  //           CreateClaimableBalanceResult createClaimableBalanceResult;\n  //       case CLAIM_CLAIMABLE_BALANCE:\n  //           ClaimClaimableBalanceResult claimClaimableBalanceResult;\n  //       case BEGIN_SPONSORING_FUTURE_RESERVES:\n  //           BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;\n  //       case END_SPONSORING_FUTURE_RESERVES:\n  //           EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;\n  //       case REVOKE_SPONSORSHIP:\n  //           RevokeSponsorshipResult revokeSponsorshipResult;\n  //       }\n  //       tr;\n  //   default:\n  //       void;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"OperationResult\", {\n    switchOn: xdr.lookup(\"OperationResultCode\"),\n    switchName: \"code\",\n    switches: [[\"opInner\", \"tr\"]],\n    arms: {\n      tr: xdr.lookup(\"OperationResultTr\")\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum TransactionResultCode\n  //   {\n  //       txFEE_BUMP_INNER_SUCCESS = 1, // fee bump inner transaction succeeded\n  //       txSUCCESS = 0,                // all operations succeeded\n  //   \n  //       txFAILED = -1, // one of the operations failed (none were applied)\n  //   \n  //       txTOO_EARLY = -2,         // ledger closeTime before minTime\n  //       txTOO_LATE = -3,          // ledger closeTime after maxTime\n  //       txMISSING_OPERATION = -4, // no operation was specified\n  //       txBAD_SEQ = -5,           // sequence number does not match source account\n  //   \n  //       txBAD_AUTH = -6,             // too few valid signatures / wrong network\n  //       txINSUFFICIENT_BALANCE = -7, // fee would bring account below reserve\n  //       txNO_ACCOUNT = -8,           // source account not found\n  //       txINSUFFICIENT_FEE = -9,     // fee is too small\n  //       txBAD_AUTH_EXTRA = -10,      // unused signatures attached to transaction\n  //       txINTERNAL_ERROR = -11,      // an unknown error occured\n  //   \n  //       txNOT_SUPPORTED = -12,         // transaction type not supported\n  //       txFEE_BUMP_INNER_FAILED = -13, // fee bump inner transaction failed\n  //       txBAD_SPONSORSHIP = -14        // sponsorship not confirmed\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"TransactionResultCode\", {\n    txFeeBumpInnerSuccess: 1,\n    txSuccess: 0,\n    txFailed: -1,\n    txTooEarly: -2,\n    txTooLate: -3,\n    txMissingOperation: -4,\n    txBadSeq: -5,\n    txBadAuth: -6,\n    txInsufficientBalance: -7,\n    txNoAccount: -8,\n    txInsufficientFee: -9,\n    txBadAuthExtra: -10,\n    txInternalError: -11,\n    txNotSupported: -12,\n    txFeeBumpInnerFailed: -13,\n    txBadSponsorship: -14\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (TransactionResultCode code)\n  //       {\n  //       // txFEE_BUMP_INNER_SUCCESS is not included\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       case txTOO_EARLY:\n  //       case txTOO_LATE:\n  //       case txMISSING_OPERATION:\n  //       case txBAD_SEQ:\n  //       case txBAD_AUTH:\n  //       case txINSUFFICIENT_BALANCE:\n  //       case txNO_ACCOUNT:\n  //       case txINSUFFICIENT_FEE:\n  //       case txBAD_AUTH_EXTRA:\n  //       case txINTERNAL_ERROR:\n  //       case txNOT_SUPPORTED:\n  //       // txFEE_BUMP_INNER_FAILED is not included\n  //       case txBAD_SPONSORSHIP:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"InnerTransactionResultResult\", {\n    switchOn: xdr.lookup(\"TransactionResultCode\"),\n    switchName: \"code\",\n    switches: [[\"txSuccess\", \"results\"], [\"txFailed\", \"results\"], [\"txTooEarly\", xdr.void()], [\"txTooLate\", xdr.void()], [\"txMissingOperation\", xdr.void()], [\"txBadSeq\", xdr.void()], [\"txBadAuth\", xdr.void()], [\"txInsufficientBalance\", xdr.void()], [\"txNoAccount\", xdr.void()], [\"txInsufficientFee\", xdr.void()], [\"txBadAuthExtra\", xdr.void()], [\"txInternalError\", xdr.void()], [\"txNotSupported\", xdr.void()], [\"txBadSponsorship\", xdr.void()]],\n    arms: {\n      results: xdr.varArray(xdr.lookup(\"OperationResult\"), 2147483647)\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"InnerTransactionResultExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct InnerTransactionResult\n  //   {\n  //       // Always 0. Here for binary compatibility.\n  //       int64 feeCharged;\n  //   \n  //       union switch (TransactionResultCode code)\n  //       {\n  //       // txFEE_BUMP_INNER_SUCCESS is not included\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       case txTOO_EARLY:\n  //       case txTOO_LATE:\n  //       case txMISSING_OPERATION:\n  //       case txBAD_SEQ:\n  //       case txBAD_AUTH:\n  //       case txINSUFFICIENT_BALANCE:\n  //       case txNO_ACCOUNT:\n  //       case txINSUFFICIENT_FEE:\n  //       case txBAD_AUTH_EXTRA:\n  //       case txINTERNAL_ERROR:\n  //       case txNOT_SUPPORTED:\n  //       // txFEE_BUMP_INNER_FAILED is not included\n  //       case txBAD_SPONSORSHIP:\n  //           void;\n  //       }\n  //       result;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"InnerTransactionResult\", [[\"feeCharged\", xdr.lookup(\"Int64\")], [\"result\", xdr.lookup(\"InnerTransactionResultResult\")], [\"ext\", xdr.lookup(\"InnerTransactionResultExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct InnerTransactionResultPair\n  //   {\n  //       Hash transactionHash;          // hash of the inner transaction\n  //       InnerTransactionResult result; // result for the inner transaction\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"InnerTransactionResultPair\", [[\"transactionHash\", xdr.lookup(\"Hash\")], [\"result\", xdr.lookup(\"InnerTransactionResult\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (TransactionResultCode code)\n  //       {\n  //       case txFEE_BUMP_INNER_SUCCESS:\n  //       case txFEE_BUMP_INNER_FAILED:\n  //           InnerTransactionResultPair innerResultPair;\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionResultResult\", {\n    switchOn: xdr.lookup(\"TransactionResultCode\"),\n    switchName: \"code\",\n    switches: [[\"txFeeBumpInnerSuccess\", \"innerResultPair\"], [\"txFeeBumpInnerFailed\", \"innerResultPair\"], [\"txSuccess\", \"results\"], [\"txFailed\", \"results\"]],\n    arms: {\n      innerResultPair: xdr.lookup(\"InnerTransactionResultPair\"),\n      results: xdr.varArray(xdr.lookup(\"OperationResult\"), 2147483647)\n    },\n    defaultArm: xdr.void()\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionResultExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResult\n  //   {\n  //       int64 feeCharged; // actual fee charged for the transaction\n  //   \n  //       union switch (TransactionResultCode code)\n  //       {\n  //       case txFEE_BUMP_INNER_SUCCESS:\n  //       case txFEE_BUMP_INNER_FAILED:\n  //           InnerTransactionResultPair innerResultPair;\n  //       case txSUCCESS:\n  //       case txFAILED:\n  //           OperationResult results<>;\n  //       default:\n  //           void;\n  //       }\n  //       result;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResult\", [[\"feeCharged\", xdr.lookup(\"Int64\")], [\"result\", xdr.lookup(\"TransactionResultResult\")], [\"ext\", xdr.lookup(\"TransactionResultExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Value<>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"Value\", xdr.varOpaque());\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPBallot\n  //   {\n  //       uint32 counter; // n\n  //       Value value;    // x\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpBallot\", [[\"counter\", xdr.lookup(\"Uint32\")], [\"value\", xdr.lookup(\"Value\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum SCPStatementType\n  //   {\n  //       SCP_ST_PREPARE = 0,\n  //       SCP_ST_CONFIRM = 1,\n  //       SCP_ST_EXTERNALIZE = 2,\n  //       SCP_ST_NOMINATE = 3\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ScpStatementType\", {\n    scpStPrepare: 0,\n    scpStConfirm: 1,\n    scpStExternalize: 2,\n    scpStNominate: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPNomination\n  //   {\n  //       Hash quorumSetHash; // D\n  //       Value votes<>;      // X\n  //       Value accepted<>;   // Y\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpNomination\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"votes\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)], [\"accepted\", xdr.varArray(xdr.lookup(\"Value\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatementPrepare\", [[\"quorumSetHash\", xdr.lookup(\"Hash\")], [\"ballot\", xdr.lookup(\"ScpBallot\")], [\"prepared\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"preparedPrime\", xdr.option(xdr.lookup(\"ScpBallot\"))], [\"nC\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatementConfirm\", [[\"ballot\", xdr.lookup(\"ScpBallot\")], [\"nPrepared\", xdr.lookup(\"Uint32\")], [\"nCommit\", xdr.lookup(\"Uint32\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"quorumSetHash\", xdr.lookup(\"Hash\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatementExternalize\", [[\"commit\", xdr.lookup(\"ScpBallot\")], [\"nH\", xdr.lookup(\"Uint32\")], [\"commitQuorumSetHash\", xdr.lookup(\"Hash\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"ScpStatementPledges\", {\n    switchOn: xdr.lookup(\"ScpStatementType\"),\n    switchName: \"type\",\n    switches: [[\"scpStPrepare\", \"prepare\"], [\"scpStConfirm\", \"confirm\"], [\"scpStExternalize\", \"externalize\"], [\"scpStNominate\", \"nominate\"]],\n    arms: {\n      prepare: xdr.lookup(\"ScpStatementPrepare\"),\n      confirm: xdr.lookup(\"ScpStatementConfirm\"),\n      externalize: xdr.lookup(\"ScpStatementExternalize\"),\n      nominate: xdr.lookup(\"ScpNomination\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPStatement\n  //   {\n  //       NodeID nodeID;    // v\n  //       uint64 slotIndex; // i\n  //   \n  //       union switch (SCPStatementType type)\n  //       {\n  //       case SCP_ST_PREPARE:\n  //           struct\n  //           {\n  //               Hash quorumSetHash;       // D\n  //               SCPBallot ballot;         // b\n  //               SCPBallot* prepared;      // p\n  //               SCPBallot* preparedPrime; // p'\n  //               uint32 nC;                // c.n\n  //               uint32 nH;                // h.n\n  //           } prepare;\n  //       case SCP_ST_CONFIRM:\n  //           struct\n  //           {\n  //               SCPBallot ballot;   // b\n  //               uint32 nPrepared;   // p.n\n  //               uint32 nCommit;     // c.n\n  //               uint32 nH;          // h.n\n  //               Hash quorumSetHash; // D\n  //           } confirm;\n  //       case SCP_ST_EXTERNALIZE:\n  //           struct\n  //           {\n  //               SCPBallot commit;         // c\n  //               uint32 nH;                // h.n\n  //               Hash commitQuorumSetHash; // D used before EXTERNALIZE\n  //           } externalize;\n  //       case SCP_ST_NOMINATE:\n  //           SCPNomination nominate;\n  //       }\n  //       pledges;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpStatement\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"slotIndex\", xdr.lookup(\"Uint64\")], [\"pledges\", xdr.lookup(\"ScpStatementPledges\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPEnvelope\n  //   {\n  //       SCPStatement statement;\n  //       Signature signature;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpEnvelope\", [[\"statement\", xdr.lookup(\"ScpStatement\")], [\"signature\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPQuorumSet\n  //   {\n  //       uint32 threshold;\n  //       PublicKey validators<>;\n  //       SCPQuorumSet innerSets<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpQuorumSet\", [[\"threshold\", xdr.lookup(\"Uint32\")], [\"validators\", xdr.varArray(xdr.lookup(\"PublicKey\"), 2147483647)], [\"innerSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   typedef PublicKey AccountID;\n  //\n  // ===========================================================================\n  xdr.typedef(\"AccountId\", xdr.lookup(\"PublicKey\"));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque Thresholds[4];\n  //\n  // ===========================================================================\n  xdr.typedef(\"Thresholds\", xdr.opaque(4));\n\n  // === xdr source ============================================================\n  //\n  //   typedef string string32<32>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"String32\", xdr.string(32));\n\n  // === xdr source ============================================================\n  //\n  //   typedef string string64<64>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"String64\", xdr.string(64));\n\n  // === xdr source ============================================================\n  //\n  //   typedef int64 SequenceNumber;\n  //\n  // ===========================================================================\n  xdr.typedef(\"SequenceNumber\", xdr.lookup(\"Int64\"));\n\n  // === xdr source ============================================================\n  //\n  //   typedef uint64 TimePoint;\n  //\n  // ===========================================================================\n  xdr.typedef(\"TimePoint\", xdr.lookup(\"Uint64\"));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque DataValue<64>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"DataValue\", xdr.varOpaque(64));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode4[4];\n  //\n  // ===========================================================================\n  xdr.typedef(\"AssetCode4\", xdr.opaque(4));\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque AssetCode12[12];\n  //\n  // ===========================================================================\n  xdr.typedef(\"AssetCode12\", xdr.opaque(12));\n\n  // === xdr source ============================================================\n  //\n  //   enum AssetType\n  //   {\n  //       ASSET_TYPE_NATIVE = 0,\n  //       ASSET_TYPE_CREDIT_ALPHANUM4 = 1,\n  //       ASSET_TYPE_CREDIT_ALPHANUM12 = 2\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AssetType\", {\n    assetTypeNative: 0,\n    assetTypeCreditAlphanum4: 1,\n    assetTypeCreditAlphanum12: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"AssetAlphaNum4\", [[\"assetCode\", xdr.lookup(\"AssetCode4\")], [\"issuer\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"AssetAlphaNum12\", [[\"assetCode\", xdr.lookup(\"AssetCode12\")], [\"issuer\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union Asset switch (AssetType type)\n  //   {\n  //   case ASSET_TYPE_NATIVE: // Not credit\n  //       void;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM4:\n  //       struct\n  //       {\n  //           AssetCode4 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum4;\n  //   \n  //   case ASSET_TYPE_CREDIT_ALPHANUM12:\n  //       struct\n  //       {\n  //           AssetCode12 assetCode;\n  //           AccountID issuer;\n  //       } alphaNum12;\n  //   \n  //       // add other asset types here in the future\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"Asset\", {\n    switchOn: xdr.lookup(\"AssetType\"),\n    switchName: \"type\",\n    switches: [[\"assetTypeNative\", xdr.void()], [\"assetTypeCreditAlphanum4\", \"alphaNum4\"], [\"assetTypeCreditAlphanum12\", \"alphaNum12\"]],\n    arms: {\n      alphaNum4: xdr.lookup(\"AssetAlphaNum4\"),\n      alphaNum12: xdr.lookup(\"AssetAlphaNum12\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Price\n  //   {\n  //       int32 n; // numerator\n  //       int32 d; // denominator\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Price\", [[\"n\", xdr.lookup(\"Int32\")], [\"d\", xdr.lookup(\"Int32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct Liabilities\n  //   {\n  //       int64 buying;\n  //       int64 selling;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Liabilities\", [[\"buying\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum ThresholdIndexes\n  //   {\n  //       THRESHOLD_MASTER_WEIGHT = 0,\n  //       THRESHOLD_LOW = 1,\n  //       THRESHOLD_MED = 2,\n  //       THRESHOLD_HIGH = 3\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ThresholdIndices\", {\n    thresholdMasterWeight: 0,\n    thresholdLow: 1,\n    thresholdMed: 2,\n    thresholdHigh: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum LedgerEntryType\n  //   {\n  //       ACCOUNT = 0,\n  //       TRUSTLINE = 1,\n  //       OFFER = 2,\n  //       DATA = 3,\n  //       CLAIMABLE_BALANCE = 4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"LedgerEntryType\", {\n    account: 0,\n    trustline: 1,\n    offer: 2,\n    data: 3,\n    claimableBalance: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct Signer\n  //   {\n  //       SignerKey key;\n  //       uint32 weight; // really only need 1 byte\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"Signer\", [[\"key\", xdr.lookup(\"SignerKey\")], [\"weight\", xdr.lookup(\"Uint32\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum AccountFlags\n  //   { // masks for each flag\n  //   \n  //       // Flags set on issuer accounts\n  //       // TrustLines are created with authorized set to \"false\" requiring\n  //       // the issuer to set it for each TrustLine\n  //       AUTH_REQUIRED_FLAG = 0x1,\n  //       // If set, the authorized flag in TrustLines can be cleared\n  //       // otherwise, authorization cannot be revoked\n  //       AUTH_REVOCABLE_FLAG = 0x2,\n  //       // Once set, causes all AUTH_* flags to be read-only\n  //       AUTH_IMMUTABLE_FLAG = 0x4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"AccountFlags\", {\n    authRequiredFlag: 1,\n    authRevocableFlag: 2,\n    authImmutableFlag: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_ACCOUNT_FLAGS = 0x7;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_ACCOUNT_FLAGS\", 0x7);\n\n  // === xdr source ============================================================\n  //\n  //   const MAX_SIGNERS = 20;\n  //\n  // ===========================================================================\n  xdr.const(\"MAX_SIGNERS\", 20);\n\n  // === xdr source ============================================================\n  //\n  //   typedef AccountID* SponsorshipDescriptor;\n  //\n  // ===========================================================================\n  xdr.typedef(\"SponsorshipDescriptor\", xdr.option(xdr.lookup(\"AccountId\")));\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"AccountEntryExtensionV2Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct AccountEntryExtensionV2\n  //   {\n  //       uint32 numSponsored;\n  //       uint32 numSponsoring;\n  //       SponsorshipDescriptor signerSponsoringIDs<MAX_SIGNERS>;\n  //   \n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AccountEntryExtensionV2\", [[\"numSponsored\", xdr.lookup(\"Uint32\")], [\"numSponsoring\", xdr.lookup(\"Uint32\")], [\"signerSponsoringIDs\", xdr.varArray(xdr.lookup(\"SponsorshipDescriptor\"), xdr.lookup(\"MAX_SIGNERS\"))], [\"ext\", xdr.lookup(\"AccountEntryExtensionV2Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 2:\n  //           AccountEntryExtensionV2 v2;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"AccountEntryExtensionV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [2, \"v2\"]],\n    arms: {\n      v2: xdr.lookup(\"AccountEntryExtensionV2\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct AccountEntryExtensionV1\n  //   {\n  //       Liabilities liabilities;\n  //   \n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 2:\n  //           AccountEntryExtensionV2 v2;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AccountEntryExtensionV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"AccountEntryExtensionV1Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           AccountEntryExtensionV1 v1;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"AccountEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"AccountEntryExtensionV1\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct AccountEntry\n  //   {\n  //       AccountID accountID;      // master public key for this account\n  //       int64 balance;            // in stroops\n  //       SequenceNumber seqNum;    // last sequence number used for this account\n  //       uint32 numSubEntries;     // number of sub-entries this account has\n  //                                 // drives the reserve\n  //       AccountID* inflationDest; // Account to vote for during inflation\n  //       uint32 flags;             // see AccountFlags\n  //   \n  //       string32 homeDomain; // can be used for reverse federation and memo lookup\n  //   \n  //       // fields used for signatures\n  //       // thresholds stores unsigned bytes: [weight of master|low|medium|high]\n  //       Thresholds thresholds;\n  //   \n  //       Signer signers<MAX_SIGNERS>; // possible signers for this account\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           AccountEntryExtensionV1 v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"AccountEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"balance\", xdr.lookup(\"Int64\")], [\"seqNum\", xdr.lookup(\"SequenceNumber\")], [\"numSubEntries\", xdr.lookup(\"Uint32\")], [\"inflationDest\", xdr.option(xdr.lookup(\"AccountId\"))], [\"flags\", xdr.lookup(\"Uint32\")], [\"homeDomain\", xdr.lookup(\"String32\")], [\"thresholds\", xdr.lookup(\"Thresholds\")], [\"signers\", xdr.varArray(xdr.lookup(\"Signer\"), xdr.lookup(\"MAX_SIGNERS\"))], [\"ext\", xdr.lookup(\"AccountEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum TrustLineFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       AUTHORIZED_FLAG = 1,\n  //       // issuer has authorized account to maintain and reduce liabilities for its\n  //       // credit\n  //       AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG = 2\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"TrustLineFlags\", {\n    authorizedFlag: 1,\n    authorizedToMaintainLiabilitiesFlag: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_TRUSTLINE_FLAGS = 1;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_TRUSTLINE_FLAGS\", 1);\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_TRUSTLINE_FLAGS_V13 = 3;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_TRUSTLINE_FLAGS_V13\", 3);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //\n  // ===========================================================================\n  xdr.union(\"TrustLineEntryV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           }\n  //\n  // ===========================================================================\n  xdr.struct(\"TrustLineEntryV1\", [[\"liabilities\", xdr.lookup(\"Liabilities\")], [\"ext\", xdr.lookup(\"TrustLineEntryV1Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TrustLineEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"TrustLineEntryV1\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TrustLineEntry\n  //   {\n  //       AccountID accountID; // account this trustline belongs to\n  //       Asset asset;         // type of asset (with issuer)\n  //       int64 balance;       // how much of this asset the user has.\n  //                            // Asset defines the unit for this;\n  //   \n  //       int64 limit;  // balance cannot be above this\n  //       uint32 flags; // see TrustLineFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           struct\n  //           {\n  //               Liabilities liabilities;\n  //   \n  //               union switch (int v)\n  //               {\n  //               case 0:\n  //                   void;\n  //               }\n  //               ext;\n  //           } v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TrustLineEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")], [\"balance\", xdr.lookup(\"Int64\")], [\"limit\", xdr.lookup(\"Int64\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"TrustLineEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum OfferEntryFlags\n  //   {\n  //       // issuer has authorized account to perform transactions with its credit\n  //       PASSIVE_FLAG = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"OfferEntryFlags\", {\n    passiveFlag: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   const MASK_OFFERENTRY_FLAGS = 1;\n  //\n  // ===========================================================================\n  xdr.const(\"MASK_OFFERENTRY_FLAGS\", 1);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"OfferEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct OfferEntry\n  //   {\n  //       AccountID sellerID;\n  //       int64 offerID;\n  //       Asset selling; // A\n  //       Asset buying;  // B\n  //       int64 amount;  // amount of A\n  //   \n  //       /* price for this offer:\n  //           price of A in terms of B\n  //           price=AmountB/AmountA=priceNumerator/priceDenominator\n  //           price is after fees\n  //       */\n  //       Price price;\n  //       uint32 flags; // see OfferEntryFlags\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"OfferEntry\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")], [\"selling\", xdr.lookup(\"Asset\")], [\"buying\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"price\", xdr.lookup(\"Price\")], [\"flags\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"OfferEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"DataEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct DataEntry\n  //   {\n  //       AccountID accountID; // account this data belongs to\n  //       string64 dataName;\n  //       DataValue dataValue;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"DataEntry\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")], [\"dataValue\", xdr.lookup(\"DataValue\")], [\"ext\", xdr.lookup(\"DataEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum ClaimPredicateType\n  //   {\n  //       CLAIM_PREDICATE_UNCONDITIONAL = 0,\n  //       CLAIM_PREDICATE_AND = 1,\n  //       CLAIM_PREDICATE_OR = 2,\n  //       CLAIM_PREDICATE_NOT = 3,\n  //       CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME = 4,\n  //       CLAIM_PREDICATE_BEFORE_RELATIVE_TIME = 5\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ClaimPredicateType\", {\n    claimPredicateUnconditional: 0,\n    claimPredicateAnd: 1,\n    claimPredicateOr: 2,\n    claimPredicateNot: 3,\n    claimPredicateBeforeAbsoluteTime: 4,\n    claimPredicateBeforeRelativeTime: 5\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ClaimPredicate switch (ClaimPredicateType type)\n  //   {\n  //   case CLAIM_PREDICATE_UNCONDITIONAL:\n  //       void;\n  //   case CLAIM_PREDICATE_AND:\n  //       ClaimPredicate andPredicates<2>;\n  //   case CLAIM_PREDICATE_OR:\n  //       ClaimPredicate orPredicates<2>;\n  //   case CLAIM_PREDICATE_NOT:\n  //       ClaimPredicate* notPredicate;\n  //   case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:\n  //       int64 absBefore; // Predicate will be true if closeTime < absBefore\n  //   case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:\n  //       int64 relBefore; // Seconds since closeTime of the ledger in which the\n  //                        // ClaimableBalanceEntry was created\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ClaimPredicate\", {\n    switchOn: xdr.lookup(\"ClaimPredicateType\"),\n    switchName: \"type\",\n    switches: [[\"claimPredicateUnconditional\", xdr.void()], [\"claimPredicateAnd\", \"andPredicates\"], [\"claimPredicateOr\", \"orPredicates\"], [\"claimPredicateNot\", \"notPredicate\"], [\"claimPredicateBeforeAbsoluteTime\", \"absBefore\"], [\"claimPredicateBeforeRelativeTime\", \"relBefore\"]],\n    arms: {\n      andPredicates: xdr.varArray(xdr.lookup(\"ClaimPredicate\"), 2),\n      orPredicates: xdr.varArray(xdr.lookup(\"ClaimPredicate\"), 2),\n      notPredicate: xdr.option(xdr.lookup(\"ClaimPredicate\")),\n      absBefore: xdr.lookup(\"Int64\"),\n      relBefore: xdr.lookup(\"Int64\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ClaimantType\n  //   {\n  //       CLAIMANT_TYPE_V0 = 0\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ClaimantType\", {\n    claimantTypeV0: 0\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID destination;    // The account that can use this condition\n  //           ClaimPredicate predicate; // Claimable if predicate is true\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"ClaimantV0\", [[\"destination\", xdr.lookup(\"AccountId\")], [\"predicate\", xdr.lookup(\"ClaimPredicate\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union Claimant switch (ClaimantType type)\n  //   {\n  //   case CLAIMANT_TYPE_V0:\n  //       struct\n  //       {\n  //           AccountID destination;    // The account that can use this condition\n  //           ClaimPredicate predicate; // Claimable if predicate is true\n  //       } v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"Claimant\", {\n    switchOn: xdr.lookup(\"ClaimantType\"),\n    switchName: \"type\",\n    switches: [[\"claimantTypeV0\", \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"ClaimantV0\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum ClaimableBalanceIDType\n  //   {\n  //       CLAIMABLE_BALANCE_ID_TYPE_V0 = 0\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"ClaimableBalanceIdType\", {\n    claimableBalanceIdTypeV0: 0\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union ClaimableBalanceID switch (ClaimableBalanceIDType type)\n  //   {\n  //   case CLAIMABLE_BALANCE_ID_TYPE_V0:\n  //       Hash v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ClaimableBalanceId\", {\n    switchOn: xdr.lookup(\"ClaimableBalanceIdType\"),\n    switchName: \"type\",\n    switches: [[\"claimableBalanceIdTypeV0\", \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"Hash\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"ClaimableBalanceEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct ClaimableBalanceEntry\n  //   {\n  //       // Unique identifier for this ClaimableBalanceEntry\n  //       ClaimableBalanceID balanceID;\n  //   \n  //       // List of claimants with associated predicate\n  //       Claimant claimants<10>;\n  //   \n  //       // Any asset including native\n  //       Asset asset;\n  //   \n  //       // Amount of asset\n  //       int64 amount;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ClaimableBalanceEntry\", [[\"balanceId\", xdr.lookup(\"ClaimableBalanceId\")], [\"claimants\", xdr.varArray(xdr.lookup(\"Claimant\"), 10)], [\"asset\", xdr.lookup(\"Asset\")], [\"amount\", xdr.lookup(\"Int64\")], [\"ext\", xdr.lookup(\"ClaimableBalanceEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryExtensionV1Ext\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerEntryExtensionV1\n  //   {\n  //       SponsorshipDescriptor sponsoringID;\n  //   \n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerEntryExtensionV1\", [[\"sponsoringId\", xdr.lookup(\"SponsorshipDescriptor\")], [\"ext\", xdr.lookup(\"LedgerEntryExtensionV1Ext\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       case CLAIMABLE_BALANCE:\n  //           ClaimableBalanceEntry claimableBalance;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryData\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"data\", \"data\"], [\"claimableBalance\", \"claimableBalance\"]],\n    arms: {\n      account: xdr.lookup(\"AccountEntry\"),\n      trustLine: xdr.lookup(\"TrustLineEntry\"),\n      offer: xdr.lookup(\"OfferEntry\"),\n      data: xdr.lookup(\"DataEntry\"),\n      claimableBalance: xdr.lookup(\"ClaimableBalanceEntry\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           LedgerEntryExtensionV1 v1;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()], [1, \"v1\"]],\n    arms: {\n      v1: xdr.lookup(\"LedgerEntryExtensionV1\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerEntry\n  //   {\n  //       uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed\n  //   \n  //       union switch (LedgerEntryType type)\n  //       {\n  //       case ACCOUNT:\n  //           AccountEntry account;\n  //       case TRUSTLINE:\n  //           TrustLineEntry trustLine;\n  //       case OFFER:\n  //           OfferEntry offer;\n  //       case DATA:\n  //           DataEntry data;\n  //       case CLAIMABLE_BALANCE:\n  //           ClaimableBalanceEntry claimableBalance;\n  //       }\n  //       data;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       case 1:\n  //           LedgerEntryExtensionV1 v1;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerEntry\", [[\"lastModifiedLedgerSeq\", xdr.lookup(\"Uint32\")], [\"data\", xdr.lookup(\"LedgerEntryData\")], [\"ext\", xdr.lookup(\"LedgerEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyAccount\", [[\"accountId\", xdr.lookup(\"AccountId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyTrustLine\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"asset\", xdr.lookup(\"Asset\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyOffer\", [[\"sellerId\", xdr.lookup(\"AccountId\")], [\"offerId\", xdr.lookup(\"Int64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyData\", [[\"accountId\", xdr.lookup(\"AccountId\")], [\"dataName\", xdr.lookup(\"String64\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct\n  //       {\n  //           ClaimableBalanceID balanceID;\n  //       }\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerKeyClaimableBalance\", [[\"balanceId\", xdr.lookup(\"ClaimableBalanceId\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerKey switch (LedgerEntryType type)\n  //   {\n  //   case ACCOUNT:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //       } account;\n  //   \n  //   case TRUSTLINE:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           Asset asset;\n  //       } trustLine;\n  //   \n  //   case OFFER:\n  //       struct\n  //       {\n  //           AccountID sellerID;\n  //           int64 offerID;\n  //       } offer;\n  //   \n  //   case DATA:\n  //       struct\n  //       {\n  //           AccountID accountID;\n  //           string64 dataName;\n  //       } data;\n  //   \n  //   case CLAIMABLE_BALANCE:\n  //       struct\n  //       {\n  //           ClaimableBalanceID balanceID;\n  //       } claimableBalance;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerKey\", {\n    switchOn: xdr.lookup(\"LedgerEntryType\"),\n    switchName: \"type\",\n    switches: [[\"account\", \"account\"], [\"trustline\", \"trustLine\"], [\"offer\", \"offer\"], [\"data\", \"data\"], [\"claimableBalance\", \"claimableBalance\"]],\n    arms: {\n      account: xdr.lookup(\"LedgerKeyAccount\"),\n      trustLine: xdr.lookup(\"LedgerKeyTrustLine\"),\n      offer: xdr.lookup(\"LedgerKeyOffer\"),\n      data: xdr.lookup(\"LedgerKeyData\"),\n      claimableBalance: xdr.lookup(\"LedgerKeyClaimableBalance\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum EnvelopeType\n  //   {\n  //       ENVELOPE_TYPE_TX_V0 = 0,\n  //       ENVELOPE_TYPE_SCP = 1,\n  //       ENVELOPE_TYPE_TX = 2,\n  //       ENVELOPE_TYPE_AUTH = 3,\n  //       ENVELOPE_TYPE_SCPVALUE = 4,\n  //       ENVELOPE_TYPE_TX_FEE_BUMP = 5,\n  //       ENVELOPE_TYPE_OP_ID = 6\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"EnvelopeType\", {\n    envelopeTypeTxV0: 0,\n    envelopeTypeScp: 1,\n    envelopeTypeTx: 2,\n    envelopeTypeAuth: 3,\n    envelopeTypeScpvalue: 4,\n    envelopeTypeTxFeeBump: 5,\n    envelopeTypeOpId: 6\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef opaque UpgradeType<128>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"UpgradeType\", xdr.varOpaque(128));\n\n  // === xdr source ============================================================\n  //\n  //   enum StellarValueType\n  //   {\n  //       STELLAR_VALUE_BASIC = 0,\n  //       STELLAR_VALUE_SIGNED = 1\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"StellarValueType\", {\n    stellarValueBasic: 0,\n    stellarValueSigned: 1\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerCloseValueSignature\n  //   {\n  //       NodeID nodeID;       // which node introduced the value\n  //       Signature signature; // nodeID's signature\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerCloseValueSignature\", [[\"nodeId\", xdr.lookup(\"NodeId\")], [\"signature\", xdr.lookup(\"Signature\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"StellarValueExt\", {\n    switchOn: xdr.lookup(\"StellarValueType\"),\n    switchName: \"v\",\n    switches: [[\"stellarValueBasic\", xdr.void()], [\"stellarValueSigned\", \"lcValueSignature\"]],\n    arms: {\n      lcValueSignature: xdr.lookup(\"LedgerCloseValueSignature\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct StellarValue\n  //   {\n  //       Hash txSetHash;      // transaction set to apply to previous ledger\n  //       TimePoint closeTime; // network close time\n  //   \n  //       // upgrades to apply to the previous ledger (usually empty)\n  //       // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop\n  //       // unknown steps during consensus if needed.\n  //       // see notes below on 'LedgerUpgrade' for more detail\n  //       // max size is dictated by number of upgrade types (+ room for future)\n  //       UpgradeType upgrades<6>;\n  //   \n  //       // reserved for future use\n  //       union switch (StellarValueType v)\n  //       {\n  //       case STELLAR_VALUE_BASIC:\n  //           void;\n  //       case STELLAR_VALUE_SIGNED:\n  //           LedgerCloseValueSignature lcValueSignature;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"StellarValue\", [[\"txSetHash\", xdr.lookup(\"Hash\")], [\"closeTime\", xdr.lookup(\"TimePoint\")], [\"upgrades\", xdr.varArray(xdr.lookup(\"UpgradeType\"), 6)], [\"ext\", xdr.lookup(\"StellarValueExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerHeaderExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerHeader\n  //   {\n  //       uint32 ledgerVersion;    // the protocol version of the ledger\n  //       Hash previousLedgerHash; // hash of the previous ledger header\n  //       StellarValue scpValue;   // what consensus agreed to\n  //       Hash txSetResultHash;    // the TransactionResultSet that led to this ledger\n  //       Hash bucketListHash;     // hash of the ledger state\n  //   \n  //       uint32 ledgerSeq; // sequence number of this ledger\n  //   \n  //       int64 totalCoins; // total number of stroops in existence.\n  //                         // 10,000,000 stroops in 1 XLM\n  //   \n  //       int64 feePool;       // fees burned since last inflation run\n  //       uint32 inflationSeq; // inflation sequence number\n  //   \n  //       uint64 idPool; // last used global ID, used for generating objects\n  //   \n  //       uint32 baseFee;     // base fee per operation in stroops\n  //       uint32 baseReserve; // account base reserve in stroops\n  //   \n  //       uint32 maxTxSetSize; // maximum size a transaction set can be\n  //   \n  //       Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back\n  //                         // in time without walking the chain back ledger by ledger\n  //                         // each slot contains the oldest ledger that is mod of\n  //                         // either 50  5000  50000 or 500000 depending on index\n  //                         // skipList[0] mod(50), skipList[1] mod(5000), etc\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerHeader\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"scpValue\", xdr.lookup(\"StellarValue\")], [\"txSetResultHash\", xdr.lookup(\"Hash\")], [\"bucketListHash\", xdr.lookup(\"Hash\")], [\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"totalCoins\", xdr.lookup(\"Int64\")], [\"feePool\", xdr.lookup(\"Int64\")], [\"inflationSeq\", xdr.lookup(\"Uint32\")], [\"idPool\", xdr.lookup(\"Uint64\")], [\"baseFee\", xdr.lookup(\"Uint32\")], [\"baseReserve\", xdr.lookup(\"Uint32\")], [\"maxTxSetSize\", xdr.lookup(\"Uint32\")], [\"skipList\", xdr.array(xdr.lookup(\"Hash\"), 4)], [\"ext\", xdr.lookup(\"LedgerHeaderExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   enum LedgerUpgradeType\n  //   {\n  //       LEDGER_UPGRADE_VERSION = 1,\n  //       LEDGER_UPGRADE_BASE_FEE = 2,\n  //       LEDGER_UPGRADE_MAX_TX_SET_SIZE = 3,\n  //       LEDGER_UPGRADE_BASE_RESERVE = 4\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"LedgerUpgradeType\", {\n    ledgerUpgradeVersion: 1,\n    ledgerUpgradeBaseFee: 2,\n    ledgerUpgradeMaxTxSetSize: 3,\n    ledgerUpgradeBaseReserve: 4\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerUpgrade switch (LedgerUpgradeType type)\n  //   {\n  //   case LEDGER_UPGRADE_VERSION:\n  //       uint32 newLedgerVersion; // update ledgerVersion\n  //   case LEDGER_UPGRADE_BASE_FEE:\n  //       uint32 newBaseFee; // update baseFee\n  //   case LEDGER_UPGRADE_MAX_TX_SET_SIZE:\n  //       uint32 newMaxTxSetSize; // update maxTxSetSize\n  //   case LEDGER_UPGRADE_BASE_RESERVE:\n  //       uint32 newBaseReserve; // update baseReserve\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerUpgrade\", {\n    switchOn: xdr.lookup(\"LedgerUpgradeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerUpgradeVersion\", \"newLedgerVersion\"], [\"ledgerUpgradeBaseFee\", \"newBaseFee\"], [\"ledgerUpgradeMaxTxSetSize\", \"newMaxTxSetSize\"], [\"ledgerUpgradeBaseReserve\", \"newBaseReserve\"]],\n    arms: {\n      newLedgerVersion: xdr.lookup(\"Uint32\"),\n      newBaseFee: xdr.lookup(\"Uint32\"),\n      newMaxTxSetSize: xdr.lookup(\"Uint32\"),\n      newBaseReserve: xdr.lookup(\"Uint32\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum BucketEntryType\n  //   {\n  //       METAENTRY =\n  //           -1, // At-and-after protocol 11: bucket metadata, should come first.\n  //       LIVEENTRY = 0, // Before protocol 11: created-or-updated;\n  //                      // At-and-after protocol 11: only updated.\n  //       DEADENTRY = 1,\n  //       INITENTRY = 2 // At-and-after protocol 11: only created.\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"BucketEntryType\", {\n    metaentry: -1,\n    liveentry: 0,\n    deadentry: 1,\n    initentry: 2\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"BucketMetadataExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct BucketMetadata\n  //   {\n  //       // Indicates the protocol version used to create / merge this bucket.\n  //       uint32 ledgerVersion;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"BucketMetadata\", [[\"ledgerVersion\", xdr.lookup(\"Uint32\")], [\"ext\", xdr.lookup(\"BucketMetadataExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union BucketEntry switch (BucketEntryType type)\n  //   {\n  //   case LIVEENTRY:\n  //   case INITENTRY:\n  //       LedgerEntry liveEntry;\n  //   \n  //   case DEADENTRY:\n  //       LedgerKey deadEntry;\n  //   case METAENTRY:\n  //       BucketMetadata metaEntry;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"BucketEntry\", {\n    switchOn: xdr.lookup(\"BucketEntryType\"),\n    switchName: \"type\",\n    switches: [[\"liveentry\", \"liveEntry\"], [\"initentry\", \"liveEntry\"], [\"deadentry\", \"deadEntry\"], [\"metaentry\", \"metaEntry\"]],\n    arms: {\n      liveEntry: xdr.lookup(\"LedgerEntry\"),\n      deadEntry: xdr.lookup(\"LedgerKey\"),\n      metaEntry: xdr.lookup(\"BucketMetadata\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionSet\n  //   {\n  //       Hash previousLedgerHash;\n  //       TransactionEnvelope txs<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionSet\", [[\"previousLedgerHash\", xdr.lookup(\"Hash\")], [\"txes\", xdr.varArray(xdr.lookup(\"TransactionEnvelope\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResultPair\n  //   {\n  //       Hash transactionHash;\n  //       TransactionResult result; // result for the transaction\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResultPair\", [[\"transactionHash\", xdr.lookup(\"Hash\")], [\"result\", xdr.lookup(\"TransactionResult\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResultSet\n  //   {\n  //       TransactionResultPair results<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResultSet\", [[\"results\", xdr.varArray(xdr.lookup(\"TransactionResultPair\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionSet txSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionHistoryEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txSet\", xdr.lookup(\"TransactionSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionHistoryResultEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionHistoryResultEntry\n  //   {\n  //       uint32 ledgerSeq;\n  //       TransactionResultSet txResultSet;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionHistoryResultEntry\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"txResultSet\", xdr.lookup(\"TransactionResultSet\")], [\"ext\", xdr.lookup(\"TransactionHistoryResultEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerHeaderHistoryEntryExt\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, xdr.void()]],\n    arms: {}\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerHeaderHistoryEntry\n  //   {\n  //       Hash hash;\n  //       LedgerHeader header;\n  //   \n  //       // reserved for future use\n  //       union switch (int v)\n  //       {\n  //       case 0:\n  //           void;\n  //       }\n  //       ext;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerHeaderHistoryEntry\", [[\"hash\", xdr.lookup(\"Hash\")], [\"header\", xdr.lookup(\"LedgerHeader\")], [\"ext\", xdr.lookup(\"LedgerHeaderHistoryEntryExt\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerSCPMessages\n  //   {\n  //       uint32 ledgerSeq;\n  //       SCPEnvelope messages<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerScpMessages\", [[\"ledgerSeq\", xdr.lookup(\"Uint32\")], [\"messages\", xdr.varArray(xdr.lookup(\"ScpEnvelope\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct SCPHistoryEntryV0\n  //   {\n  //       SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages\n  //       LedgerSCPMessages ledgerMessages;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"ScpHistoryEntryV0\", [[\"quorumSets\", xdr.varArray(xdr.lookup(\"ScpQuorumSet\"), 2147483647)], [\"ledgerMessages\", xdr.lookup(\"LedgerScpMessages\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union SCPHistoryEntry switch (int v)\n  //   {\n  //   case 0:\n  //       SCPHistoryEntryV0 v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"ScpHistoryEntry\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"ScpHistoryEntryV0\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   enum LedgerEntryChangeType\n  //   {\n  //       LEDGER_ENTRY_CREATED = 0, // entry was added to the ledger\n  //       LEDGER_ENTRY_UPDATED = 1, // entry was modified in the ledger\n  //       LEDGER_ENTRY_REMOVED = 2, // entry was removed from the ledger\n  //       LEDGER_ENTRY_STATE = 3    // value of the entry\n  //   };\n  //\n  // ===========================================================================\n  xdr.enum(\"LedgerEntryChangeType\", {\n    ledgerEntryCreated: 0,\n    ledgerEntryUpdated: 1,\n    ledgerEntryRemoved: 2,\n    ledgerEntryState: 3\n  });\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerEntryChange switch (LedgerEntryChangeType type)\n  //   {\n  //   case LEDGER_ENTRY_CREATED:\n  //       LedgerEntry created;\n  //   case LEDGER_ENTRY_UPDATED:\n  //       LedgerEntry updated;\n  //   case LEDGER_ENTRY_REMOVED:\n  //       LedgerKey removed;\n  //   case LEDGER_ENTRY_STATE:\n  //       LedgerEntry state;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerEntryChange\", {\n    switchOn: xdr.lookup(\"LedgerEntryChangeType\"),\n    switchName: \"type\",\n    switches: [[\"ledgerEntryCreated\", \"created\"], [\"ledgerEntryUpdated\", \"updated\"], [\"ledgerEntryRemoved\", \"removed\"], [\"ledgerEntryState\", \"state\"]],\n    arms: {\n      created: xdr.lookup(\"LedgerEntry\"),\n      updated: xdr.lookup(\"LedgerEntry\"),\n      removed: xdr.lookup(\"LedgerKey\"),\n      state: xdr.lookup(\"LedgerEntry\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   typedef LedgerEntryChange LedgerEntryChanges<>;\n  //\n  // ===========================================================================\n  xdr.typedef(\"LedgerEntryChanges\", xdr.varArray(xdr.lookup(\"LedgerEntryChange\"), 2147483647));\n\n  // === xdr source ============================================================\n  //\n  //   struct OperationMeta\n  //   {\n  //       LedgerEntryChanges changes;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"OperationMeta\", [[\"changes\", xdr.lookup(\"LedgerEntryChanges\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionMetaV1\n  //   {\n  //       LedgerEntryChanges txChanges; // tx level changes if any\n  //       OperationMeta operations<>;   // meta for each operation\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionMetaV1\", [[\"txChanges\", xdr.lookup(\"LedgerEntryChanges\")], [\"operations\", xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionMetaV2\n  //   {\n  //       LedgerEntryChanges txChangesBefore; // tx level changes before operations\n  //                                           // are applied if any\n  //       OperationMeta operations<>;         // meta for each operation\n  //       LedgerEntryChanges txChangesAfter;  // tx level changes after operations are\n  //                                           // applied if any\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionMetaV2\", [[\"txChangesBefore\", xdr.lookup(\"LedgerEntryChanges\")], [\"operations\", xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647)], [\"txChangesAfter\", xdr.lookup(\"LedgerEntryChanges\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   union TransactionMeta switch (int v)\n  //   {\n  //   case 0:\n  //       OperationMeta operations<>;\n  //   case 1:\n  //       TransactionMetaV1 v1;\n  //   case 2:\n  //       TransactionMetaV2 v2;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"TransactionMeta\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"operations\"], [1, \"v1\"], [2, \"v2\"]],\n    arms: {\n      operations: xdr.varArray(xdr.lookup(\"OperationMeta\"), 2147483647),\n      v1: xdr.lookup(\"TransactionMetaV1\"),\n      v2: xdr.lookup(\"TransactionMetaV2\")\n    }\n  });\n\n  // === xdr source ============================================================\n  //\n  //   struct TransactionResultMeta\n  //   {\n  //       TransactionResultPair result;\n  //       LedgerEntryChanges feeProcessing;\n  //       TransactionMeta txApplyProcessing;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"TransactionResultMeta\", [[\"result\", xdr.lookup(\"TransactionResultPair\")], [\"feeProcessing\", xdr.lookup(\"LedgerEntryChanges\")], [\"txApplyProcessing\", xdr.lookup(\"TransactionMeta\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct UpgradeEntryMeta\n  //   {\n  //       LedgerUpgrade upgrade;\n  //       LedgerEntryChanges changes;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"UpgradeEntryMeta\", [[\"upgrade\", xdr.lookup(\"LedgerUpgrade\")], [\"changes\", xdr.lookup(\"LedgerEntryChanges\")]]);\n\n  // === xdr source ============================================================\n  //\n  //   struct LedgerCloseMetaV0\n  //   {\n  //       LedgerHeaderHistoryEntry ledgerHeader;\n  //       // NB: txSet is sorted in \"Hash order\"\n  //       TransactionSet txSet;\n  //   \n  //       // NB: transactions are sorted in apply order here\n  //       // fees for all transactions are processed first\n  //       // followed by applying transactions\n  //       TransactionResultMeta txProcessing<>;\n  //   \n  //       // upgrades are applied last\n  //       UpgradeEntryMeta upgradesProcessing<>;\n  //   \n  //       // other misc information attached to the ledger close\n  //       SCPHistoryEntry scpInfo<>;\n  //   };\n  //\n  // ===========================================================================\n  xdr.struct(\"LedgerCloseMetaV0\", [[\"ledgerHeader\", xdr.lookup(\"LedgerHeaderHistoryEntry\")], [\"txSet\", xdr.lookup(\"TransactionSet\")], [\"txProcessing\", xdr.varArray(xdr.lookup(\"TransactionResultMeta\"), 2147483647)], [\"upgradesProcessing\", xdr.varArray(xdr.lookup(\"UpgradeEntryMeta\"), 2147483647)], [\"scpInfo\", xdr.varArray(xdr.lookup(\"ScpHistoryEntry\"), 2147483647)]]);\n\n  // === xdr source ============================================================\n  //\n  //   union LedgerCloseMeta switch (int v)\n  //   {\n  //   case 0:\n  //       LedgerCloseMetaV0 v0;\n  //   };\n  //\n  // ===========================================================================\n  xdr.union(\"LedgerCloseMeta\", {\n    switchOn: xdr.int(),\n    switchName: \"v\",\n    switches: [[0, \"v0\"]],\n    arms: {\n      v0: xdr.lookup(\"LedgerCloseMetaV0\")\n    }\n  });\n}); // Automatically generated on 2020-09-21T15:09:03-05:00\n// DO NOT EDIT or your changes may be overwritten\n\n/* jshint maxstatements:2147483647  */\n/* jshint esnext:true  */\n\nexports.default = types;"]},"metadata":{},"sourceType":"script"}