{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.isValidDate = isValidDate;\n\nvar _jsXdr = require('js-xdr');\n\nvar _bignumber = require('bignumber.js');\n\nvar _bignumber2 = _interopRequireDefault(_bignumber);\n\nvar _clone = require('lodash/clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _isUndefined = require('lodash/isUndefined');\n\nvar _isUndefined2 = _interopRequireDefault(_isUndefined);\n\nvar _stellarXdr_generated = require('./generated/stellar-xdr_generated');\n\nvar _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);\n\nvar _keypair = require('./keypair');\n\nvar _transaction = require('./transaction');\n\nvar _fee_bump_transaction = require('./fee_bump_transaction');\n\nvar _memo = require('./memo');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Minimum base fee for transactions. If this fee is below the network\n * minimum, the transaction will fail. The more operations in the\n * transaction, the greater the required fee. Use {@link\n * Server#fetchBaseFee} to get an accurate value of minimum transaction\n * fee on the network.\n *\n * @constant\n * @see [Fees](https://www.stellar.org/developers/guides/concepts/fees.html)\n */\n\n\nvar BASE_FEE = exports.BASE_FEE = '100'; // Stroops\n\n/**\n * @constant\n * @see {@link TransactionBuilder#setTimeout}\n * @see [Timeout](https://www.stellar.org/developers/horizon/reference/endpoints/transactions-create.html#timeout)\n */\n\nvar TimeoutInfinite = exports.TimeoutInfinite = 0;\n/**\n * <p>Transaction builder helps constructs a new `{@link Transaction}` using the given {@link Account}\n * as the transaction's \"source account\". The transaction will use the current sequence\n * number of the given account as its sequence number and increment the given account's\n * sequence number by one. The given source account must include a private key for signing\n * the transaction or an error will be thrown.</p>\n *\n * <p>Operations can be added to the transaction via their corresponding builder methods, and\n * each returns the TransactionBuilder object so they can be chained together. After adding\n * the desired operations, call the `build()` method on the `TransactionBuilder` to return a fully\n * constructed `{@link Transaction}` that can be signed. The returned transaction will contain the\n * sequence number of the source account and include the signature from the source account.</p>\n *\n * <p><strong>Be careful about unsubmitted transactions!</strong> When you build a transaction, stellar-sdk\n * automatically increments the source account's sequence number. If you end up\n * not submitting this transaction and submitting another one instead, it'll fail due to\n * the sequence number being wrong. So if you decide not to use a built transaction,\n * make sure to update the source account's sequence number\n * with [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount) before creating another transaction.</p>\n *\n * <p>The following code example creates a new transaction with {@link Operation.createAccount} and\n * {@link Operation.payment} operations.\n * The Transaction's source account first funds `destinationA`, then sends\n * a payment to `destinationB`. The built transaction is then signed by `sourceKeypair`.</p>\n *\n * ```\n * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })\n * .addOperation(Operation.createAccount({\n *     destination: destinationA,\n *     startingBalance: \"20\"\n * })) // <- funds and creates destinationA\n * .addOperation(Operation.payment({\n *     destination: destinationB,\n *     amount: \"100\",\n *     asset: Asset.native()\n * })) // <- sends 100 XLM to destinationB\n * .setTimeout(30)\n * .build();\n *\n * transaction.sign(sourceKeypair);\n * ```\n * @constructor\n * @param {Account} sourceAccount - The source account for this transaction.\n * @param {object} opts Options object\n * @param {string} opts.fee - The max fee willing to pay per operation in this transaction (**in stroops**). Required.\n * @param {object} [opts.timebounds] - The timebounds for the validity of this transaction.\n * @param {number|string|Date} [opts.timebounds.minTime] - 64 bit unix timestamp or Date object\n * @param {number|string|Date} [opts.timebounds.maxTime] - 64 bit unix timestamp or Date object\n * @param {Memo} [opts.memo] - The memo for the transaction\n * @param {string} [opts.networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n */\n\nvar TransactionBuilder = exports.TransactionBuilder = function () {\n  function TransactionBuilder(sourceAccount) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransactionBuilder);\n\n    if (!sourceAccount) {\n      throw new Error('must specify source account for the transaction');\n    }\n\n    if ((0, _isUndefined2.default)(opts.fee)) {\n      throw new Error('must specify fee for the transaction (in stroops)');\n    }\n\n    this.source = sourceAccount;\n    this.operations = [];\n    this.baseFee = (0, _isUndefined2.default)(opts.fee) ? BASE_FEE : opts.fee;\n    this.timebounds = (0, _clone2.default)(opts.timebounds) || null;\n    this.memo = opts.memo || _memo.Memo.none();\n    this.networkPassphrase = opts.networkPassphrase || null;\n  }\n  /**\n   * Adds an operation to the transaction.\n   * @param {xdr.Operation} operation The xdr operation object, use {@link Operation} static methods.\n   * @returns {TransactionBuilder}\n   */\n\n\n  _createClass(TransactionBuilder, [{\n    key: 'addOperation',\n    value: function addOperation(operation) {\n      this.operations.push(operation);\n      return this;\n    }\n    /**\n     * Adds a memo to the transaction.\n     * @param {Memo} memo {@link Memo} object\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'addMemo',\n    value: function addMemo(memo) {\n      this.memo = memo;\n      return this;\n    }\n    /**\n     * Because of the distributed nature of the Stellar network it is possible that the status of your transaction\n     * will be determined after a long time if the network is highly congested.\n     * If you want to be sure to receive the status of the transaction within a given period you should set the\n     * {@link TimeBounds} with <code>maxTime</code> on the transaction (this is what <code>setTimeout</code> does\n     * internally; if there's <code>minTime</code> set but no <code>maxTime</code> it will be added).\n     * Call to <code>TransactionBuilder.setTimeout</code> is required if Transaction does not have <code>max_time</code> set.\n     * If you don't want to set timeout, use <code>{@link TimeoutInfinite}</code>. In general you should set\n     * <code>{@link TimeoutInfinite}</code> only in smart contracts.\n     *\n     * Please note that Horizon may still return <code>504 Gateway Timeout</code> error, even for short timeouts.\n     * In such case you need to resubmit the same transaction again without making any changes to receive a status.\n     * This method is using the machine system time (UTC), make sure it is set correctly.\n     * @param {number} timeout Number of seconds the transaction is good. Can't be negative.\n     * If the value is `0`, the transaction is good indefinitely.\n     * @return {TransactionBuilder}\n     * @see TimeoutInfinite\n     */\n\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(timeout) {\n      if (this.timebounds !== null && this.timebounds.maxTime > 0) {\n        throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');\n      }\n\n      if (timeout < 0) {\n        throw new Error('timeout cannot be negative');\n      }\n\n      if (timeout > 0) {\n        var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeout;\n\n        if (this.timebounds === null) {\n          this.timebounds = {\n            minTime: 0,\n            maxTime: timeoutTimestamp\n          };\n        } else {\n          this.timebounds = {\n            minTime: this.timebounds.minTime,\n            maxTime: timeoutTimestamp\n          };\n        }\n      } else {\n        this.timebounds = {\n          minTime: 0,\n          maxTime: 0\n        };\n      }\n\n      return this;\n    }\n    /**\n     * Set network nassphrase for the Transaction that will be built.\n     *\n     * @param {string} [networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setNetworkPassphrase',\n    value: function setNetworkPassphrase(networkPassphrase) {\n      this.networkPassphrase = networkPassphrase;\n      return this;\n    }\n    /**\n     * This will build the transaction.\n     * It will also increment the source account's sequence number by 1.\n     * @returns {Transaction} This method will return the built {@link Transaction}.\n     */\n\n  }, {\n    key: 'build',\n    value: function build() {\n      var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);\n      var fee = new _bignumber2.default(this.baseFee).mul(this.operations.length).toNumber();\n      var attrs = {\n        fee: fee,\n        seqNum: _stellarXdr_generated2.default.SequenceNumber.fromString(sequenceNumber.toString()),\n        memo: this.memo ? this.memo.toXDRObject() : null\n      };\n\n      if (this.timebounds === null || typeof this.timebounds.minTime === 'undefined' || typeof this.timebounds.maxTime === 'undefined') {\n        throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');\n      }\n\n      if (isValidDate(this.timebounds.minTime)) {\n        this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;\n      }\n\n      if (isValidDate(this.timebounds.maxTime)) {\n        this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;\n      }\n\n      this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());\n      this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());\n      attrs.timeBounds = new _stellarXdr_generated2.default.TimeBounds(this.timebounds);\n      attrs.sourceAccount = _keypair.Keypair.fromPublicKey(this.source.accountId()).xdrMuxedAccount();\n      attrs.ext = new _stellarXdr_generated2.default.TransactionExt(0);\n      var xtx = new _stellarXdr_generated2.default.Transaction(attrs);\n      xtx.operations(this.operations);\n      var txEnvelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({\n        tx: xtx\n      }));\n      var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);\n      this.source.incrementSequenceNumber();\n      return tx;\n    }\n    /**\n     * Builds a {@link FeeBumpTransaction}\n     * @param {Keypair} feeSource - The account paying for the transaction.\n     * @param {string} baseFee - The max fee willing to pay per operation in inner transaction (**in stroops**). Required.\n     * @param {Transaction} innerTx - The Transaction to be bumped by the fee bump transaction.\n     * @param {string} networkPassphrase - networkPassphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {FeeBumpTransaction}\n     */\n\n  }], [{\n    key: 'buildFeeBumpTransaction',\n    value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {\n      var innerOps = innerTx.operations.length;\n      var innerBaseFeeRate = new _bignumber2.default(innerTx.fee).div(innerOps);\n      var base = new _bignumber2.default(baseFee); // The fee rate for fee bump is at least the fee rate of the inner transaction\n\n      if (base.lessThan(innerBaseFeeRate)) {\n        throw new Error('Invalid baseFee, it should be at least ' + innerBaseFeeRate + ' stroops.');\n      }\n\n      var minBaseFee = new _bignumber2.default(BASE_FEE); // The fee rate is at least the minimum fee\n\n      if (base.lessThan(minBaseFee)) {\n        throw new Error('Invalid baseFee, it should be at least ' + minBaseFee + ' stroops.');\n      }\n\n      var innerTxEnvelope = innerTx.toEnvelope();\n\n      if (innerTxEnvelope.switch() === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0()) {\n        var v0Tx = innerTxEnvelope.v0().tx();\n        var v1Tx = new _stellarXdr_generated2.default.Transaction({\n          sourceAccount: new _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),\n          fee: v0Tx.fee(),\n          seqNum: v0Tx.seqNum(),\n          timeBounds: v0Tx.timeBounds(),\n          memo: v0Tx.memo(),\n          operations: v0Tx.operations(),\n          ext: new _stellarXdr_generated2.default.TransactionExt(0)\n        });\n        innerTxEnvelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({\n          tx: v1Tx,\n          signatures: innerTxEnvelope.v0().signatures()\n        }));\n      }\n\n      var tx = new _stellarXdr_generated2.default.FeeBumpTransaction({\n        feeSource: feeSource.xdrMuxedAccount(),\n        fee: _stellarXdr_generated2.default.Int64.fromString(base.mul(innerOps + 1).toString()),\n        innerTx: _stellarXdr_generated2.default.FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),\n        ext: new _stellarXdr_generated2.default.FeeBumpTransactionExt(0)\n      });\n      var feeBumpTxEnvelope = new _stellarXdr_generated2.default.FeeBumpTransactionEnvelope({\n        tx: tx,\n        signatures: []\n      });\n      var envelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);\n      return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n    }\n    /**\n     * Build a {@link Transaction} or {@link FeeBumpTransaction} from an xdr.TransactionEnvelope.\n     * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope object or base64 encoded string.\n     * @param {string} networkPassphrase - networkPassphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {Transaction|FeeBumpTransaction}\n     */\n\n  }, {\n    key: 'fromXDR',\n    value: function fromXDR(envelope, networkPassphrase) {\n      if (typeof envelope === 'string') {\n        envelope = _stellarXdr_generated2.default.TransactionEnvelope.fromXDR(envelope, 'base64');\n      }\n\n      if (envelope.switch() === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxFeeBump()) {\n        return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n      }\n\n      return new _transaction.Transaction(envelope, networkPassphrase);\n    }\n  }]);\n\n  return TransactionBuilder;\n}();\n/**\n * Checks whether a provided object is a valid Date.\n * @argument {Date} d date object\n * @returns {boolean}\n */\n\n\nfunction isValidDate(d) {\n  // isnan is okay here because it correctly checks for invalid date objects\n  // eslint-disable-next-line no-restricted-globals\n  return d instanceof Date && !isNaN(d);\n}","map":{"version":3,"sources":["/home/manuel/Escritorio/blockchain_code/blockchain-crowdfunding/test_crowdfundig/node_modules/stellar-base/lib/transaction_builder.js"],"names":["Object","defineProperty","exports","value","TransactionBuilder","TimeoutInfinite","BASE_FEE","undefined","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","isValidDate","_jsXdr","require","_bignumber","_bignumber2","_interopRequireDefault","_clone","_clone2","_isUndefined","_isUndefined2","_stellarXdr_generated","_stellarXdr_generated2","_keypair","_transaction","_fee_bump_transaction","_memo","obj","__esModule","default","_classCallCheck","instance","TypeError","sourceAccount","opts","arguments","Error","fee","source","operations","baseFee","timebounds","memo","Memo","none","networkPassphrase","addOperation","operation","push","addMemo","setTimeout","timeout","maxTime","timeoutTimestamp","Math","floor","Date","now","minTime","setNetworkPassphrase","build","sequenceNumber","add","mul","toNumber","attrs","seqNum","SequenceNumber","fromString","toString","toXDRObject","getTime","UnsignedHyper","timeBounds","TimeBounds","Keypair","fromPublicKey","accountId","xdrMuxedAccount","ext","TransactionExt","xtx","Transaction","txEnvelope","TransactionEnvelope","envelopeTypeTx","TransactionV1Envelope","tx","incrementSequenceNumber","buildFeeBumpTransaction","feeSource","innerTx","innerOps","innerBaseFeeRate","div","base","lessThan","minBaseFee","innerTxEnvelope","toEnvelope","switch","EnvelopeType","envelopeTypeTxV0","v0Tx","v0","v1Tx","MuxedAccount","keyTypeEd25519","sourceAccountEd25519","signatures","FeeBumpTransaction","Int64","FeeBumpTransactionInnerTx","v1","FeeBumpTransactionExt","feeBumpTxEnvelope","FeeBumpTransactionEnvelope","envelope","envelopeTypeTxFeeBump","fromXDR","d","isNaN"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isValidDate = isValidDate;\n\nvar _jsXdr = require('js-xdr');\n\nvar _bignumber = require('bignumber.js');\n\nvar _bignumber2 = _interopRequireDefault(_bignumber);\n\nvar _clone = require('lodash/clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _isUndefined = require('lodash/isUndefined');\n\nvar _isUndefined2 = _interopRequireDefault(_isUndefined);\n\nvar _stellarXdr_generated = require('./generated/stellar-xdr_generated');\n\nvar _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);\n\nvar _keypair = require('./keypair');\n\nvar _transaction = require('./transaction');\n\nvar _fee_bump_transaction = require('./fee_bump_transaction');\n\nvar _memo = require('./memo');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Minimum base fee for transactions. If this fee is below the network\n * minimum, the transaction will fail. The more operations in the\n * transaction, the greater the required fee. Use {@link\n * Server#fetchBaseFee} to get an accurate value of minimum transaction\n * fee on the network.\n *\n * @constant\n * @see [Fees](https://www.stellar.org/developers/guides/concepts/fees.html)\n */\nvar BASE_FEE = exports.BASE_FEE = '100'; // Stroops\n\n/**\n * @constant\n * @see {@link TransactionBuilder#setTimeout}\n * @see [Timeout](https://www.stellar.org/developers/horizon/reference/endpoints/transactions-create.html#timeout)\n */\nvar TimeoutInfinite = exports.TimeoutInfinite = 0;\n\n/**\n * <p>Transaction builder helps constructs a new `{@link Transaction}` using the given {@link Account}\n * as the transaction's \"source account\". The transaction will use the current sequence\n * number of the given account as its sequence number and increment the given account's\n * sequence number by one. The given source account must include a private key for signing\n * the transaction or an error will be thrown.</p>\n *\n * <p>Operations can be added to the transaction via their corresponding builder methods, and\n * each returns the TransactionBuilder object so they can be chained together. After adding\n * the desired operations, call the `build()` method on the `TransactionBuilder` to return a fully\n * constructed `{@link Transaction}` that can be signed. The returned transaction will contain the\n * sequence number of the source account and include the signature from the source account.</p>\n *\n * <p><strong>Be careful about unsubmitted transactions!</strong> When you build a transaction, stellar-sdk\n * automatically increments the source account's sequence number. If you end up\n * not submitting this transaction and submitting another one instead, it'll fail due to\n * the sequence number being wrong. So if you decide not to use a built transaction,\n * make sure to update the source account's sequence number\n * with [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount) before creating another transaction.</p>\n *\n * <p>The following code example creates a new transaction with {@link Operation.createAccount} and\n * {@link Operation.payment} operations.\n * The Transaction's source account first funds `destinationA`, then sends\n * a payment to `destinationB`. The built transaction is then signed by `sourceKeypair`.</p>\n *\n * ```\n * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })\n * .addOperation(Operation.createAccount({\n *     destination: destinationA,\n *     startingBalance: \"20\"\n * })) // <- funds and creates destinationA\n * .addOperation(Operation.payment({\n *     destination: destinationB,\n *     amount: \"100\",\n *     asset: Asset.native()\n * })) // <- sends 100 XLM to destinationB\n * .setTimeout(30)\n * .build();\n *\n * transaction.sign(sourceKeypair);\n * ```\n * @constructor\n * @param {Account} sourceAccount - The source account for this transaction.\n * @param {object} opts Options object\n * @param {string} opts.fee - The max fee willing to pay per operation in this transaction (**in stroops**). Required.\n * @param {object} [opts.timebounds] - The timebounds for the validity of this transaction.\n * @param {number|string|Date} [opts.timebounds.minTime] - 64 bit unix timestamp or Date object\n * @param {number|string|Date} [opts.timebounds.maxTime] - 64 bit unix timestamp or Date object\n * @param {Memo} [opts.memo] - The memo for the transaction\n * @param {string} [opts.networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n */\n\nvar TransactionBuilder = exports.TransactionBuilder = function () {\n  function TransactionBuilder(sourceAccount) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransactionBuilder);\n\n    if (!sourceAccount) {\n      throw new Error('must specify source account for the transaction');\n    }\n\n    if ((0, _isUndefined2.default)(opts.fee)) {\n      throw new Error('must specify fee for the transaction (in stroops)');\n    }\n\n    this.source = sourceAccount;\n    this.operations = [];\n\n    this.baseFee = (0, _isUndefined2.default)(opts.fee) ? BASE_FEE : opts.fee;\n    this.timebounds = (0, _clone2.default)(opts.timebounds) || null;\n    this.memo = opts.memo || _memo.Memo.none();\n    this.networkPassphrase = opts.networkPassphrase || null;\n  }\n\n  /**\n   * Adds an operation to the transaction.\n   * @param {xdr.Operation} operation The xdr operation object, use {@link Operation} static methods.\n   * @returns {TransactionBuilder}\n   */\n\n\n  _createClass(TransactionBuilder, [{\n    key: 'addOperation',\n    value: function addOperation(operation) {\n      this.operations.push(operation);\n      return this;\n    }\n\n    /**\n     * Adds a memo to the transaction.\n     * @param {Memo} memo {@link Memo} object\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'addMemo',\n    value: function addMemo(memo) {\n      this.memo = memo;\n      return this;\n    }\n\n    /**\n     * Because of the distributed nature of the Stellar network it is possible that the status of your transaction\n     * will be determined after a long time if the network is highly congested.\n     * If you want to be sure to receive the status of the transaction within a given period you should set the\n     * {@link TimeBounds} with <code>maxTime</code> on the transaction (this is what <code>setTimeout</code> does\n     * internally; if there's <code>minTime</code> set but no <code>maxTime</code> it will be added).\n     * Call to <code>TransactionBuilder.setTimeout</code> is required if Transaction does not have <code>max_time</code> set.\n     * If you don't want to set timeout, use <code>{@link TimeoutInfinite}</code>. In general you should set\n     * <code>{@link TimeoutInfinite}</code> only in smart contracts.\n     *\n     * Please note that Horizon may still return <code>504 Gateway Timeout</code> error, even for short timeouts.\n     * In such case you need to resubmit the same transaction again without making any changes to receive a status.\n     * This method is using the machine system time (UTC), make sure it is set correctly.\n     * @param {number} timeout Number of seconds the transaction is good. Can't be negative.\n     * If the value is `0`, the transaction is good indefinitely.\n     * @return {TransactionBuilder}\n     * @see TimeoutInfinite\n     */\n\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(timeout) {\n      if (this.timebounds !== null && this.timebounds.maxTime > 0) {\n        throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');\n      }\n\n      if (timeout < 0) {\n        throw new Error('timeout cannot be negative');\n      }\n\n      if (timeout > 0) {\n        var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeout;\n        if (this.timebounds === null) {\n          this.timebounds = { minTime: 0, maxTime: timeoutTimestamp };\n        } else {\n          this.timebounds = {\n            minTime: this.timebounds.minTime,\n            maxTime: timeoutTimestamp\n          };\n        }\n      } else {\n        this.timebounds = {\n          minTime: 0,\n          maxTime: 0\n        };\n      }\n\n      return this;\n    }\n\n    /**\n     * Set network nassphrase for the Transaction that will be built.\n     *\n     * @param {string} [networkPassphrase] passphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setNetworkPassphrase',\n    value: function setNetworkPassphrase(networkPassphrase) {\n      this.networkPassphrase = networkPassphrase;\n      return this;\n    }\n\n    /**\n     * This will build the transaction.\n     * It will also increment the source account's sequence number by 1.\n     * @returns {Transaction} This method will return the built {@link Transaction}.\n     */\n\n  }, {\n    key: 'build',\n    value: function build() {\n      var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);\n      var fee = new _bignumber2.default(this.baseFee).mul(this.operations.length).toNumber();\n      var attrs = {\n        fee: fee,\n        seqNum: _stellarXdr_generated2.default.SequenceNumber.fromString(sequenceNumber.toString()),\n        memo: this.memo ? this.memo.toXDRObject() : null\n      };\n\n      if (this.timebounds === null || typeof this.timebounds.minTime === 'undefined' || typeof this.timebounds.maxTime === 'undefined') {\n        throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');\n      }\n\n      if (isValidDate(this.timebounds.minTime)) {\n        this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;\n      }\n      if (isValidDate(this.timebounds.maxTime)) {\n        this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;\n      }\n\n      this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());\n      this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());\n\n      attrs.timeBounds = new _stellarXdr_generated2.default.TimeBounds(this.timebounds);\n      attrs.sourceAccount = _keypair.Keypair.fromPublicKey(this.source.accountId()).xdrMuxedAccount();\n      attrs.ext = new _stellarXdr_generated2.default.TransactionExt(0);\n\n      var xtx = new _stellarXdr_generated2.default.Transaction(attrs);\n      xtx.operations(this.operations);\n      var txEnvelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({ tx: xtx }));\n\n      var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);\n\n      this.source.incrementSequenceNumber();\n\n      return tx;\n    }\n\n    /**\n     * Builds a {@link FeeBumpTransaction}\n     * @param {Keypair} feeSource - The account paying for the transaction.\n     * @param {string} baseFee - The max fee willing to pay per operation in inner transaction (**in stroops**). Required.\n     * @param {Transaction} innerTx - The Transaction to be bumped by the fee bump transaction.\n     * @param {string} networkPassphrase - networkPassphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {FeeBumpTransaction}\n     */\n\n  }], [{\n    key: 'buildFeeBumpTransaction',\n    value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {\n      var innerOps = innerTx.operations.length;\n      var innerBaseFeeRate = new _bignumber2.default(innerTx.fee).div(innerOps);\n      var base = new _bignumber2.default(baseFee);\n\n      // The fee rate for fee bump is at least the fee rate of the inner transaction\n      if (base.lessThan(innerBaseFeeRate)) {\n        throw new Error('Invalid baseFee, it should be at least ' + innerBaseFeeRate + ' stroops.');\n      }\n\n      var minBaseFee = new _bignumber2.default(BASE_FEE);\n\n      // The fee rate is at least the minimum fee\n      if (base.lessThan(minBaseFee)) {\n        throw new Error('Invalid baseFee, it should be at least ' + minBaseFee + ' stroops.');\n      }\n\n      var innerTxEnvelope = innerTx.toEnvelope();\n      if (innerTxEnvelope.switch() === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0()) {\n        var v0Tx = innerTxEnvelope.v0().tx();\n        var v1Tx = new _stellarXdr_generated2.default.Transaction({\n          sourceAccount: new _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),\n          fee: v0Tx.fee(),\n          seqNum: v0Tx.seqNum(),\n          timeBounds: v0Tx.timeBounds(),\n          memo: v0Tx.memo(),\n          operations: v0Tx.operations(),\n          ext: new _stellarXdr_generated2.default.TransactionExt(0)\n        });\n        innerTxEnvelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({\n          tx: v1Tx,\n          signatures: innerTxEnvelope.v0().signatures()\n        }));\n      }\n\n      var tx = new _stellarXdr_generated2.default.FeeBumpTransaction({\n        feeSource: feeSource.xdrMuxedAccount(),\n        fee: _stellarXdr_generated2.default.Int64.fromString(base.mul(innerOps + 1).toString()),\n        innerTx: _stellarXdr_generated2.default.FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),\n        ext: new _stellarXdr_generated2.default.FeeBumpTransactionExt(0)\n      });\n      var feeBumpTxEnvelope = new _stellarXdr_generated2.default.FeeBumpTransactionEnvelope({\n        tx: tx,\n        signatures: []\n      });\n      var envelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);\n\n      return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n    }\n\n    /**\n     * Build a {@link Transaction} or {@link FeeBumpTransaction} from an xdr.TransactionEnvelope.\n     * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope object or base64 encoded string.\n     * @param {string} networkPassphrase - networkPassphrase of the target stellar network (e.g. \"Public Global Stellar Network ; September 2015\").\n     * @returns {Transaction|FeeBumpTransaction}\n     */\n\n  }, {\n    key: 'fromXDR',\n    value: function fromXDR(envelope, networkPassphrase) {\n      if (typeof envelope === 'string') {\n        envelope = _stellarXdr_generated2.default.TransactionEnvelope.fromXDR(envelope, 'base64');\n      }\n\n      if (envelope.switch() === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxFeeBump()) {\n        return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n      }\n\n      return new _transaction.Transaction(envelope, networkPassphrase);\n    }\n  }]);\n\n  return TransactionBuilder;\n}();\n\n/**\n * Checks whether a provided object is a valid Date.\n * @argument {Date} d date object\n * @returns {boolean}\n */\n\n\nfunction isValidDate(d) {\n  // isnan is okay here because it correctly checks for invalid date objects\n  // eslint-disable-next-line no-restricted-globals\n  return d instanceof Date && !isNaN(d);\n}"]},"metadata":{},"sourceType":"script"}