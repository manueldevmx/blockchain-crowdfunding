{"ast":null,"code":"/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.2\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict'; // https://github.com/umdjs/umd/blob/master/returnExports.js\n\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory(require('./URI'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./URI'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URITemplate = factory(root.URI, root);\n  }\n})(this, function (URI, root) {\n  'use strict'; // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n\n  /*jshint camelcase: false */\n  // save current URITemplate variable, if any\n\n  var _URITemplate = root && root.URITemplate;\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    } // Allow instantiation without the 'new' keyword\n\n\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n\n  var p = URITemplate.prototype; // list of operators and their defined options\n\n  var operators = {\n    // Simple string expansion\n    '': {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Reserved character strings\n    '+': {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#': {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.': {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/': {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';': {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?': {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode: 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&': {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode: 'encode'\n    } // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n\n  }; // storage for already parsed templates\n\n  URITemplate._cache = {}; // pattern to identify expressions [operator, variable-list] in template\n\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g; // pattern to identify variables [name, explode, maxlength] in variable-list\n\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/; // pattern to verify variable name integrity\n\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/; // pattern to verify literal integrity\n\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/; // expand parsed expression (expression, not template!)\n\n  URITemplate.expand = function (expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator]; // expansion type (include keys or not)\n\n    var type = options.named ? 'Named' : 'Unnamed'; // list of variables within the expression\n\n    var variables = expression.variables; // result buffer for evaluating the expression\n\n    var buffer = [];\n    var d, variable, i;\n\n    for (i = 0; variable = variables[i]; i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n\n      if (d.type === 0 && opts && opts.strict) {\n        throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        } // no data, no action\n\n\n        continue;\n      }\n\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      } // expand the given variable\n\n\n      buffer.push(URITemplate['expand' + type](d, options, variable.explode, variable.explode && options.separator || ',', variable.maxlength, variable.name));\n    }\n\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  }; // expand a named variable\n\n\n  URITemplate.expandNamed = function (d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = ''; // peformance crap\n\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator; // flag noting if values are already encoded\n\n    var _encode = !d[encode].length; // key for named expansion\n\n\n    var _name = d.type === 2 ? '' : URI[encode](name);\n\n    var _value, i, l; // for each found value\n\n\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n\n    return result;\n  }; // expand an unnamed variable\n\n\n  URITemplate.expandUnnamed = function (d, options, explode, separator, length) {\n    // variable result buffer\n    var result = ''; // performance crap\n\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator; // flag noting if values are already encoded\n\n    var _encode = !d[encode].length;\n\n    var _name, _value, i, l; // for each found value\n\n\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([d.type === 2 ? URI[encode](d.val[i][0]) : undefined, _value]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n\n        result += _name;\n\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += empty_name_separator || _value ? '=' : '';\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n\n      result += _value;\n    }\n\n    return result;\n  };\n\n  URITemplate.noConflict = function () {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n\n    return URITemplate;\n  }; // expand template through given data map\n\n\n  p.expand = function (data, opts) {\n    var result = '';\n\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string' // literal string\n      ? this.parts[i] // expression\n      : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  }; // parse template into action tokens\n\n\n  p.parse = function () {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN; // token result buffer\n\n    var parts = []; // position within source template\n\n    var pos = 0;\n    var variables, eMatch, vMatch;\n\n    var checkLiteral = function (literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n\n      return literal;\n    }; // RegExp is shared accross all templates,\n    // which requires a manual reset\n\n\n    ePattern.lastIndex = 0; // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n\n    while (true) {\n      eMatch = ePattern.exec(expression);\n\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1] + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0] + '\"');\n      } // parse variable-list\n\n\n      variables = eMatch[2].split(',');\n\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n\n    this.parts = parts;\n    return this;\n  }; // simplify data structures\n\n\n  Data.prototype.get = function (key) {\n    // performance crap\n    var data = this.data; // cache for processed data-point\n\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n\n    this.cache[key] = d;\n\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    } // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n\n\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n\n      d.val.push([undefined, String(value)]);\n    }\n\n    return d;\n  }; // hook into URI for fluid access\n\n\n  URI.expand = function (expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n    return new URI(expansion);\n  };\n\n  return URITemplate;\n});","map":{"version":3,"sources":["/home/manuel/Escritorio/blockchain_code/blockchain-crowdfunding/test_crowdfundig/node_modules/urijs/src/URITemplate.js"],"names":["root","factory","module","exports","require","define","amd","URITemplate","URI","_URITemplate","hasOwn","Object","prototype","hasOwnProperty","expression","_cache","Data","data","cache","p","operators","prefix","separator","named","empty_name_separator","encode","EXPRESSION_PATTERN","VARIABLE_PATTERN","VARIABLE_NAME_PATTERN","LITERAL_PATTERN","expand","opts","options","operator","type","variables","buffer","d","variable","i","get","name","strict","Error","val","length","push","maxlength","explode","join","expandNamed","result","_encode","_name","_value","l","substring","undefined","expandUnnamed","noConflict","parts","parse","ePattern","vPattern","nPattern","lPattern","pos","eMatch","vMatch","checkLiteral","literal","match","lastIndex","exec","index","split","parseInt","key","encodeReserved","value","String","toString","call","template","expansion"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,WAAUA,IAAV,EAAgBC,OAAhB,EAAyB;AACxB,eADwB,CAExB;;AACA,MAAI,OAAOC,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,CAACC,OAAzC,EAAkD;AAChD;AACAD,IAAAA,MAAM,CAACC,OAAP,GAAiBF,OAAO,CAACG,OAAO,CAAC,OAAD,CAAR,CAAxB;AACD,GAHD,MAGO,IAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA3C,EAAgD;AACrD;AACAD,IAAAA,MAAM,CAAC,CAAC,OAAD,CAAD,EAAYJ,OAAZ,CAAN;AACD,GAHM,MAGA;AACL;AACAD,IAAAA,IAAI,CAACO,WAAL,GAAmBN,OAAO,CAACD,IAAI,CAACQ,GAAN,EAAWR,IAAX,CAA1B;AACD;AACF,CAbA,EAaC,IAbD,EAaO,UAAUQ,GAAV,EAAeR,IAAf,EAAqB;AAC3B,eAD2B,CAE3B;;AACA;AAEA;;AACA,MAAIS,YAAY,GAAGT,IAAI,IAAIA,IAAI,CAACO,WAAhC;;AAEA,MAAIG,MAAM,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAA9B;;AACA,WAASN,WAAT,CAAqBO,UAArB,EAAiC;AAC/B;AACA,QAAIP,WAAW,CAACQ,MAAZ,CAAmBD,UAAnB,CAAJ,EAAoC;AAClC,aAAOP,WAAW,CAACQ,MAAZ,CAAmBD,UAAnB,CAAP;AACD,KAJ8B,CAM/B;;;AACA,QAAI,EAAE,gBAAgBP,WAAlB,CAAJ,EAAoC;AAClC,aAAO,IAAIA,WAAJ,CAAgBO,UAAhB,CAAP;AACD;;AAED,SAAKA,UAAL,GAAkBA,UAAlB;AACAP,IAAAA,WAAW,CAACQ,MAAZ,CAAmBD,UAAnB,IAAiC,IAAjC;AACA,WAAO,IAAP;AACD;;AAED,WAASE,IAAT,CAAcC,IAAd,EAAoB;AAClB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAa,EAAb;AACD;;AAED,MAAIC,CAAC,GAAGZ,WAAW,CAACK,SAApB,CA9B2B,CA+B3B;;AACA,MAAIQ,SAAS,GAAG;AACd;AACA,QAAK;AACHC,MAAAA,MAAM,EAAE,EADL;AAEHC,MAAAA,SAAS,EAAE,GAFR;AAGHC,MAAAA,KAAK,EAAE,KAHJ;AAIHC,MAAAA,oBAAoB,EAAE,KAJnB;AAKHC,MAAAA,MAAM,EAAG;AALN,KAFS;AASd;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,EADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,KAHH;AAIJC,MAAAA,oBAAoB,EAAE,KAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KAVQ;AAiBd;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,GADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,KAHH;AAIJC,MAAAA,oBAAoB,EAAE,KAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KAlBQ;AAyBd;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,GADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,KAHH;AAIJC,MAAAA,oBAAoB,EAAE,KAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KA1BQ;AAiCd;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,GADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,KAHH;AAIJC,MAAAA,oBAAoB,EAAE,KAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KAlCQ;AAyCd;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,GADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,IAHH;AAIJC,MAAAA,oBAAoB,EAAE,KAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KA1CQ;AAiDd;AACA;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,GADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,IAHH;AAIJC,MAAAA,oBAAoB,EAAE,IAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KAnDQ;AA0Dd;AACA;AACA,SAAM;AACJJ,MAAAA,MAAM,EAAE,GADJ;AAEJC,MAAAA,SAAS,EAAE,GAFP;AAGJC,MAAAA,KAAK,EAAE,IAHH;AAIJC,MAAAA,oBAAoB,EAAE,IAJlB;AAKJC,MAAAA,MAAM,EAAG;AALL,KA5DQ,CAoEd;AACA;;AArEc,GAAhB,CAhC2B,CAwG3B;;AACAlB,EAAAA,WAAW,CAACQ,MAAZ,GAAqB,EAArB,CAzG2B,CA0G3B;;AACAR,EAAAA,WAAW,CAACmB,kBAAZ,GAAiC,oCAAjC,CA3G2B,CA4G3B;;AACAnB,EAAAA,WAAW,CAACoB,gBAAZ,GAA+B,wCAA/B,CA7G2B,CA8G3B;;AACApB,EAAAA,WAAW,CAACqB,qBAAZ,GAAoC,iBAApC,CA/G2B,CAgH3B;;AACArB,EAAAA,WAAW,CAACsB,eAAZ,GAA8B,eAA9B,CAjH2B,CAmH3B;;AACAtB,EAAAA,WAAW,CAACuB,MAAZ,GAAqB,UAAShB,UAAT,EAAqBG,IAArB,EAA2Bc,IAA3B,EAAiC;AACpD;AACA,QAAIC,OAAO,GAAGZ,SAAS,CAACN,UAAU,CAACmB,QAAZ,CAAvB,CAFoD,CAGpD;;AACA,QAAIC,IAAI,GAAGF,OAAO,CAACT,KAAR,GAAgB,OAAhB,GAA0B,SAArC,CAJoD,CAKpD;;AACA,QAAIY,SAAS,GAAGrB,UAAU,CAACqB,SAA3B,CANoD,CAOpD;;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,CAAJ,EAAOC,QAAP,EAAiBC,CAAjB;;AAEA,SAAKA,CAAC,GAAG,CAAT,EAAaD,QAAQ,GAAGH,SAAS,CAACI,CAAD,CAAjC,EAAuCA,CAAC,EAAxC,EAA4C;AAC1C;AACAF,MAAAA,CAAC,GAAGpB,IAAI,CAACuB,GAAL,CAASF,QAAQ,CAACG,IAAlB,CAAJ;;AACA,UAAIJ,CAAC,CAACH,IAAF,KAAW,CAAX,IAAgBH,IAAhB,IAAwBA,IAAI,CAACW,MAAjC,EAAyC;AACrC,cAAM,IAAIC,KAAJ,CAAU,2CAA2CL,QAAQ,CAACG,IAApD,GAA2D,GAArE,CAAN;AACH;;AACD,UAAI,CAACJ,CAAC,CAACO,GAAF,CAAMC,MAAX,EAAmB;AACjB,YAAIR,CAAC,CAACH,IAAN,EAAY;AACV;AACA;AACAE,UAAAA,MAAM,CAACU,IAAP,CAAY,EAAZ;AACD,SALgB,CAMjB;;;AACA;AACD;;AAED,UAAIT,CAAC,CAACH,IAAF,GAAS,CAAT,IAAcI,QAAQ,CAACS,SAA3B,EAAsC;AACpC;AACA,cAAM,IAAIJ,KAAJ,CAAU,qEAAqEL,QAAQ,CAACG,IAA9E,GAAqF,GAA/F,CAAN;AACD,OAnByC,CAqB1C;;;AACAL,MAAAA,MAAM,CAACU,IAAP,CAAYvC,WAAW,CAAC,WAAW2B,IAAZ,CAAX,CACVG,CADU,EAEVL,OAFU,EAGVM,QAAQ,CAACU,OAHC,EAIVV,QAAQ,CAACU,OAAT,IAAoBhB,OAAO,CAACV,SAA5B,IAAyC,GAJ/B,EAKVgB,QAAQ,CAACS,SALC,EAMVT,QAAQ,CAACG,IANC,CAAZ;AAQD;;AAED,QAAIL,MAAM,CAACS,MAAX,EAAmB;AACjB,aAAOb,OAAO,CAACX,MAAR,GAAiBe,MAAM,CAACa,IAAP,CAAYjB,OAAO,CAACV,SAApB,CAAxB;AACD,KAFD,MAEO;AACL;AACA,aAAO,EAAP;AACD;AACF,GAjDD,CApH2B,CAsK3B;;;AACAf,EAAAA,WAAW,CAAC2C,WAAZ,GAA0B,UAASb,CAAT,EAAYL,OAAZ,EAAqBgB,OAArB,EAA8B1B,SAA9B,EAAyCuB,MAAzC,EAAiDJ,IAAjD,EAAuD;AAC/E;AACA,QAAIU,MAAM,GAAG,EAAb,CAF+E,CAG/E;;AACA,QAAI1B,MAAM,GAAGO,OAAO,CAACP,MAArB;AACA,QAAID,oBAAoB,GAAGQ,OAAO,CAACR,oBAAnC,CAL+E,CAM/E;;AACA,QAAI4B,OAAO,GAAG,CAACf,CAAC,CAACZ,MAAD,CAAD,CAAUoB,MAAzB,CAP+E,CAQ/E;;;AACA,QAAIQ,KAAK,GAAGhB,CAAC,CAACH,IAAF,KAAW,CAAX,GAAe,EAAf,GAAmB1B,GAAG,CAACiB,MAAD,CAAH,CAAYgB,IAAZ,CAA/B;;AACA,QAAIa,MAAJ,EAAYf,CAAZ,EAAegB,CAAf,CAV+E,CAY/E;;;AACA,SAAKhB,CAAC,GAAG,CAAJ,EAAOgB,CAAC,GAAGlB,CAAC,CAACO,GAAF,CAAMC,MAAtB,EAA8BN,CAAC,GAAGgB,CAAlC,EAAqChB,CAAC,EAAtC,EAA0C;AACxC,UAAIM,MAAJ,EAAY;AACV;AACAS,QAAAA,MAAM,GAAG9C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,EAAYiB,SAAZ,CAAsB,CAAtB,EAAyBX,MAAzB,CAAZ,CAAT;;AACA,YAAIR,CAAC,CAACH,IAAF,KAAW,CAAf,EAAkB;AAChB;AACAmB,UAAAA,KAAK,GAAG7C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,EAAYiB,SAAZ,CAAsB,CAAtB,EAAyBX,MAAzB,CAAZ,CAAR;AACD;AACF,OAPD,MAOO,IAAIO,OAAJ,EAAa;AAClB;AACAE,QAAAA,MAAM,GAAG9C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,CAAZ,CAAT;;AACA,YAAIF,CAAC,CAACH,IAAF,KAAW,CAAf,EAAkB;AAChB;AACAmB,UAAAA,KAAK,GAAG7C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,CAAZ,CAAR;AACAF,UAAAA,CAAC,CAACZ,MAAD,CAAD,CAAUqB,IAAV,CAAe,CAACO,KAAD,EAAQC,MAAR,CAAf;AACD,SAJD,MAIO;AACL;AACAjB,UAAAA,CAAC,CAACZ,MAAD,CAAD,CAAUqB,IAAV,CAAe,CAACW,SAAD,EAAYH,MAAZ,CAAf;AACD;AACF,OAXM,MAWA;AACL;AACAA,QAAAA,MAAM,GAAGjB,CAAC,CAACZ,MAAD,CAAD,CAAUc,CAAV,EAAa,CAAb,CAAT;;AACA,YAAIF,CAAC,CAACH,IAAF,KAAW,CAAf,EAAkB;AAChBmB,UAAAA,KAAK,GAAGhB,CAAC,CAACZ,MAAD,CAAD,CAAUc,CAAV,EAAa,CAAb,CAAR;AACD;AACF;;AAED,UAAIY,MAAJ,EAAY;AACV;AACAA,QAAAA,MAAM,IAAI7B,SAAV;AACD;;AAED,UAAI,CAAC0B,OAAL,EAAc;AACZ,YAAI,CAACT,CAAL,EAAQ;AACN;AACAY,UAAAA,MAAM,IAAI3C,GAAG,CAACiB,MAAD,CAAH,CAAYgB,IAAZ,KAAqBjB,oBAAoB,IAAI8B,MAAxB,GAAiC,GAAjC,GAAuC,EAA5D,CAAV;AACD;;AAED,YAAIjB,CAAC,CAACH,IAAF,KAAW,CAAf,EAAkB;AAChB;AACAiB,UAAAA,MAAM,IAAIE,KAAK,GAAG,GAAlB;AACD;;AAEDF,QAAAA,MAAM,IAAIG,MAAV;AACD,OAZD,MAYO;AACL;AACAH,QAAAA,MAAM,IAAIE,KAAK,IAAI7B,oBAAoB,IAAI8B,MAAxB,GAAiC,GAAjC,GAAuC,EAA3C,CAAL,GAAsDA,MAAhE;AACD;AACF;;AAED,WAAOH,MAAP;AACD,GAhED,CAvK2B,CAwO3B;;;AACA5C,EAAAA,WAAW,CAACmD,aAAZ,GAA4B,UAASrB,CAAT,EAAYL,OAAZ,EAAqBgB,OAArB,EAA8B1B,SAA9B,EAAyCuB,MAAzC,EAAiD;AAC3E;AACA,QAAIM,MAAM,GAAG,EAAb,CAF2E,CAG3E;;AACA,QAAI1B,MAAM,GAAGO,OAAO,CAACP,MAArB;AACA,QAAID,oBAAoB,GAAGQ,OAAO,CAACR,oBAAnC,CAL2E,CAM3E;;AACA,QAAI4B,OAAO,GAAG,CAACf,CAAC,CAACZ,MAAD,CAAD,CAAUoB,MAAzB;;AACA,QAAIQ,KAAJ,EAAWC,MAAX,EAAmBf,CAAnB,EAAsBgB,CAAtB,CAR2E,CAU3E;;;AACA,SAAKhB,CAAC,GAAG,CAAJ,EAAOgB,CAAC,GAAGlB,CAAC,CAACO,GAAF,CAAMC,MAAtB,EAA8BN,CAAC,GAAGgB,CAAlC,EAAqChB,CAAC,EAAtC,EAA0C;AACxC,UAAIM,MAAJ,EAAY;AACV;AACAS,QAAAA,MAAM,GAAG9C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,EAAYiB,SAAZ,CAAsB,CAAtB,EAAyBX,MAAzB,CAAZ,CAAT;AACD,OAHD,MAGO,IAAIO,OAAJ,EAAa;AAClB;AACAE,QAAAA,MAAM,GAAG9C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,CAAZ,CAAT;AACAF,QAAAA,CAAC,CAACZ,MAAD,CAAD,CAAUqB,IAAV,CAAe,CACbT,CAAC,CAACH,IAAF,KAAW,CAAX,GAAe1B,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,CAAZ,CAAf,GAA0CkB,SAD7B,EAEbH,MAFa,CAAf;AAID,OAPM,MAOA;AACL;AACAA,QAAAA,MAAM,GAAGjB,CAAC,CAACZ,MAAD,CAAD,CAAUc,CAAV,EAAa,CAAb,CAAT;AACD;;AAED,UAAIY,MAAJ,EAAY;AACV;AACAA,QAAAA,MAAM,IAAI7B,SAAV;AACD;;AAED,UAAIe,CAAC,CAACH,IAAF,KAAW,CAAf,EAAkB;AAChB,YAAIW,MAAJ,EAAY;AACV;AACAQ,UAAAA,KAAK,GAAG7C,GAAG,CAACiB,MAAD,CAAH,CAAYY,CAAC,CAACO,GAAF,CAAML,CAAN,EAAS,CAAT,EAAYiB,SAAZ,CAAsB,CAAtB,EAAyBX,MAAzB,CAAZ,CAAR;AACD,SAHD,MAGO;AACL;AACAQ,UAAAA,KAAK,GAAGhB,CAAC,CAACZ,MAAD,CAAD,CAAUc,CAAV,EAAa,CAAb,CAAR;AACD;;AAEDY,QAAAA,MAAM,IAAIE,KAAV;;AACA,YAAIL,OAAJ,EAAa;AACX;AACAG,UAAAA,MAAM,IAAK3B,oBAAoB,IAAI8B,MAAxB,GAAiC,GAAjC,GAAuC,EAAlD;AACD,SAHD,MAGO;AACL;AACAH,UAAAA,MAAM,IAAI,GAAV;AACD;AACF;;AAEDA,MAAAA,MAAM,IAAIG,MAAV;AACD;;AAED,WAAOH,MAAP;AACD,GAvDD;;AAyDA5C,EAAAA,WAAW,CAACoD,UAAZ,GAAyB,YAAW;AAClC,QAAI3D,IAAI,CAACO,WAAL,KAAqBA,WAAzB,EAAsC;AACpCP,MAAAA,IAAI,CAACO,WAAL,GAAmBE,YAAnB;AACD;;AAED,WAAOF,WAAP;AACD,GAND,CAlS2B,CA0S3B;;;AACAY,EAAAA,CAAC,CAACW,MAAF,GAAW,UAASb,IAAT,EAAec,IAAf,EAAqB;AAC9B,QAAIoB,MAAM,GAAG,EAAb;;AAEA,QAAI,CAAC,KAAKS,KAAN,IAAe,CAAC,KAAKA,KAAL,CAAWf,MAA/B,EAAuC;AACrC;AACA,WAAKgB,KAAL;AACD;;AAED,QAAI,EAAE5C,IAAI,YAAYD,IAAlB,CAAJ,EAA6B;AAC3B;AACA;AACAC,MAAAA,IAAI,GAAG,IAAID,IAAJ,CAASC,IAAT,CAAP;AACD;;AAED,SAAK,IAAIsB,CAAC,GAAG,CAAR,EAAWgB,CAAC,GAAG,KAAKK,KAAL,CAAWf,MAA/B,EAAuCN,CAAC,GAAGgB,CAA3C,EAA8ChB,CAAC,EAA/C,EAAmD;AACjD;AACAY,MAAAA,MAAM,IAAI,OAAO,KAAKS,KAAL,CAAWrB,CAAX,CAAP,KAAyB,QAAzB,CACR;AADQ,QAEN,KAAKqB,KAAL,CAAWrB,CAAX,CAFM,CAGR;AAHQ,QAINhC,WAAW,CAACuB,MAAZ,CAAmB,KAAK8B,KAAL,CAAWrB,CAAX,CAAnB,EAAkCtB,IAAlC,EAAwCc,IAAxC,CAJJ;AAKA;AACD;;AAED,WAAOoB,MAAP;AACD,GAzBD,CA3S2B,CAqU3B;;;AACAhC,EAAAA,CAAC,CAAC0C,KAAF,GAAU,YAAW;AACnB;AACA,QAAI/C,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIgD,QAAQ,GAAGvD,WAAW,CAACmB,kBAA3B;AACA,QAAIqC,QAAQ,GAAGxD,WAAW,CAACoB,gBAA3B;AACA,QAAIqC,QAAQ,GAAGzD,WAAW,CAACqB,qBAA3B;AACA,QAAIqC,QAAQ,GAAG1D,WAAW,CAACsB,eAA3B,CANmB,CAOnB;;AACA,QAAI+B,KAAK,GAAG,EAAZ,CARmB,CASjB;;AACF,QAAIM,GAAG,GAAG,CAAV;AACA,QAAI/B,SAAJ,EAAegC,MAAf,EAAuBC,MAAvB;;AAEA,QAAIC,YAAY,GAAG,UAASC,OAAT,EAAkB;AACnC,UAAIA,OAAO,CAACC,KAAR,CAAcN,QAAd,CAAJ,EAA6B;AAC3B,cAAM,IAAItB,KAAJ,CAAU,sBAAsB2B,OAAtB,GAAgC,GAA1C,CAAN;AACD;;AACD,aAAOA,OAAP;AACD,KALD,CAbmB,CAoBnB;AACA;;;AACAR,IAAAA,QAAQ,CAACU,SAAT,GAAqB,CAArB,CAtBmB,CAuBnB;AACA;;AACA,WAAO,IAAP,EAAa;AACXL,MAAAA,MAAM,GAAGL,QAAQ,CAACW,IAAT,CAAc3D,UAAd,CAAT;;AACA,UAAIqD,MAAM,KAAK,IAAf,EAAqB;AACnB;AACAP,QAAAA,KAAK,CAACd,IAAN,CAAWuB,YAAY,CAACvD,UAAU,CAAC0C,SAAX,CAAqBU,GAArB,CAAD,CAAvB;AACA;AACD,OAJD,MAIO;AACL;AACAN,QAAAA,KAAK,CAACd,IAAN,CAAWuB,YAAY,CAACvD,UAAU,CAAC0C,SAAX,CAAqBU,GAArB,EAA0BC,MAAM,CAACO,KAAjC,CAAD,CAAvB;AACAR,QAAAA,GAAG,GAAGC,MAAM,CAACO,KAAP,GAAeP,MAAM,CAAC,CAAD,CAAN,CAAUtB,MAA/B;AACD;;AAED,UAAI,CAACzB,SAAS,CAAC+C,MAAM,CAAC,CAAD,CAAP,CAAd,EAA2B;AACzB,cAAM,IAAIxB,KAAJ,CAAU,uBAAuBwB,MAAM,CAAC,CAAD,CAA7B,GAAoC,QAApC,GAA+CA,MAAM,CAAC,CAAD,CAArD,GAA2D,GAArE,CAAN;AACD,OAFD,MAEO,IAAI,CAACA,MAAM,CAAC,CAAD,CAAX,EAAgB;AACrB,cAAM,IAAIxB,KAAJ,CAAU,0BAA0BwB,MAAM,CAAC,CAAD,CAAhC,GAAuC,GAAjD,CAAN;AACD,OAhBU,CAkBX;;;AACAhC,MAAAA,SAAS,GAAGgC,MAAM,CAAC,CAAD,CAAN,CAAUQ,KAAV,CAAgB,GAAhB,CAAZ;;AACA,WAAK,IAAIpC,CAAC,GAAG,CAAR,EAAWgB,CAAC,GAAGpB,SAAS,CAACU,MAA9B,EAAsCN,CAAC,GAAGgB,CAA1C,EAA6ChB,CAAC,EAA9C,EAAkD;AAChD6B,QAAAA,MAAM,GAAGjC,SAAS,CAACI,CAAD,CAAT,CAAagC,KAAb,CAAmBR,QAAnB,CAAT;;AACA,YAAIK,MAAM,KAAK,IAAf,EAAqB;AACnB,gBAAM,IAAIzB,KAAJ,CAAU,uBAAuBR,SAAS,CAACI,CAAD,CAAhC,GAAsC,QAAtC,GAAiD4B,MAAM,CAAC,CAAD,CAAvD,GAA6D,GAAvE,CAAN;AACD,SAFD,MAEO,IAAIC,MAAM,CAAC,CAAD,CAAN,CAAUG,KAAV,CAAgBP,QAAhB,CAAJ,EAA+B;AACpC,gBAAM,IAAIrB,KAAJ,CAAU,4BAA4ByB,MAAM,CAAC,CAAD,CAAlC,GAAwC,QAAxC,GAAmDD,MAAM,CAAC,CAAD,CAAzD,GAA+D,GAAzE,CAAN;AACD;;AAEDhC,QAAAA,SAAS,CAACI,CAAD,CAAT,GAAe;AACbE,UAAAA,IAAI,EAAE2B,MAAM,CAAC,CAAD,CADC;AAEbpB,UAAAA,OAAO,EAAE,CAAC,CAACoB,MAAM,CAAC,CAAD,CAFJ;AAGbrB,UAAAA,SAAS,EAAEqB,MAAM,CAAC,CAAD,CAAN,IAAaQ,QAAQ,CAACR,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ;AAHnB,SAAf;AAKD;;AAED,UAAI,CAACjC,SAAS,CAACU,MAAf,EAAuB;AACrB,cAAM,IAAIF,KAAJ,CAAU,qCAAqCwB,MAAM,CAAC,CAAD,CAA3C,GAAiD,GAA3D,CAAN;AACD;;AAEDP,MAAAA,KAAK,CAACd,IAAN,CAAW;AACThC,QAAAA,UAAU,EAAEqD,MAAM,CAAC,CAAD,CADT;AAETlC,QAAAA,QAAQ,EAAEkC,MAAM,CAAC,CAAD,CAFP;AAGThC,QAAAA,SAAS,EAAEA;AAHF,OAAX;AAKD;;AAED,QAAI,CAACyB,KAAK,CAACf,MAAX,EAAmB;AACjB;AACA;AACA;AACAe,MAAAA,KAAK,CAACd,IAAN,CAAWuB,YAAY,CAACvD,UAAD,CAAvB;AACD;;AAED,SAAK8C,KAAL,GAAaA,KAAb;AACA,WAAO,IAAP;AACD,GAhFD,CAtU2B,CAwZ3B;;;AACA5C,EAAAA,IAAI,CAACJ,SAAL,CAAe4B,GAAf,GAAqB,UAASqC,GAAT,EAAc;AACjC;AACA,QAAI5D,IAAI,GAAG,KAAKA,IAAhB,CAFiC,CAGjC;;AACA,QAAIoB,CAAC,GAAG;AACN;AACAH,MAAAA,IAAI,EAAE,CAFA;AAGN;AACAU,MAAAA,GAAG,EAAE,EAJC;AAKN;AACAnB,MAAAA,MAAM,EAAE,EANF;AAONqD,MAAAA,cAAc,EAAE;AAPV,KAAR;AASA,QAAIvC,CAAJ,EAAOgB,CAAP,EAAUwB,KAAV;;AAEA,QAAI,KAAK7D,KAAL,CAAW2D,GAAX,MAAoBpB,SAAxB,EAAmC;AACjC;AACA,aAAO,KAAKvC,KAAL,CAAW2D,GAAX,CAAP;AACD;;AAED,SAAK3D,KAAL,CAAW2D,GAAX,IAAkBxC,CAAlB;;AAEA,QAAI2C,MAAM,CAACrE,MAAM,CAACC,SAAP,CAAiBqE,QAAjB,CAA0BC,IAA1B,CAA+BjE,IAA/B,CAAD,CAAN,KAAiD,mBAArD,EAA0E;AACxE;AACA8D,MAAAA,KAAK,GAAG9D,IAAI,CAAC4D,GAAD,CAAZ;AACD,KAHD,MAGO,IAAIG,MAAM,CAACrE,MAAM,CAACC,SAAP,CAAiBqE,QAAjB,CAA0BC,IAA1B,CAA+BjE,IAAI,CAAC4D,GAAD,CAAnC,CAAD,CAAN,KAAsD,mBAA1D,EAA+E;AACpF;AACAE,MAAAA,KAAK,GAAG9D,IAAI,CAAC4D,GAAD,CAAJ,CAAUA,GAAV,CAAR;AACD,KAHM,MAGA;AACL;AACAE,MAAAA,KAAK,GAAG9D,IAAI,CAAC4D,GAAD,CAAZ;AACD,KA/BgC,CAiCjC;AACA;;;AACA,QAAIE,KAAK,KAAKtB,SAAV,IAAuBsB,KAAK,KAAK,IAArC,EAA2C;AACzC;AACA,aAAO1C,CAAP;AACD,KAHD,MAGO,IAAI2C,MAAM,CAACrE,MAAM,CAACC,SAAP,CAAiBqE,QAAjB,CAA0BC,IAA1B,CAA+BH,KAA/B,CAAD,CAAN,KAAkD,gBAAtD,EAAwE;AAC7E,WAAKxC,CAAC,GAAG,CAAJ,EAAOgB,CAAC,GAAGwB,KAAK,CAAClC,MAAtB,EAA8BN,CAAC,GAAGgB,CAAlC,EAAqChB,CAAC,EAAtC,EAA0C;AACxC,YAAIwC,KAAK,CAACxC,CAAD,CAAL,KAAakB,SAAb,IAA0BsB,KAAK,CAACxC,CAAD,CAAL,KAAa,IAA3C,EAAiD;AAC/C;AACAF,UAAAA,CAAC,CAACO,GAAF,CAAME,IAAN,CAAW,CAACW,SAAD,EAAYuB,MAAM,CAACD,KAAK,CAACxC,CAAD,CAAN,CAAlB,CAAX;AACD;AACF;;AAED,UAAIF,CAAC,CAACO,GAAF,CAAMC,MAAV,EAAkB;AAChB;AACAR,QAAAA,CAAC,CAACH,IAAF,GAAS,CAAT,CAFgB,CAEJ;AACb;AACF,KAZM,MAYA,IAAI8C,MAAM,CAACrE,MAAM,CAACC,SAAP,CAAiBqE,QAAjB,CAA0BC,IAA1B,CAA+BH,KAA/B,CAAD,CAAN,KAAkD,iBAAtD,EAAyE;AAC9E,WAAKxC,CAAL,IAAUwC,KAAV,EAAiB;AACf,YAAIrE,MAAM,CAACwE,IAAP,CAAYH,KAAZ,EAAmBxC,CAAnB,KAAyBwC,KAAK,CAACxC,CAAD,CAAL,KAAakB,SAAtC,IAAmDsB,KAAK,CAACxC,CAAD,CAAL,KAAa,IAApE,EAA0E;AACxE;AACAF,UAAAA,CAAC,CAACO,GAAF,CAAME,IAAN,CAAW,CAACP,CAAD,EAAIyC,MAAM,CAACD,KAAK,CAACxC,CAAD,CAAN,CAAV,CAAX;AACD;AACF;;AAED,UAAIF,CAAC,CAACO,GAAF,CAAMC,MAAV,EAAkB;AAChB;AACAR,QAAAA,CAAC,CAACH,IAAF,GAAS,CAAT,CAFgB,CAEJ;AACb;AACF,KAZM,MAYA;AACLG,MAAAA,CAAC,CAACH,IAAF,GAAS,CAAT,CADK,CACO;AACZ;;AACAG,MAAAA,CAAC,CAACO,GAAF,CAAME,IAAN,CAAW,CAACW,SAAD,EAAYuB,MAAM,CAACD,KAAD,CAAlB,CAAX;AACD;;AAED,WAAO1C,CAAP;AACD,GArED,CAzZ2B,CAge3B;;;AACA7B,EAAAA,GAAG,CAACsB,MAAJ,GAAa,UAAShB,UAAT,EAAqBG,IAArB,EAA2B;AACtC,QAAIkE,QAAQ,GAAG,IAAI5E,WAAJ,CAAgBO,UAAhB,CAAf;AACA,QAAIsE,SAAS,GAAGD,QAAQ,CAACrD,MAAT,CAAgBb,IAAhB,CAAhB;AAEA,WAAO,IAAIT,GAAJ,CAAQ4E,SAAR,CAAP;AACD,GALD;;AAOA,SAAO7E,WAAP;AACD,CAtfA,CAAD","sourcesContent":["/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.2\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory(require('./URI'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./URI'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URITemplate = factory(root.URI, root);\n  }\n}(this, function (URI, root) {\n  'use strict';\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URITemplate variable, if any\n  var _URITemplate = root && root.URITemplate;\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    }\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n\n  var p = URITemplate.prototype;\n  // list of operators and their defined options\n  var operators = {\n    // Simple string expansion\n    '' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Reserved character strings\n    '+' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#' : {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.' : {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/' : {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';' : {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?' : {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&' : {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    }\n\n    // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n  };\n\n  // storage for already parsed templates\n  URITemplate._cache = {};\n  // pattern to identify expressions [operator, variable-list] in template\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g;\n  // pattern to identify variables [name, explode, maxlength] in variable-list\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/;\n  // pattern to verify variable name integrity\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;\n  // pattern to verify literal integrity\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/;\n\n  // expand parsed expression (expression, not template!)\n  URITemplate.expand = function(expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator];\n    // expansion type (include keys or not)\n    var type = options.named ? 'Named' : 'Unnamed';\n    // list of variables within the expression\n    var variables = expression.variables;\n    // result buffer for evaluating the expression\n    var buffer = [];\n    var d, variable, i;\n\n    for (i = 0; (variable = variables[i]); i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n      if (d.type === 0 && opts && opts.strict) {\n          throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        }\n        // no data, no action\n        continue;\n      }\n\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      }\n\n      // expand the given variable\n      buffer.push(URITemplate['expand' + type](\n        d,\n        options,\n        variable.explode,\n        variable.explode && options.separator || ',',\n        variable.maxlength,\n        variable.name\n      ));\n    }\n\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  };\n  // expand a named variable\n  URITemplate.expandNamed = function(d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = '';\n    // peformance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    // key for named expansion\n    var _name = d.type === 2 ? '': URI[encode](name);\n    var _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n\n    return result;\n  };\n  // expand an unnamed variable\n  URITemplate.expandUnnamed = function(d, options, explode, separator, length) {\n    // variable result buffer\n    var result = '';\n    // performance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    var _name, _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([\n          d.type === 2 ? URI[encode](d.val[i][0]) : undefined,\n          _value\n        ]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n\n        result += _name;\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += (empty_name_separator || _value ? '=' : '');\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n\n      result += _value;\n    }\n\n    return result;\n  };\n\n  URITemplate.noConflict = function() {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n\n    return URITemplate;\n  };\n\n  // expand template through given data map\n  p.expand = function(data, opts) {\n    var result = '';\n\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string'\n        // literal string\n        ? this.parts[i]\n        // expression\n        : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  };\n  // parse template into action tokens\n  p.parse = function() {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN;\n    // token result buffer\n    var parts = [];\n      // position within source template\n    var pos = 0;\n    var variables, eMatch, vMatch;\n\n    var checkLiteral = function(literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n      return literal;\n    };\n\n    // RegExp is shared accross all templates,\n    // which requires a manual reset\n    ePattern.lastIndex = 0;\n    // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n    while (true) {\n      eMatch = ePattern.exec(expression);\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1]  + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0]  + '\"');\n      }\n\n      // parse variable-list\n      variables = eMatch[2].split(',');\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n\n    this.parts = parts;\n    return this;\n  };\n\n  // simplify data structures\n  Data.prototype.get = function(key) {\n    // performance crap\n    var data = this.data;\n    // cache for processed data-point\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n\n    this.cache[key] = d;\n\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    }\n\n    // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n      d.val.push([undefined, String(value)]);\n    }\n\n    return d;\n  };\n\n  // hook into URI for fluid access\n  URI.expand = function(expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n\n    return new URI(expansion);\n  };\n\n  return URITemplate;\n}));\n"]},"metadata":{},"sourceType":"script"}