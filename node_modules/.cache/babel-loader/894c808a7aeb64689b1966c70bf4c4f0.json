{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Utils = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar clone_1 = tslib_1.__importDefault(require(\"lodash/clone\"));\n\nvar randombytes_1 = tslib_1.__importDefault(require(\"randombytes\"));\n\nvar stellar_base_1 = require(\"stellar-base\");\n\nvar errors_1 = require(\"./errors\");\n\nvar Utils;\n\n(function (Utils) {\n  function buildChallengeTx(serverKeypair, clientAccountID, homeDomain, timeout, networkPassphrase) {\n    if (timeout === void 0) {\n      timeout = 300;\n    }\n\n    if (clientAccountID.startsWith(\"M\")) {\n      throw Error(\"Invalid clientAccountID: multiplexed accounts are not supported.\");\n    }\n\n    var account = new stellar_base_1.Account(serverKeypair.publicKey(), \"-1\");\n    var now = Math.floor(Date.now() / 1000);\n    var value = randombytes_1.default(48).toString(\"base64\");\n    var transaction = new stellar_base_1.TransactionBuilder(account, {\n      fee: stellar_base_1.BASE_FEE,\n      networkPassphrase: networkPassphrase,\n      timebounds: {\n        minTime: now,\n        maxTime: now + timeout\n      }\n    }).addOperation(stellar_base_1.Operation.manageData({\n      name: homeDomain + \" auth\",\n      value: value,\n      source: clientAccountID\n    })).build();\n    transaction.sign(serverKeypair);\n    return transaction.toEnvelope().toXDR(\"base64\").toString();\n  }\n\n  Utils.buildChallengeTx = buildChallengeTx;\n\n  function readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains) {\n    var _a;\n\n    if (serverAccountID.startsWith(\"M\")) {\n      throw Error(\"Invalid serverAccountID: multiplexed accounts are not supported.\");\n    }\n\n    var transaction = stellar_base_1.TransactionBuilder.fromXDR(challengeTx, networkPassphrase);\n\n    if (!(transaction instanceof stellar_base_1.Transaction)) {\n      throw new errors_1.InvalidSep10ChallengeError(\"Invalid challenge: expected a Transaction but received a FeeBumpTransaction\");\n    }\n\n    var sequence = Number.parseInt(transaction.sequence, 10);\n\n    if (sequence !== 0) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction sequence number should be zero\");\n    }\n\n    if (transaction.source !== serverAccountID) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction source account is not equal to the server's account\");\n    }\n\n    if (transaction.operations.length < 1) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction should contain at least one operation\");\n    }\n\n    var _b = transaction.operations,\n        operation = _b[0],\n        subsequentOperations = _b.slice(1);\n\n    if (!operation.source) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation should contain a source account\");\n    }\n\n    var clientAccountID = operation.source;\n\n    if (operation.type !== \"manageData\") {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation type should be 'manageData'\");\n    }\n\n    if (transaction.timeBounds && Number.parseInt((_a = transaction.timeBounds) === null || _a === void 0 ? void 0 : _a.maxTime, 10) === stellar_base_1.TimeoutInfinite) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction requires non-infinite timebounds\");\n    }\n\n    if (!validateTimebounds(transaction)) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction has expired\");\n    }\n\n    if (Buffer.from(operation.value.toString(), \"base64\").length !== 48) {\n      throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation value should be a 64 bytes base64 random string\");\n    }\n\n    if (!homeDomains) {\n      throw new errors_1.InvalidSep10ChallengeError(\"Invalid homeDomains: a home domain must be provided for verification\");\n    }\n\n    var matchedHomeDomain;\n\n    if (typeof homeDomains === \"string\") {\n      if (homeDomains + \" auth\" === operation.name) {\n        matchedHomeDomain = homeDomains;\n      }\n    } else if (Array.isArray(homeDomains)) {\n      matchedHomeDomain = homeDomains.find(function (domain) {\n        return domain + \" auth\" === operation.name;\n      });\n    } else {\n      throw new errors_1.InvalidSep10ChallengeError(\"Invalid homeDomains: homeDomains type is \" + typeof homeDomains + \" but should be a string or an array\");\n    }\n\n    if (!matchedHomeDomain) {\n      throw new errors_1.InvalidSep10ChallengeError(\"Invalid homeDomains: the transaction's operation key name does not match the expected home domain\");\n    }\n\n    for (var _i = 0, subsequentOperations_1 = subsequentOperations; _i < subsequentOperations_1.length; _i++) {\n      var op = subsequentOperations_1[_i];\n\n      if (op.type !== \"manageData\") {\n        throw new errors_1.InvalidSep10ChallengeError(\"The transaction has operations that are not of type 'manageData'\");\n      }\n\n      if (op.source !== serverAccountID) {\n        throw new errors_1.InvalidSep10ChallengeError(\"The transaction has operations that are unrecognized\");\n      }\n    }\n\n    return {\n      tx: transaction,\n      clientAccountID: clientAccountID,\n      matchedHomeDomain: matchedHomeDomain\n    };\n  }\n\n  Utils.readChallengeTx = readChallengeTx;\n\n  function verifyChallengeTxThreshold(challengeTx, serverAccountID, networkPassphrase, threshold, signerSummary, homeDomains) {\n    var _a;\n\n    var signers = signerSummary.map(function (signer) {\n      return signer.key;\n    });\n    var signersFound = verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains);\n    var weight = 0;\n\n    var _loop_1 = function (signer) {\n      var sigWeight = ((_a = signerSummary.find(function (s) {\n        return s.key === signer;\n      })) === null || _a === void 0 ? void 0 : _a.weight) || 0;\n      weight += sigWeight;\n    };\n\n    for (var _i = 0, signersFound_1 = signersFound; _i < signersFound_1.length; _i++) {\n      var signer = signersFound_1[_i];\n\n      _loop_1(signer);\n    }\n\n    if (weight < threshold) {\n      throw new errors_1.InvalidSep10ChallengeError(\"signers with weight \" + weight + \" do not meet threshold \" + threshold + \"\\\"\");\n    }\n\n    return signersFound;\n  }\n\n  Utils.verifyChallengeTxThreshold = verifyChallengeTxThreshold;\n\n  function verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains) {\n    var tx = readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains).tx;\n    var serverKP;\n\n    try {\n      serverKP = stellar_base_1.Keypair.fromPublicKey(serverAccountID);\n    } catch (err) {\n      throw new Error(\"Couldn't infer keypair from the provided 'serverAccountID': \" + err.message);\n    }\n\n    var clientSigners = new Set();\n\n    for (var _i = 0, signers_1 = signers; _i < signers_1.length; _i++) {\n      var signer = signers_1[_i];\n\n      if (signer === serverKP.publicKey()) {\n        continue;\n      }\n\n      if (signer.charAt(0) !== \"G\") {\n        continue;\n      }\n\n      clientSigners.add(signer);\n    }\n\n    if (clientSigners.size === 0) {\n      throw new errors_1.InvalidSep10ChallengeError(\"No verifiable client signers provided, at least one G... address must be provided\");\n    }\n\n    var allSigners = tslib_1.__spreadArrays([serverKP.publicKey()], Array.from(clientSigners));\n\n    var signersFound = gatherTxSigners(tx, allSigners);\n\n    if (signersFound.indexOf(serverKP.publicKey()) === -1) {\n      throw new errors_1.InvalidSep10ChallengeError(\"Transaction not signed by server: '\" + serverKP.publicKey() + \"'\");\n    }\n\n    if (signersFound.length === 1) {\n      throw new errors_1.InvalidSep10ChallengeError(\"None of the given signers match the transaction signatures\");\n    }\n\n    if (signersFound.length !== tx.signatures.length) {\n      throw new errors_1.InvalidSep10ChallengeError(\"Transaction has unrecognized signatures\");\n    }\n\n    signersFound.splice(signersFound.indexOf(serverKP.publicKey()), 1);\n    return signersFound;\n  }\n\n  Utils.verifyChallengeTxSigners = verifyChallengeTxSigners;\n\n  function verifyTxSignedBy(transaction, accountID) {\n    return gatherTxSigners(transaction, [accountID]).length !== 0;\n  }\n\n  Utils.verifyTxSignedBy = verifyTxSignedBy;\n\n  function gatherTxSigners(transaction, signers) {\n    var hashedSignatureBase = transaction.hash();\n    var txSignatures = clone_1.default(transaction.signatures);\n    var signersFound = new Set();\n\n    for (var _i = 0, signers_2 = signers; _i < signers_2.length; _i++) {\n      var signer = signers_2[_i];\n\n      if (txSignatures.length === 0) {\n        break;\n      }\n\n      var keypair = void 0;\n\n      try {\n        keypair = stellar_base_1.Keypair.fromPublicKey(signer);\n      } catch (err) {\n        throw new errors_1.InvalidSep10ChallengeError(\"Signer is not a valid address: \" + err.message);\n      }\n\n      for (var i = 0; i < txSignatures.length; i++) {\n        var decSig = txSignatures[i];\n\n        if (!decSig.hint().equals(keypair.signatureHint())) {\n          continue;\n        }\n\n        if (keypair.verify(hashedSignatureBase, decSig.signature())) {\n          signersFound.add(signer);\n          txSignatures.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    return Array.from(signersFound);\n  }\n\n  Utils.gatherTxSigners = gatherTxSigners;\n\n  function validateTimebounds(transaction) {\n    if (!transaction.timeBounds) {\n      return false;\n    }\n\n    var now = Math.floor(Date.now() / 1000);\n    var _a = transaction.timeBounds,\n        minTime = _a.minTime,\n        maxTime = _a.maxTime;\n    return now >= Number.parseInt(minTime, 10) && now <= Number.parseInt(maxTime, 10);\n  }\n})(Utils = exports.Utils || (exports.Utils = {}));","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAUA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAMA,IAAiB,KAAjB;;AAAA,CAAA,UAAiB,KAAjB,EAAsB;AAoBpB,WAAgB,gBAAhB,CACE,aADF,EAEE,eAFF,EAGE,UAHF,EAIE,OAJF,EAKE,iBALF,EAK2B;AADzB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,GAAA;AAAqB;;AAGrB,QAAI,eAAe,CAAC,UAAhB,CAA2B,GAA3B,CAAJ,EAAqC;AACnC,YAAM,KAAK,CACT,kEADS,CAAX;AAGD;;AAED,QAAM,OAAO,GAAG,IAAI,cAAA,CAAA,OAAJ,CAAY,aAAa,CAAC,SAAd,EAAZ,EAAuC,IAAvC,CAAhB;AACA,QAAM,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,KAAa,IAAxB,CAAZ;AAOA,QAAM,KAAK,GAAG,aAAA,CAAA,OAAA,CAAY,EAAZ,EAAgB,QAAhB,CAAyB,QAAzB,CAAd;AAEA,QAAM,WAAW,GAAG,IAAI,cAAA,CAAA,kBAAJ,CAAuB,OAAvB,EAAgC;AAClD,MAAA,GAAG,EAAE,cAAA,CAAA,QAD6C;AAElD,MAAA,iBAAiB,EAAA,iBAFiC;AAGlD,MAAA,UAAU,EAAE;AACV,QAAA,OAAO,EAAE,GADC;AAEV,QAAA,OAAO,EAAE,GAAG,GAAG;AAFL;AAHsC,KAAhC,EAQjB,YARiB,CAShB,cAAA,CAAA,SAAA,CAAU,UAAV,CAAqB;AACnB,MAAA,IAAI,EAAK,UAAU,GAAA,OADA;AAEnB,MAAA,KAAK,EAAA,KAFc;AAGnB,MAAA,MAAM,EAAE;AAHW,KAArB,CATgB,EAejB,KAfiB,EAApB;AAiBA,IAAA,WAAW,CAAC,IAAZ,CAAiB,aAAjB;AAEA,WAAO,WAAW,CACf,UADI,GAEJ,KAFI,CAEE,QAFF,EAGJ,QAHI,EAAP;AAID;;AA9Ce,EAAA,KAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAqEhB,WAAgB,eAAhB,CACE,WADF,EAEE,eAFF,EAGE,iBAHF,EAIE,WAJF,EAIgC;;;AAE9B,QAAI,eAAe,CAAC,UAAhB,CAA2B,GAA3B,CAAJ,EAAqC;AACnC,YAAM,KAAK,CACT,kEADS,CAAX;AAGD;;AAED,QAAM,WAAW,GAAG,cAAA,CAAA,kBAAA,CAAmB,OAAnB,CAClB,WADkB,EAElB,iBAFkB,CAApB;;AAKA,QAAI,EAAE,WAAW,YAAY,cAAA,CAAA,WAAzB,CAAJ,EAA2C;AACzC,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,6EADI,CAAN;AAGD;;AAGD,QAAM,QAAQ,GAAG,MAAM,CAAC,QAAP,CAAgB,WAAW,CAAC,QAA5B,EAAsC,EAAtC,CAAjB;;AAEA,QAAI,QAAQ,KAAK,CAAjB,EAAoB;AAClB,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,gDADI,CAAN;AAGD;;AAGD,QAAI,WAAW,CAAC,MAAZ,KAAuB,eAA3B,EAA4C;AAC1C,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,qEADI,CAAN;AAGD;;AAGD,QAAI,WAAW,CAAC,UAAZ,CAAuB,MAAvB,GAAgC,CAApC,EAAuC;AACrC,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,uDADI,CAAN;AAGD;;AAEK,QAAA,EAAA,GAAuC,WAAW,CAAC,UAAnD;AAAA,QAAC,SAAS,GAAA,EAAA,CAAA,CAAA,CAAV;AAAA,QAAe,oBAAoB,GAAA,EAAA,CAAA,KAAA,CAAA,CAAA,CAAnC;;AAEN,QAAI,CAAC,SAAS,CAAC,MAAf,EAAuB;AACrB,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,6DADI,CAAN;AAGD;;AACD,QAAM,eAAe,GAAW,SAAS,CAAC,MAA1C;;AAEA,QAAI,SAAS,CAAC,IAAV,KAAmB,YAAvB,EAAqC;AACnC,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,yDADI,CAAN;AAGD;;AAGD,QACE,WAAW,CAAC,UAAZ,IACA,MAAM,CAAC,QAAP,CAAe,CAAA,EAAA,GAAC,WAAW,CAAC,UAAb,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,KAAA,CAAvB,GAAuB,EAAA,CAAE,OAAxC,EAAiD,EAAjD,MAAyD,cAAA,CAAA,eAF3D,EAGE;AACA,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,kDADI,CAAN;AAGD;;AAED,QAAI,CAAC,kBAAkB,CAAC,WAAD,CAAvB,EAAsC;AACpC,YAAM,IAAI,QAAA,CAAA,0BAAJ,CAA+B,6BAA/B,CAAN;AACD;;AAGD,QAAI,MAAM,CAAC,IAAP,CAAY,SAAS,CAAC,KAAV,CAAgB,QAAhB,EAAZ,EAAwC,QAAxC,EAAkD,MAAlD,KAA6D,EAAjE,EAAqE;AACnE,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,6EADI,CAAN;AAGD;;AAGD,QAAI,CAAC,WAAL,EAAkB;AAChB,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,sEADI,CAAN;AAGD;;AAED,QAAI,iBAAJ;;AAEA,QAAI,OAAO,WAAP,KAAuB,QAA3B,EAAqC;AACnC,UAAO,WAAW,GAAA,OAAX,KAAuB,SAAS,CAAC,IAAxC,EAA8C;AAC5C,QAAA,iBAAiB,GAAG,WAApB;AACD;AACF,KAJD,MAIO,IAAI,KAAK,CAAC,OAAN,CAAc,WAAd,CAAJ,EAAgC;AACrC,MAAA,iBAAiB,GAAG,WAAW,CAAC,IAAZ,CAClB,UAAC,MAAD,EAAO;AAAK,eAAG,MAAM,GAAA,OAAN,KAAkB,SAAS,CAA9B,IAAA;AAAmC,OAD7B,CAApB;AAGD,KAJM,MAIA;AACL,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,8CAA4C,OAAO,WAAnD,GAA8D,qCAD1D,CAAN;AAGD;;AAED,QAAI,CAAC,iBAAL,EAAwB;AACtB,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,mGADI,CAAN;AAGD;;AAGD,SAAiB,IAAA,EAAA,GAAA,CAAA,EAAA,sBAAA,GAAA,oBAAjB,EAAiB,EAAA,GAAA,sBAAA,CAAA,MAAjB,EAAiB,EAAA,EAAjB,EAAuC;AAAlC,UAAM,EAAE,GAAA,sBAAA,CAAA,EAAA,CAAR;;AACH,UAAI,EAAE,CAAC,IAAH,KAAY,YAAhB,EAA8B;AAC5B,cAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,kEADI,CAAN;AAGD;;AACD,UAAI,EAAE,CAAC,MAAH,KAAc,eAAlB,EAAmC;AACjC,cAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,sDADI,CAAN;AAGD;AACF;;AAED,WAAO;AAAE,MAAA,EAAE,EAAE,WAAN;AAAmB,MAAA,eAAe,EAAA,eAAlC;AAAoC,MAAA,iBAAiB,EAAA;AAArD,KAAP;AACD;;AA9He,EAAA,KAAA,CAAA,eAAA,GAAe,eAAf;;AAuMhB,WAAgB,0BAAhB,CACE,WADF,EAEE,eAFF,EAGE,iBAHF,EAIE,SAJF,EAKE,aALF,EAME,WANF,EAMgC;;;AAE9B,QAAM,OAAO,GAAG,aAAa,CAAC,GAAd,CAAkB,UAAC,MAAD,EAAO;AAAK,aAAA,MAAM,CAAN,GAAA;AAAU,KAAxC,CAAhB;AAEA,QAAM,YAAY,GAAG,wBAAwB,CAC3C,WAD2C,EAE3C,eAF2C,EAG3C,iBAH2C,EAI3C,OAJ2C,EAK3C,WAL2C,CAA7C;AAQA,QAAI,MAAM,GAAG,CAAb;;4BACW,M,EAAM;AACf,UAAM,SAAS,GACb,CAAA,CAAA,EAAA,GAAA,aAAa,CAAC,IAAd,CAAmB,UAAC,CAAD,EAAE;AAAK,eAAA,CAAC,CAAC,GAAF,KAAA,MAAA;AAAgB,OAA1C,CAAA,MAA2C,IAA3C,IAA2C,EAAA,KAAA,KAAA,CAA3C,GAA2C,KAAA,CAA3C,GAA2C,EAAA,CAAE,MAA7C,KAAuD,CADzD;AAEA,MAAA,MAAM,IAAI,SAAV;;;AAHF,SAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,cAAA,GAAA,YAArB,EAAqB,EAAA,GAAA,cAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAiC;AAA5B,UAAM,MAAM,GAAA,cAAA,CAAA,EAAA,CAAZ;;cAAM,M;AAIV;;AAED,QAAI,MAAM,GAAG,SAAb,EAAwB;AACtB,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,yBAAuB,MAAvB,GAA6B,yBAA7B,GAAuD,SAAvD,GAAgE,IAD5D,CAAN;AAGD;;AAED,WAAO,YAAP;AACD;;AAhCe,EAAA,KAAA,CAAA,0BAAA,GAA0B,0BAA1B;;AA0FhB,WAAgB,wBAAhB,CACE,WADF,EAEE,eAFF,EAGE,iBAHF,EAIE,OAJF,EAKE,WALF,EAKgC;AAGtB,QAAA,EAAE,GAAK,eAAe,CAC5B,WAD4B,EAE5B,eAF4B,EAG5B,iBAH4B,EAI5B,WAJ4B,CAAf,CAAL,EAAF;AAQR,QAAI,QAAJ;;AACA,QAAI;AACF,MAAA,QAAQ,GAAG,cAAA,CAAA,OAAA,CAAQ,aAAR,CAAsB,eAAtB,CAAX;AACD,KAFD,CAEE,OAAO,GAAP,EAAY;AACZ,YAAM,IAAI,KAAJ,CACJ,iEACE,GAAG,CAAC,OAFF,CAAN;AAID;;AAID,QAAM,aAAa,GAAG,IAAI,GAAJ,EAAtB;;AACA,SAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,OAArB,EAAqB,EAAA,GAAA,SAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAA8B;AAAzB,UAAM,MAAM,GAAA,SAAA,CAAA,EAAA,CAAZ;;AAMH,UAAI,MAAM,KAAK,QAAQ,CAAC,SAAT,EAAf,EAAqC;AACnC;AACD;;AAGD,UAAI,MAAM,CAAC,MAAP,CAAc,CAAd,MAAqB,GAAzB,EAA8B;AAC5B;AACD;;AAED,MAAA,aAAa,CAAC,GAAd,CAAkB,MAAlB;AACD;;AAGD,QAAI,aAAa,CAAC,IAAd,KAAuB,CAA3B,EAA8B;AAC5B,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,mFADI,CAAN;AAGD;;AAMD,QAAM,UAAU,GAAA,OAAA,CAAA,cAAA,CAAA,CACd,QAAQ,CAAC,SAAT,EADc,CAAA,EAEX,KAAK,CAAC,IAAN,CAAW,aAAX,CAFW,CAAhB;;AAKA,QAAM,YAAY,GAAa,eAAe,CAAC,EAAD,EAAK,UAAL,CAA9C;;AAGA,QAAI,YAAY,CAAC,OAAb,CAAqB,QAAQ,CAAC,SAAT,EAArB,MAA+C,CAAC,CAApD,EAAuD;AACrD,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,wCAAwC,QAAQ,CAAC,SAAT,EAAxC,GAA+D,GAD3D,CAAN;AAGD;;AAGD,QAAI,YAAY,CAAC,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,4DADI,CAAN;AAGD;;AAGD,QAAI,YAAY,CAAC,MAAb,KAAwB,EAAE,CAAC,UAAH,CAAc,MAA1C,EAAkD;AAChD,YAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,yCADI,CAAN;AAGD;;AAGD,IAAA,YAAY,CAAC,MAAb,CAAoB,YAAY,CAAC,OAAb,CAAqB,QAAQ,CAAC,SAAT,EAArB,CAApB,EAAgE,CAAhE;AAEA,WAAO,YAAP;AACD;;AA1Fe,EAAA,KAAA,CAAA,wBAAA,GAAwB,wBAAxB;;AA+GhB,WAAgB,gBAAhB,CACE,WADF,EAEE,SAFF,EAEmB;AAEjB,WAAO,eAAe,CAAC,WAAD,EAAc,CAAC,SAAD,CAAd,CAAf,CAA0C,MAA1C,KAAqD,CAA5D;AACD;;AALe,EAAA,KAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AA8BhB,WAAgB,eAAhB,CACE,WADF,EAEE,OAFF,EAEmB;AAEjB,QAAM,mBAAmB,GAAG,WAAW,CAAC,IAAZ,EAA5B;AAEA,QAAM,YAAY,GAAG,OAAA,CAAA,OAAA,CAAM,WAAW,CAAC,UAAlB,CAArB;AACA,QAAM,YAAY,GAAG,IAAI,GAAJ,EAArB;;AAEA,SAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,OAArB,EAAqB,EAAA,GAAA,SAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAA8B;AAAzB,UAAM,MAAM,GAAA,SAAA,CAAA,EAAA,CAAZ;;AACH,UAAI,YAAY,CAAC,MAAb,KAAwB,CAA5B,EAA+B;AAC7B;AACD;;AAED,UAAI,OAAO,GAAA,KAAA,CAAX;;AACA,UAAI;AACF,QAAA,OAAO,GAAG,cAAA,CAAA,OAAA,CAAQ,aAAR,CAAsB,MAAtB,CAAV;AACD,OAFD,CAEE,OAAO,GAAP,EAAY;AACZ,cAAM,IAAI,QAAA,CAAA,0BAAJ,CACJ,oCAAoC,GAAG,CAAC,OADpC,CAAN;AAGD;;AAED,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,YAAM,MAAM,GAAG,YAAY,CAAC,CAAD,CAA3B;;AAEA,YAAI,CAAC,MAAM,CAAC,IAAP,GAAc,MAAd,CAAqB,OAAO,CAAC,aAAR,EAArB,CAAL,EAAoD;AAClD;AACD;;AAED,YAAI,OAAO,CAAC,MAAR,CAAe,mBAAf,EAAoC,MAAM,CAAC,SAAP,EAApC,CAAJ,EAA6D;AAC3D,UAAA,YAAY,CAAC,GAAb,CAAiB,MAAjB;AACA,UAAA,YAAY,CAAC,MAAb,CAAoB,CAApB,EAAuB,CAAvB;AACA;AACD;AACF;AACF;;AAED,WAAO,KAAK,CAAC,IAAN,CAAW,YAAX,CAAP;AACD;;AAvCe,EAAA,KAAA,CAAA,eAAA,GAAe,eAAf;;AAiDhB,WAAS,kBAAT,CAA4B,WAA5B,EAAoD;AAClD,QAAI,CAAC,WAAW,CAAC,UAAjB,EAA6B;AAC3B,aAAO,KAAP;AACD;;AAED,QAAM,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,KAAa,IAAxB,CAAZ;AACM,QAAA,EAAA,GAAuB,WAAW,CAAC,UAAnC;AAAA,QAAE,OAAO,GAAA,EAAA,CAAA,OAAT;AAAA,QAAW,OAAO,GAAA,EAAA,CAAA,OAAlB;AAEN,WACE,GAAG,IAAI,MAAM,CAAC,QAAP,CAAgB,OAAhB,EAAyB,EAAzB,CAAP,IAAuC,GAAG,IAAI,MAAM,CAAC,QAAP,CAAgB,OAAhB,EAAyB,EAAzB,CADhD;AAGD;AACF,CApkBD,EAAiB,KAAK,GAAL,OAAA,CAAA,KAAA,KAAA,OAAA,CAAA,KAAA,GAAK,EAAL,CAAjB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Utils = void 0;\nvar tslib_1 = require(\"tslib\");\nvar clone_1 = tslib_1.__importDefault(require(\"lodash/clone\"));\nvar randombytes_1 = tslib_1.__importDefault(require(\"randombytes\"));\nvar stellar_base_1 = require(\"stellar-base\");\nvar errors_1 = require(\"./errors\");\nvar Utils;\n(function (Utils) {\n    function buildChallengeTx(serverKeypair, clientAccountID, homeDomain, timeout, networkPassphrase) {\n        if (timeout === void 0) { timeout = 300; }\n        if (clientAccountID.startsWith(\"M\")) {\n            throw Error(\"Invalid clientAccountID: multiplexed accounts are not supported.\");\n        }\n        var account = new stellar_base_1.Account(serverKeypair.publicKey(), \"-1\");\n        var now = Math.floor(Date.now() / 1000);\n        var value = randombytes_1.default(48).toString(\"base64\");\n        var transaction = new stellar_base_1.TransactionBuilder(account, {\n            fee: stellar_base_1.BASE_FEE,\n            networkPassphrase: networkPassphrase,\n            timebounds: {\n                minTime: now,\n                maxTime: now + timeout,\n            },\n        })\n            .addOperation(stellar_base_1.Operation.manageData({\n            name: homeDomain + \" auth\",\n            value: value,\n            source: clientAccountID,\n        }))\n            .build();\n        transaction.sign(serverKeypair);\n        return transaction\n            .toEnvelope()\n            .toXDR(\"base64\")\n            .toString();\n    }\n    Utils.buildChallengeTx = buildChallengeTx;\n    function readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains) {\n        var _a;\n        if (serverAccountID.startsWith(\"M\")) {\n            throw Error(\"Invalid serverAccountID: multiplexed accounts are not supported.\");\n        }\n        var transaction = stellar_base_1.TransactionBuilder.fromXDR(challengeTx, networkPassphrase);\n        if (!(transaction instanceof stellar_base_1.Transaction)) {\n            throw new errors_1.InvalidSep10ChallengeError(\"Invalid challenge: expected a Transaction but received a FeeBumpTransaction\");\n        }\n        var sequence = Number.parseInt(transaction.sequence, 10);\n        if (sequence !== 0) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction sequence number should be zero\");\n        }\n        if (transaction.source !== serverAccountID) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction source account is not equal to the server's account\");\n        }\n        if (transaction.operations.length < 1) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction should contain at least one operation\");\n        }\n        var _b = transaction.operations, operation = _b[0], subsequentOperations = _b.slice(1);\n        if (!operation.source) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation should contain a source account\");\n        }\n        var clientAccountID = operation.source;\n        if (operation.type !== \"manageData\") {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation type should be 'manageData'\");\n        }\n        if (transaction.timeBounds &&\n            Number.parseInt((_a = transaction.timeBounds) === null || _a === void 0 ? void 0 : _a.maxTime, 10) === stellar_base_1.TimeoutInfinite) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction requires non-infinite timebounds\");\n        }\n        if (!validateTimebounds(transaction)) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction has expired\");\n        }\n        if (Buffer.from(operation.value.toString(), \"base64\").length !== 48) {\n            throw new errors_1.InvalidSep10ChallengeError(\"The transaction's operation value should be a 64 bytes base64 random string\");\n        }\n        if (!homeDomains) {\n            throw new errors_1.InvalidSep10ChallengeError(\"Invalid homeDomains: a home domain must be provided for verification\");\n        }\n        var matchedHomeDomain;\n        if (typeof homeDomains === \"string\") {\n            if (homeDomains + \" auth\" === operation.name) {\n                matchedHomeDomain = homeDomains;\n            }\n        }\n        else if (Array.isArray(homeDomains)) {\n            matchedHomeDomain = homeDomains.find(function (domain) { return domain + \" auth\" === operation.name; });\n        }\n        else {\n            throw new errors_1.InvalidSep10ChallengeError(\"Invalid homeDomains: homeDomains type is \" + typeof homeDomains + \" but should be a string or an array\");\n        }\n        if (!matchedHomeDomain) {\n            throw new errors_1.InvalidSep10ChallengeError(\"Invalid homeDomains: the transaction's operation key name does not match the expected home domain\");\n        }\n        for (var _i = 0, subsequentOperations_1 = subsequentOperations; _i < subsequentOperations_1.length; _i++) {\n            var op = subsequentOperations_1[_i];\n            if (op.type !== \"manageData\") {\n                throw new errors_1.InvalidSep10ChallengeError(\"The transaction has operations that are not of type 'manageData'\");\n            }\n            if (op.source !== serverAccountID) {\n                throw new errors_1.InvalidSep10ChallengeError(\"The transaction has operations that are unrecognized\");\n            }\n        }\n        return { tx: transaction, clientAccountID: clientAccountID, matchedHomeDomain: matchedHomeDomain };\n    }\n    Utils.readChallengeTx = readChallengeTx;\n    function verifyChallengeTxThreshold(challengeTx, serverAccountID, networkPassphrase, threshold, signerSummary, homeDomains) {\n        var _a;\n        var signers = signerSummary.map(function (signer) { return signer.key; });\n        var signersFound = verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains);\n        var weight = 0;\n        var _loop_1 = function (signer) {\n            var sigWeight = ((_a = signerSummary.find(function (s) { return s.key === signer; })) === null || _a === void 0 ? void 0 : _a.weight) || 0;\n            weight += sigWeight;\n        };\n        for (var _i = 0, signersFound_1 = signersFound; _i < signersFound_1.length; _i++) {\n            var signer = signersFound_1[_i];\n            _loop_1(signer);\n        }\n        if (weight < threshold) {\n            throw new errors_1.InvalidSep10ChallengeError(\"signers with weight \" + weight + \" do not meet threshold \" + threshold + \"\\\"\");\n        }\n        return signersFound;\n    }\n    Utils.verifyChallengeTxThreshold = verifyChallengeTxThreshold;\n    function verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains) {\n        var tx = readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains).tx;\n        var serverKP;\n        try {\n            serverKP = stellar_base_1.Keypair.fromPublicKey(serverAccountID);\n        }\n        catch (err) {\n            throw new Error(\"Couldn't infer keypair from the provided 'serverAccountID': \" +\n                err.message);\n        }\n        var clientSigners = new Set();\n        for (var _i = 0, signers_1 = signers; _i < signers_1.length; _i++) {\n            var signer = signers_1[_i];\n            if (signer === serverKP.publicKey()) {\n                continue;\n            }\n            if (signer.charAt(0) !== \"G\") {\n                continue;\n            }\n            clientSigners.add(signer);\n        }\n        if (clientSigners.size === 0) {\n            throw new errors_1.InvalidSep10ChallengeError(\"No verifiable client signers provided, at least one G... address must be provided\");\n        }\n        var allSigners = tslib_1.__spreadArrays([\n            serverKP.publicKey()\n        ], Array.from(clientSigners));\n        var signersFound = gatherTxSigners(tx, allSigners);\n        if (signersFound.indexOf(serverKP.publicKey()) === -1) {\n            throw new errors_1.InvalidSep10ChallengeError(\"Transaction not signed by server: '\" + serverKP.publicKey() + \"'\");\n        }\n        if (signersFound.length === 1) {\n            throw new errors_1.InvalidSep10ChallengeError(\"None of the given signers match the transaction signatures\");\n        }\n        if (signersFound.length !== tx.signatures.length) {\n            throw new errors_1.InvalidSep10ChallengeError(\"Transaction has unrecognized signatures\");\n        }\n        signersFound.splice(signersFound.indexOf(serverKP.publicKey()), 1);\n        return signersFound;\n    }\n    Utils.verifyChallengeTxSigners = verifyChallengeTxSigners;\n    function verifyTxSignedBy(transaction, accountID) {\n        return gatherTxSigners(transaction, [accountID]).length !== 0;\n    }\n    Utils.verifyTxSignedBy = verifyTxSignedBy;\n    function gatherTxSigners(transaction, signers) {\n        var hashedSignatureBase = transaction.hash();\n        var txSignatures = clone_1.default(transaction.signatures);\n        var signersFound = new Set();\n        for (var _i = 0, signers_2 = signers; _i < signers_2.length; _i++) {\n            var signer = signers_2[_i];\n            if (txSignatures.length === 0) {\n                break;\n            }\n            var keypair = void 0;\n            try {\n                keypair = stellar_base_1.Keypair.fromPublicKey(signer);\n            }\n            catch (err) {\n                throw new errors_1.InvalidSep10ChallengeError(\"Signer is not a valid address: \" + err.message);\n            }\n            for (var i = 0; i < txSignatures.length; i++) {\n                var decSig = txSignatures[i];\n                if (!decSig.hint().equals(keypair.signatureHint())) {\n                    continue;\n                }\n                if (keypair.verify(hashedSignatureBase, decSig.signature())) {\n                    signersFound.add(signer);\n                    txSignatures.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return Array.from(signersFound);\n    }\n    Utils.gatherTxSigners = gatherTxSigners;\n    function validateTimebounds(transaction) {\n        if (!transaction.timeBounds) {\n            return false;\n        }\n        var now = Math.floor(Date.now() / 1000);\n        var _a = transaction.timeBounds, minTime = _a.minTime, maxTime = _a.maxTime;\n        return (now >= Number.parseInt(minTime, 10) && now <= Number.parseInt(maxTime, 10));\n    }\n})(Utils = exports.Utils || (exports.Utils = {}));\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}